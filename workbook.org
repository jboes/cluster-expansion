* ATAT
This section is designated for all ATAT related calculation and analysis.

** Calculations
Section for setting up various ATAT calculations.

*** Binary alloy calculations
Here we initialize files using a dynamic scaling method which adjusts the lattice size depending on the alloy composition.

#+BEGIN_SRC python :results silent
import numpy as np
from subprocess import call

# This code is used to get a better starting point for lattice constant
lattice = np.array([3.631, 3.712, 3.792, 3.872, 3.953])
rad = 1 / (2*np.sqrt(2)) * lattice
scale = rad[2] / rad[-1]

call(["makelat", "-s={0}".format(scale), "Cu,Pd", "fcc,bcc"])

script = '''[INCAR]
ENCUT = 400
NSW = 50
IBRION = 2
ISIF = 7
KPPRA = 2500
EDIFF = 1e-6
GGA = PS
USEPOT = PAWPBE
'''

with open('vasp.wrap', 'w') as f:
    f.write(script)
#+END_SRC

In this section we begin generate certain number of initial configurations predicted to be unique by ATAT using the existing cluster expansion. The second portion of the code then performs VASP calculations on these structures.

#+BEGIN_SRC python :results silent
import os
import time

# The number of structures to create
N = 10

for d in ['./CuPd_bcc', './CuPd_fcc']:
    os.chdir(d)
    os.system('maps -t=0.25 &')
    for n in range(N):
        open('ready', 'w').close()
        while os.path.exists('ready'):
            time.sleep(0.1)
    open('stop', 'w').close()

time.sleep(3)

# In this section we perfrom VASP calculations on all non-completed configurations
from subprocess import call
for d in ['./CuPd_bcc', './CuPd_fcc']:
    os.chdir(d)
    call(["foreachfile", "wait", "run_atat_vasp.py"])
#+END_SRC

*** Status check
This code performs a simple iteration over all of the structures generated by ATAT and reports their status.

#+BEGIN_SRC python
from subprocess import call

for d in ['./CuPd_bcc', './CuPd_fcc']:
    call(["atatstatus.py", d])
#+END_SRC

** Analysis
Analysis of ATAT calculations.

*** Ground state hull of the
#+caption: Ground state hull of CuPd for fcc and bcc phases.
#+label: fig-cupd-gs
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/groundstate.png]]

#+BEGIN_SRC python : results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
JASPRC['restart_unconverged'] = False

config = ['fcc', 'bcc']
color = ['b', 'r']

plt.figure()
plt.plot([0.0, 1.0], [0, 0], 'k--')

for i, cfg in enumerate(config):

    with open('CuPd_{0}/gs.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        GS, EGS, CGS = [], [], []

        for line in lines:
            # Composition, DFT energy, Fit energy, Configuration
            x, y, z, c = line.split()

            CGS.append(x)
            EGS.append(y)
            GS.append(c)

    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        C, E = [], []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            x, y, z, e, w, c = line.split()

            C.append(x)
            E.append(y)

    plt.scatter(C, E, c='k', s=15)
    plt.plot(CGS, EGS, c='{0}'.format(color[i]), marker='o', label='{0}'.format(cfg))
    for j, gs in enumerate(GS[1:-1]):
        plt.text(CGS[1:-1][j], float(EGS[1:-1][j])-0.004,
                 '{0}'.format(gs),
                 color='{0}'.format(color[i]),
                 va='top', ha='center',
                 zorder=99)

plt.legend(loc='best')
plt.xlim(0, 1)
plt.xlabel('Composition (Pd)')
plt.ylabel('Heat of formation (eV/atom)')
plt.ylim(-0.15, 0.01)
plt.tight_layout()
plt.savefig('./images/groundstate.png')
#+END_SRC

* DFT
Section for running and organizing on going DFT calculations.

** CuPd fcc and bcc B2 configuration
Perform a high level DFT calculation on the fcc and bcc B2 phase. This is configuration 3 from the ATAT calculation set for both phases.

#+BEGIN_SRC python :results silent
from jasp import *
from ase.io import read
JASPRC['queue.walltime'] = '24:00:00'

# Run for fcc and bcc
for lbl in ['fcc', 'bcc']:

    # Get the CuPd structure for fcc and bcc from ATAT
    # Configuration '3', or B2 phase
    atoms = read('CuPd_{0}/3/CONTCAR'.format(lbl))

    # Will run these calculations on PBEsol and PBE
    for gga in ['PS', 'None']:

        with jasp('DFT/bulk={0}/config=3/xc=PBE/gga={1}'.format(lbl, gga),
                  xc='PBE',
                  gga='{0}'.format(gga),
                  encut=400,
                  kpts=(12, 12, 12),
                  nsw=10,
                  ibrion=2,
                  isif=7,
                  ediff=1e-8,
                  atoms=atoms) as calc:
            try:
                calc.calculate()
            except(VaspQueued, VaspSubmitted):
                pass
#+END_SRC

** fcc to fcc transition through bct geometry
*** data generation
#+BEGIN_SRC python :results silent
from ase.lattice.tetragonal import CenteredTetragonal as bct
import numpy as np
from ase.visualize import view
from jbutil import makedb
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

# Configuration '3' for fcc
with jasp('DFT/bulk=fcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

# This is the 'a' parameter from the calculation
afcc = np.linalg.norm(cell[0])

# Configuration '3' for bcc i.e. B2
with jasp('DFT/bulk=bcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

# This is the 'a' parameter from the calculation
abcc = np.linalg.norm(cell[0])

# Create a list of sample points
ca0 = np.linspace(0.9, 1.5, 31)
ca0 = np.append(ca0, [np.sqrt(2)])
a0 = np.linspace(2.5, 3.1, 31)
a0 = np.append(a0, [afcc, abcc])

for a in a0:

    for ca in ca0:

        # Generate structure based on sample points
        atoms = bct('Cu', latticeconstant={'a': a, 'c/a': ca})
        atoms[1].symbol = 'Pd'

        wd = 'DFT/bulk=bct/config=3/a={0}/ca={1}/xc=PBE/gga=PS'.format(a, ca)

        with jasp(wd,
                  xc='PBE',
                  gga='PS',
                  encut=400,
                  kpts=(12, 12, 12),
                  ibrion=-1,
                  ediff=1e-8,
                  atoms=atoms) as calc:
            try:
                calc.calculate()
            except(VaspQueued, VaspSubmitted):
                pass
#+END_SRC

*** data visualization
#+caption: 3D Minimum energy pathway of fcc to bcc transition through bct geometry space.
#+label: fig-3d-cupd-min
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/3D-bcc-pathway.png]]

#+BEGIN_SRC python
from ase.lattice.tetragonal import CenteredTetragonal as bct
from ase.db import connect
from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt
from matplotlib import cm
from jasp import *
from jbutil import makedb
JASPRC['queue.walltime'] = '24:00:00'

# Retrive the data
db = connect('data.db')
A, C = [], []
E = {}
for d in db.select([]):

    if d.a not in E.keys():
        E[d.a] = {}
    if d.ca not in E[d.a].keys():
        E[d.a][d.ca] = d.total_energy

    A.append(d.a)
    C.append(d.ca)

with jasp('DFT/bulk=fcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

    efcc = atoms.get_potential_energy()
    afcc = np.linalg.norm(cell[0])

with jasp('DFT/bulk=bcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

    ebcc = atoms.get_potential_energy()
    abcc = np.linalg.norm(cell[0])

uA = np.unique(A)
uC = np.unique(C)
X, Y = np.meshgrid(uA, uC)
Z = np.zeros(X.shape)

for i, a in enumerate(uA):
    for j, c in enumerate(uC):
        Z[j][i] = E[a][c]

fccZ, bccZ = [], []
eminZ = []
cminZ = []
aminZ = []

for i, c in enumerate(uC[5:-5]):
    data = Z[i+5, :]
    ind = data.tolist().index(min(data))

    eminZ.append(min(data))
    cminZ.append(c)
    aminZ.append(uA[ind])


rng = [ebcc, -10.2]

Z[Z > rng[1]] = np.nan

fig = plt.figure(figsize=(8, 6))
ax = fig.gca(projection='3d')
CM = cm.autumn

cset = ax.contourf(X, Y, Z, zdir='z', offset=-10.8, cmap=CM, vmin=rng[0], vmax=rng[1])

ax.plot_surface(X, Y, Z,
                rstride=1,
                cstride=1,
                cmap=CM,
                linewidth=0,
                vmin=rng[0],
                vmax=rng[1])


ax.scatter(aminZ[1:-1], cminZ[1:-1], eminZ[1:-1], c='k')

ax.plot([afcc, afcc], [np.sqrt(2), np.sqrt(2)], [-10.8, eminZ[-1]], 'go-', zorder=99)
ax.text(afcc, np.sqrt(2), eminZ[-1]+0.01, 'fcc', color='g', zorder=99, size='large')

ax.plot([abcc, abcc], [1.0, 1.0], [-10.8, eminZ[0]], 'bo-', zorder=99)
ax.text(abcc, 1.0, eminZ[0]+0.01, 'bcc', color='b', zorder=99, size='large')

ax.set_xlabel('a')
ax.set_xlim(2.4, 3.2)
ax.set_ylabel('c/a')
ax.set_ylim(0.8, 1.6)
ax.set_zlabel('Total energy (eV)')
ax.set_zlim(-10.8, rng[1])
plt.tight_layout()
plt.savefig('images/3D-bcc-pathway.png')

for i, ca in enumerate(cminZ):

    atoms = bct('Cu', latticeconstant={'a': aminZ[i], 'c/a': ca})
    atoms[1].symbol = 'Pd'

    wd = 'DFT/bulk=bct/config=3/pathway=True/ca={0}/xc=PBE/gga=None'.format(ca)

    with jasp(wd,
              xc='PBE',
              encut=400,
              kpts=(12, 12, 12),
              nsw=20,
              ibrion=2,
              isif=7,
              ediff=1e-9,
              atoms=atoms) as calc:
        try:
            calc.calculate()
        except(VaspQueued, VaspSubmitted):
            pass
#+END_SRC

** Generation of EOS from all ATAT configurations
Generates an EOS for each of the configurations produced by ATAT. This is done for both the fcc and bcc phase cluster expansions.

#+BEGIN_SRC python :results silent
import numpy as np
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

# For fcc and bcc configurations
for i, cfg in enumerate(['fcc', 'bcc']):

    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        # Begin a list of configurations
        C = []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            x, y, z, e, w, c = line.split()

            # We only need the configuration
            C.append(c)

    # Fraction of equilibrium lattice constant to be calculated.
    frac_eos = np.append(np.linspace(0.85, 1.15, 61), np.linspace(1.2, 2.0, 17))

    # This array represents all types of deformations we want to calculate.
    # The nominclature being used is as follows:
    # [ x , a , c ]
    # [ a , y , b ]
    # [ c , b , z ]
    # where a, b, and c are the xy, yz, and zx tensors, respectively.
    deformations = [['xyz', frac_eos]]

    for j, c in enumerate(C):

        for dfm in deformations:

            for frac in dfm[1]:

                # This code retrieves the optimized volume and atom positions from the ISIF=3 calculation.
                with jasp('CuPd_{0}/{1}'.format(cfg, c)) as calc:
                    atoms = calc.get_atoms()
                    cell0 = atoms.get_cell()
                    k1, k2, k3 = calc.input_params['kpts']

                dis = {}
                for vector in ['x', 'y', 'z', 'a', 'b', 'c']:
                    dis[vector] = 1.0

                    if vector in dfm[0]:
                        dis[vector] = frac

                delta = np.array([[dis['x']      , 0.5 * (dis['a'] - 1), 0.5 * (dis['c'] - 1)],
                                  [0.5 * (dis['a'] - 1), dis['y']      , 0.5 * (dis['b'] - 1)],
                                  [0.5 * (dis['c'] - 1), 0.5 * (dis['b'] - 1), dis['z']      ]])

                # This line adjusts the cell volume by the fraction specified above. 
                # The atoms are scaled accordingly inside the new unit cell.
                atoms.set_cell(np.dot(cell0, delta), scale_atoms=True)
                wd = 'DFT/bulk={0}/config={1}/strain={2}/factor={3}/xc=PBE/gga=PS'.format(cfg, c, dfm[0], frac)

                try:
                    with jasp(wd,
                              xc='PBE',
                              gga='PS',
                              kpts=(k1, k2, k3),
                              encut=400,
                              ibrion=-1,
                              ediff=1e-8,
                              atoms=atoms) as calc:
                        try:
                            atoms = calc.get_atoms()
                            nrg = atoms.get_potential_energy()
                            print 
                        except(VaspSubmitted, VaspQueued):
                            print wd, 'Queued'
                except(IOError):
                    print wd, 'IOError'
                except(VaspNotFinished):
                    print wd, 'VaspNotFinished'
#+END_SRC

** Relaxations of root 7 x root 7 slab (manual)
Manually determined configurations of an fcc root(7) \times root(7) slab. Only the chemical symbols of the first layer are allowed to change between Cu and Pd.

*** Full relaxation
#+BEGIN_SRC python
from jasp import *
from ase.lattice.surface import fcc111_root
import numpy as np

# Energy unique configurations were manually determined 
configurations = {0:[[]],
                  1:[[32]],
                  2:[[32, 31]],
                  3:[[28, 31, 32],
                     [31, 32, 33]],
                  4:[[29, 30, 33, 34],
                     [28, 29, 30, 34]],
                  5:[[28, 29, 30, 33, 34]],
                  6:[[28, 29, 30, 31, 33, 34]],
                  7:[[28, 29, 30, 31, 32, 33, 34]]}

basis = [['Cu', 'Pd', 3.634],
         ['Pd', 'Cu', 3.939]]

for base in basis:
    b, i, a = base
    for j, cfgs in configurations.iteritems():
        for k, cfg in enumerate(cfgs):

            atoms = fcc111_root(b, 7, [1, 1, 5], a=a)
            for l in cfg:
                atoms[l].symbol = i
            wd = 'DFT/surf=fcc/host={0}/lattice={1:1.3f}/cnt={2}/config={3}'.format(b, a, j, k)

            with jasp(wd,
                      xc='PBE',
                      gga='PS',
                      encut=400,
                      kpts=(5, 5, 1),
                      ibrion=2,
                      isif=2,
                      nsw=40,
                      ediff=1e-5,
                      atoms=atoms) as calc:
                try:
                    atoms = calc.get_atoms()
                    nrg = atoms.get_potential_energy()
                except(VaspQueued, VaspSubmitted):
                    print wd, 'Queued'
#+END_SRC

*** Strain effects xy
#+BEGIN_SRC python
from jasp import *
from ase.lattice.surface import fcc111_root
import numpy as np
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 4

configurations = {0:[[]],
                  1:[[32]],
                  2:[[32, 31]],
                  3:[[28, 31, 32],
                     [31, 32, 33]],
                  4:[[29, 30, 33, 34],
                     [28, 29, 30, 34]],
                  5:[[28, 29, 30, 33, 34]],
                  6:[[28, 29, 30, 31, 33, 34]],
                  7:[[28, 29, 30, 31, 32, 33, 34]]}

basis = [['Cu', 'Pd', 3.634, np.linspace(0.96, 1.16, 14)],
         ['Pd', 'Cu', 3.939, np.linspace(0.84, 1.04, 14)]]

cells = {}
for b, i, a, fac in basis:
    with jasp('DFT/surf=fcc/host={0}/lattice={1:1.3f}/cnt=0/config=0'.format(b, a)) as calc:
        atoms = calc.get_atoms()
        cell0 = atoms.get_cell()

    pos = atoms.get_positions()
    z = pos[12][-1] - pos[5][-1]
    cells['{0:1.3f}'.format(z)] = []
    for f in fac:
        delta = np.array([[f, 0, 0],
                          [0, f, 0],
                          [0, 0, 1.0]])

        cells['{0:1.3f}'.format(z)].append(np.dot(cell0, delta))
    cells['{0:1.3f}'.format(z)] = np.array(cells['{0:1.3f}'.format(z)])

for b, i, a, fac in basis:

    for j, cfgs in configurations.iteritems():
        for k, cfg in enumerate(cfgs):

            for z, cell in cells.iteritems():

                for c in cell:

                    wd = 'DFT/surf=fcc/host={0}/lattice={1:1.3f}/cnt={2}/config={3}'.format(b, a, j, k)

                    with jasp(wd) as calc:
                        atoms = calc.get_atoms()

                    atoms.set_cell(c, scale_atoms=True)

                    pos = atoms.get_positions()
                    lat = np.linalg.norm(pos[5] - pos[12])

                    nwd = 'DFT/surf=fcc/host={0}/z={1}/xy={2:1.3f}/cnt={3}/config={4}'.format(b, z, lat, j, k)
                    print nwd

                    with jasp(nwd,
                              xc='PBE',
                              gga='PS',
                              encut=400,
                              kpts=(5, 5, 1),
                              ibrion=-1,
                              ediff=1e-5,
                              atoms=atoms) as calc:
                        try:
                            calc.get_required_memory()
                            atoms = calc.get_atoms()
                            nrg = atoms.get_potential_energy()
                        except(VaspSubmitted, VaspQueued):
                            pass
#+END_SRC

** EMT unique configurations
DFT calculations to perform on EMT determined energy unique configurations.

*** 2 free-layer configurations
**** Ground state
#+BEGIN_SRC python :results silent
from ase.lattice.surface import fcc111_root
from ase.db import connect
from jasp import *
from ase.constraints import FixAtoms
from ase.visualize import view
import jbutil as jb
JASPRC['queue.ppn'] = 4
JASPRC['restart_unconverged'] = False

db = connect('traj/unique-2layer.db')

basis = [['Cu', 3.634], ['Pd', 3.939]]

UF = []
for base in basis:

    b, a = base

    for i, d in enumerate(db.select()):

        atoms = fcc111_root(b, 7, [1, 1, 5], a=a, vacuum=6.0)
        n = [atom.index for atom in atoms if atom.tag <= 2]
        cfg = d.symbols[21:]

        for j, s in enumerate(n):
            atoms[s].symbol = cfg[j]

        constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
        atoms.set_constraint(constraint)

        wd = 'DFT/surf=fcc/host={0}/lattice={1:1.3f}/type=layers2/cfg={2}/xy=1.00'.format(b, a, i)

        try:
            with jasp(wd,
                      xc='PBE',
                      encut=400,
                      kpts=(5, 5, 1),
                      ibrion=2,
                      isif=2,
                      nsw=40,
                      ediff=1e-5,
                      atoms=atoms) as calc:
                try:
                    calc.get_required_memory()
                    atoms = calc.get_atoms()
                    nrg = atoms.get_potential_energy()
                    print nrg
                except(VaspQueued, VaspSubmitted):
                    pass
        except(VaspNotFinished):
            UF += [wd]
            jb.reset(wd)

JASPRC['restart_unconverged'] = True

for wd in UF:
    with jasp(wd) as calc:
        try:
            calc.get_required_memory()
            calc.calculate()
        except(VaspQueued, VaspSubmitted):
            pass
#+END_SRC

**** Strain effects xyz
#+BEGIN_SRC python :results silent
import numpy as np
import os
from jasp import *
from ase.visualize import view
JASPRC['queue.ppn'] = 5
JASPRC['queue.walltime'] = '24:00:00'

# Fraction determined by hand, but could also be calculated from fcc lattice geometry
# basis = [['Cu', 3.634, np.linspace(1.00, 1.08392955421, 4)],]
basis = [['Pd', 3.939, np.linspace(1.00, 1.0/1.08392955421, 4)]]

for M, a, factors in basis:

    for cfg in range(343): # The number of unique 2-layer configurations

        wd0 = 'DFT/surf=fcc/host={0}/lattice={1}/type=layers2/cfg={2}/xy=1.00'.format(M, a, cfg)

        for f in factors:

            # For each configurations, start from relaxed geom and apply isotropic strain
            delta = np.array([[f, 0, 0],
                              [0, f, 0],
                              [0, 0, f]])

            with jasp(wd0) as calc:
                atoms = calc.get_atoms()
                cell = atoms.get_cell()

            atoms.set_cell(np.dot(cell, delta), scale_atoms=True)
            lat = atoms.get_distance(2, 10)

            wd = './DFT/surf=fcc/host={0}/lattice={1:1.3f}/type=layers2/cfg={2}/xy=1.00'.format(M, lat, cfg)

            if not os.path.exists(wd):
                with jasp(wd,
                          xc='PBE',
                          encut=400,
                          kpts=(5, 5, 1),
                          ibrion=-1,
                          atoms=atoms) as calc:
                    try:
                        calc.get_required_memory()
                        calc.calculate()
                    except(VaspSubmitted, VaspQueued):
                        pass
#+END_SRC

*** bulk
#+BEGIN_SRC python :results silent
from jasp import *
from ase.io import read
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 4

images = read('traj/unique-bulk.db')

f =  3.634 / 3.939
delta = np.array([[f, 0, 0],
                  [0, f, 0],
                  [0, 0, f]])

for i, atoms in enumerate(images):
    cell0 = atoms.get_cell()
    atoms.set_cell(np.dot(cell0, delta), scale_atoms=True)

    wd = 'DFT/bulk=fcc/lattice=3.634/config={0}'.format(i)

    with jasp(wd,
              xc='PBE',
              encut=400,
              kpts=(int(12/3), int(12/3), int(12/3)),
              ibrion=-1,
              atoms=atoms) as calc:
        try:
            calc.get_required_memory()
            calc.calculate()
        except(VaspSubmitted, VaspQueued):
            pass
#+END_SRC

** 3 free-layer configurations
#+BEGIN_SRC python
from ase.db import connect
import numpy as np
from ase.visualize import view
import os
from jasp import *
JASPRC['queue.ppn'] = 5
JASPRC['queue.walltime'] = '24:00:00'

db = connect('traj/unique-3layer.db')

for cfg, d in enumerate(db.select()):
    E = abs(d.NN10 / d.natoms - d.NN12 / d.natoms)
    if E > 0.11:
        atoms = db.get_atoms(d.id)
        lat = atoms.get_distance(5, 12)
        M = atoms[0].symbol

        wd = './DFT/surf=fcc/host={0}/lattice={1:1.3f}/type=layers3/cfg={2}/xy=1.00'.format(M, lat, cfg)
        if not os.path.exists(wd):
            with jasp(wd,
                      xc='PBE',
                      encut=400,
                      kpts=(5, 5, 1),
                      ibrion=-1,
                      atoms=atoms) as calc:
                try:
                    calc.get_required_memory()
                    calc.calculate()
                except(VaspSubmitted, VaspQueued):
                    pass
#+END_SRC

** Bulk configurations
*** fcc
Need to start running the worst of these calculations. (i.e. everything above 0.5 eV/atom should be a good number)

#+BEGIN_SRC python
from ase.db import connect
import numpy as np
from amp import Amp
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 4

db = connect('temp/bulk-3x3.db')

dE, ids = [], []
a, cfg = [], []
for d in db.select():
    a += [d.a]
    cfg += [d.config]
    ids += [d.id]
    dE += [abs(d.data['NN8'] / d.natoms - d.data['NN10'] / d.natoms)]

ids = np.array(ids)

# The index of energy differences greater than 0.03
ind = np.array([True if d > 0.03 else False for d in dE])

for i in ids[ind]:
    atoms = db.get_atoms(i)

    wd = 'DFT/bulk=fcc/lattice={0:1.3f}/config={1}'.format(a[i], cfg[i])

    with jasp(wd,
              xc='PBE',
              encut=400,
              kpts=(int(12/3), int(12/3), int(12/3)),
              ibrion=-1,
              atoms=atoms) as calc:
        try:
            calc.get_required_memory()
            calc.calculate()
        except(VaspSubmitted, VaspQueued):
            pass
#+END_SRC

*** bcc
Unique bcc configurations are defined by their volume per atom since this is expected to be approximately equal to that of the fcc structure.

Will begin with the extreme ends and center most lattice volumes.

#+BEGIN_SRC python
from ase.db import connect
import numpy as np
from amp import Amp
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 2
JASPRC['queue.mem'] = '1GB'

db = connect('temp/lat5-bulk-bcc.db')

vols = set()
for d in db.select():
    vols.add(d.aV)
vols = sorted(list(vols))

for d in db.select():
    if d.aV != vols[1] and d.aV != vols[3]:
        atoms = db.get_atoms(d.id)

	wd = 'DFT/bulk=bcc/Vpa={0:1.3f}/config={1}'.format(d.aV, d.cfg)

	with jasp(wd,
		  xc='PBE',
		  encut=400,
		  kpts=(int(12/3), int(12/3), int(12/3)),
		  isif=0,
		  nsw=0,
		  atoms=atoms) as calc:
	    try:
		calc.calculate()
	    except(VaspSubmitted, VaspQueued):
		pass
#+END_SRC

#+RESULTS:

[[./images/pred-mem-efficiency.png]]

#+BEGIN_SRC python
import json
from glob import glob
import matplotlib.pyplot as plt
import numpy as np

mdfiles = glob('DFT/bulk=fcc/lattice=*/config=*/METADATA')

deltas = []
for mdf in mdfiles:
    kvp = mdf.split('/')
    kvp[-1] = 'OUTCAR'
    ouf = '/'.join(kvp)

    with open(mdf) as f:
        data = json.load(f)
        req_mem = float(data['recommended.memory'])

    with open(ouf) as f:
        lines = f.readlines()
        for line in lines:
            if 'memory' in line:
                act_mem = float(line.split()[-2]) / 1e6
                break

    delta = float(req_mem - act_mem)
    deltas += [delta]

deltas = np.array(deltas)

def nbins(x):
    from math import ceil
    n = 1
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)


plt.figure(figsize=(6, 4))
plt.hist(deltas, bins=nbins(max(deltas)), color='r', alpha=0.5)
plt.xlabel('Over estimation of required memory (GB)')
plt.ylabel('Count')
plt.tight_layout()
plt.savefig('./images/pred-mem-efficiency.png')
#+END_SRC

Get calculation times with 4 ppn

[[./images/pred-time-bulk.png]]

#+BEGIN_SRC python
from glob import glob
import matplotlib.pyplot as plt
import numpy as np

files = glob('DFT/bulk=fcc/lattice=*/config=*/OUTCAR')


times = []
for outcar in files:

    with open(outcar) as f:
        lines = f.readlines()
        for line in lines:
            if 'Elapsed time' in line:
                times += [float(line.split()[-1]) / 60. / 60. * 2]
                break

times = np.array(times)

def nbins(x):
    from math import ceil
    n = 0
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
plt.hist(times, bins=nbins(max(times)), color='r', alpha=0.5)
plt.xlabel('Estimated time required for 2 ppn (hrs)')
plt.ylabel('Count')
plt.tight_layout()
plt.savefig('./images/pred-time-bulk.png')
#+END_SRC

[[./images/pred-mem-bulk.png]]

#+BEGIN_SRC python
from glob import glob
import matplotlib.pyplot as plt
import numpy as np

files = glob('DFT/bulk=fcc/lattice=*/config=*/OUTCAR')


mems = []
for outcar in files:

    with open(outcar) as f:
        lines = f.readlines()
        for line in lines:
            if 'memory' in line:
                mems += [float(line.split()[-2]) / 1e6]
                break

mems = np.array(mems)

def nbins(x):
    from math import ceil
    n = 1
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
plt.hist(mems, bins=nbins(max(mems)), color='r', alpha=0.5)
plt.xlabel('Memory required for 4 ppn (GB)')
plt.ylabel('Count')
plt.tight_layout()
plt.savefig('./images/pred-mem-bulk.png')
#+END_SRC

#+RESULTS:

* AMP
Section for AMP related utilities.

** Preparation tools
Generate a database from a set of DFT calculations and creates the necessary training set from it.

#+BEGIN_SRC python :results silent
import jbtools.gilgamesh as jb

# Create the database from the DFT directory
jb.write_database('DFT/bulk=fcc/lattice=3.787', db='networks/db5/data.db')
jb.write_database('DFT/bulk=fcc/lattice=3.863', db='networks/db5/data.db')
#+END_SRC

#+BEGIN_SRC python
import jbtools.neural as jbn

# Produce a trainset with 90% of the database calculations
jbn.produce_trainset('networks/db5/data.db', fraction=0.9)
#+END_SRC

#+RESULTS:

** Running AMP locally
Run AMP on the local machine ONLY. Copy the submit.sh and submit.py files from an existing networks directory to train on node 40 on Gilgamesh.

#+BEGIN_SRC python :results silent
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork

for n in [6, 8]:
    label = "./networks/db4-bulk/"

    calc = Amp(label=label + "40-{0}-{0}-1/".format(n),
               descriptor=Behler(cutoff=6.5),
               regression=NeuralNetwork(hiddenlayers=(2, n)))

    calc.train(label + "train.db",
               cores=3,
               energy_goal=0.0005,
               extend_variables=False)
#+END_SRC

** Status of network
#+BEGIN_SRC python :results raw
import os
import json

print('|Hidden layers|Iteration|Time|Cost Function|Energy RMSE|Force RMSE|')
print('|-')

for r, d, f in os.walk('networks/db4-bulk/'):
    if 'train-log.txt' in f:
        with open(os.path.join(r, 'train-log.txt'), 'r') as fi:
            v = fi.readlines()[-5].split()

    if 'trained-parameters.json' in f:
        with open(os.path.join(r, 'trained-parameters.json'), 'r') as fi:
            p = json.load(fi)
        n = p['hiddenlayers']
        print('|{0}|{1}|{2}|{3}|{4}|{5}|'.format(n, v[0], v[1], v[2], v[3], v[4]))
#+END_SRC

#+RESULTS:
| Hidden layers                  | Iteration | Time                | Cost Function | Energy RMSE | Force RMSE |
|--------------------------------+-----------+---------------------+---------------+-------------+------------|
| {u'Cu': [2, 8], u'Pd': [2, 8]} |      5146 | 2016-01-25T00:09:08 |     4.787e+00 |   2.539e-03 |  4.025e-01 |
| {u'Cu': [2, 6], u'Pd': [2, 6]} |      6159 | 2016-01-25T07:23:57 |     4.819e+00 |   2.169e-03 |  4.040e-01 |

** Adding AMP energies to database
This code is used to add the energy predictions from various NN to a particular database.

*** db3 unique configurations
#+BEGIN_SRC python :results silent
from ase.db import connect
from ase.io import read
from amp import Amp

images = read('traj/unique-config.db')

with connect('temp/db3-config.db') as db:
 
    for atoms in images:

        data = {}
        for d, l in [[2, 10], [2, 12],
                     [3, 6], [3, 7], [3, 8]]:

            key = 'db{0}-{1}'.format(d, l)
            calc = Amp('networks/db{0}/40-{1}-{1}-1/'.format(d, l))
            atoms.set_calculator(calc)
            data[key] = atoms.get_potential_energy()

        atoms.set_calculator(None)

        db.write(atoms, data=data)
#+END_SRC

*** 5 free-layers -- 2 \times 2 slab
#+BEGIN_SRC python :results silent
from ase.db import connect
from ase.io import read
from amp import Amp

images = read('traj/cfg2x2-5layer.db')

with connect('temp/cfg2x2-5layer-db3.db') as db:
    data = {}
    for atoms in images:
        for l in [6, 7]:

            key = 'db3-{0}'.format(l)
            calc = Amp('networks/db3/40-{0}-{0}-1/'.format(l))
            atoms.set_calculator(calc)
            data[key] = atoms.get_potential_energy()

        atoms.set_calculator(None)
        db.write(atoms, data=data)
#+END_SRC

*** Bulk -- 3 \times 3 \times 3 -- 10 lattice
Here we generate a temporary database of the energy unique EMT configurations and expand it to 10 different lattice constants. Also, predictions from db4 NNs are added for comparison.

#+BEGIN_SRC python :results silent
import numpy as np
from ase.db import connect
from ase.io import read
from amp import Amp
from ase import Atoms
# Pull unique bulk structures predicted from EMT
images = read('traj/unique-bulk.db')

# Create a new temporary database
with connect('temp/db5-3x3-bulk.db') as db:

    # Generate structures at 5 different lattice constants
    for lat in np.linspace(3.634, 3.939, 10):


        f = lat / 3.939

        delta = np.array([[f, 0, 0],
                          [0, f, 0],
                          [0, 0, f]])

        for i, atoms0 in enumerate(images):
            atoms = Atoms.copy(atoms0)
            cell0 = atoms.get_cell()
            atoms.set_cell(np.dot(cell0, delta), scale_atoms=True)

            keys = {'a': lat, 'config':i}

            data = {}
            for l in [6, 7]:
                key = 'NN{0}'.format(l)
                calc = Amp('networks/db5/40-{0}-{0}-1/'.format(l))
                atoms.set_calculator(calc)
                data[key] = atoms.get_potential_energy()

            atoms.set_calculator(None)

            db.write(atoms, key_value_pairs=keys, data=data)
#+END_SRC

#+RESULTS: 
: 1b8c51d7-cbed-4635-895e-b927acc9ead0

* EMT & other
** Unique structure calculator
*** 1 free-layer -- root(7) \times root(7)
This code uses ASAPs EMT calculator to calculate the energy of /all/ permutations given to it. It will then add the energy unique permutations to a trajectory file for later reference.

#+BEGIN_SRC python :results silent
from itertools import product
from ase.lattice.surface import fcc111_root
from asap3 import EMT
from ase import Atoms
from ase.db import connect
from amp.utilities import hash_image

base = fcc111_root('Cu', 7, size=(1, 1, 5), vacuum=6.0, a=3.634)
natoms = [a.index for a in base if a.tag <= 1]
metals = ['Cu', 'Pd']

with connect('traj/unique-1layer.db') as db:
    nrgs = set()
    for i, c in enumerate(product(metals, repeat=len(natoms))):
        atoms0 = Atoms.copy(base)
        for j, s in enumerate(natoms):
            atoms0[s].symbol = c[j]

        atoms = Atoms.copy(atoms0)
        atoms.set_calculator(EMT())
        nrg = round(atoms.get_potential_energy(), 3)
        atoms.set_calculator(None)

        if nrg not in nrgs:
            nrgs.add(nrg)
            db.write(atoms)
#+END_SRC

*** 5 free-layers -- 2 \times 2
#+BEGIN_SRC python :results silent
from itertools import product
from ase.lattice.surface import fcc111
from asap3 import EMT
from ase import Atoms
from ase.db import connect

base = fcc111('Cu', size=(2, 2, 5), vacuum=6.0, a=3.634)
natoms = [a.index for a in base]
metals = ['Cu', 'Pd']

with connect('traj/cfg2x2-5layer.db') as db:
    nrgs = set()
    for i, c in enumerate(product(metals, repeat=len(natoms))):
        atoms0 = Atoms.copy(base)
        for j, s in enumerate(natoms):
            atoms0[s].symbol = c[j]

        atoms = Atoms.copy(atoms0)
        atoms.set_calculator(EMT())
        nrg = round(atoms.get_potential_energy(), 3)
        atoms.set_calculator(None)

        if nrg not in nrgs:
            nrgs.add(nrg)
            db.write(atoms)
#+END_SRC

*** Bulk configurations

**** fcc
#+BEGIN_SRC python :results silent
from ase.lattice.cubic import FaceCenteredCubic
from itertools import product
from asap3 import EMT
from ase import Atoms
from ase.db import connect
import numpy as np

base = FaceCenteredCubic('Cu',
                         directions=[[0, 1, 1],
                                     [1, 0, 1],
                                     [1, 1, 0]],
                         size=(3, 3, 3),
                         latticeconstant=3.939)

natoms = [a.index for a in base]
metals = ['Cu', 'Pd']

with connect('traj/unique-bulk.db') as db:
    nrgs = set()
    for i, c in enumerate(product(metals, repeat=len(natoms))):

        atoms0 = Atoms.copy(base)
        for j, s in enumerate(natoms):
            atoms0[s].symbol = c[j]

        atoms = Atoms.copy(atoms0)
        atoms.set_calculator(EMT())
        nrg = round(atoms.get_potential_energy(), 3)

        atoms.set_calculator(None)

        if nrg not in nrgs:
            nrgs.add(nrg)
            db.write(atoms)
#+END_SRC

**** bcc
#+BEGIN_SRC python
from ase.lattice.cubic import BodyCenteredCubic
from ase.lattice.cubic import FaceCenteredCubic
from itertools import product
from asap3 import EMT
from ase import Atoms
from ase.db import connect
import numpy as np

fcc = FaceCenteredCubic('Cu',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant=3.634)
VOL = fcc.get_volume() / len(fcc)

base = BodyCenteredCubic('Cu',
                         directions=[[1, 1, 1],
                                     [-1, 1, 1],
                                     [-1, -1, 1]],
                        size=(3, 3, 3),
                        latticeconstant=1.0)

v0 = base.get_volume()
cell0 = base.get_cell()

f = (VOL*len(base) / v0)**(1. / 3.)
base.set_cell(f*cell0, scale_atoms=True)

natoms = [a.index for a in base]
metals = ['Cu', 'Pd']

with connect('traj/unique-bulk-bcc.db') as db:
    nrgs = set()
    for i, c in enumerate(product(metals, repeat=len(natoms))):

        atoms0 = Atoms.copy(base)
        for j, s in enumerate(natoms):
            atoms0[s].symbol = c[j]

        atoms = Atoms.copy(atoms0)
        atoms.set_calculator(EMT())
        nrg = round(atoms.get_potential_energy(), 3)

        atoms.set_calculator(None)

        if nrg not in nrgs:
            nrgs.add(nrg)
            db.write(atoms)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.visualize import view
from ase.io import read
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
from ase.db import connect

images = read('traj/unique-bulk-bcc.db')

# collect the volume/atom from fcc calculations
lat = np.linspace(3.634, 3.939, 5)
volumes = []
for a in lat:
    fcc = FaceCenteredCubic('Cu',
			    directions=[[0, 1, 1],
					[1, 0, 1],
					[1, 1, 0]],
			    latticeconstant=a)
    VOL = fcc.get_volume() / len(fcc)

    volumes += [VOL]

with connect('temp/all-lat-bulk-bcc.db') as db:
    for v in volumes:
	for atoms in images:
            v0 = atoms.get_volume() / len(atoms)
            cell0 = atoms.get_cell()

            f = (v / v0)**(1. / 3.)
            atoms.set_cell(f*cell0, scale_atoms=True)

            db.write(atoms)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect
from asap3 import EMT

db = connect('temp/all-lat-bulk-bcc.db')

vols = set()
for d in db.select():
    vols.add(d.volume / 27.)

vols = sorted(list(vols))

nrgs = set()
images = []

for d in db.select():
    if d.volume / 27. == vols[4]:

	atoms = db.get_atoms(d.id)
	atoms.set_calculator(EMT())
	nrg = round(atoms.get_potential_energy(), 3)
	atoms.set_calculator(None)

	if nrg not in nrgs:
	    nrgs.add(nrg)
            images += [atoms]

with connect('temp/lat5-bulk-bcc.db') as db:
    for v in vols:
	for i, atoms in enumerate(images):
            v0 = atoms.get_volume() / len(atoms)
            cell0 = atoms.get_cell()

            f = (v / v0)**(1. / 3.)
            atoms.set_cell(f*cell0, scale_atoms=True)

            db.write(atoms, key_value_pairs={'aV': float(v), 'cfg': int(i)})
#+END_SRC

#+RESULTS:

** Producing files for predictions
*** Opposite base composition
Each of the unique configurations produced above will also have an Cu based equivalent. We generate those here:

#+BEGIN_SRC python :results silent
from ase.db import connect
from ase.io import read
import numpy as np
from ase.visualize import view

images = read('traj/unique-4layer.db')

with connect('traj/unique-4layer.db') as db:
    for atoms in images:
        symbols = []
        for atom in atoms:
            if atom.symbol == 'Pd':
                symbols += ['Cu']
            else:
                symbols += ['Pd']
        atoms.set_chemical_symbols(symbols)

        db.write(atoms)
#+END_SRC

*** Lattice constant perturbations
#+BEGIN_SRC python :results silent
from ase.db import connect
from ase.io import read
import numpy as np
from amp.utilities import hash_image
from amp import Amp
import os

images = read('traj/unique-4layer.db')
factors = np.linspace(3.634, 3.939, 5)

rp = connect('temp/rep-4layer.db')

hashs = set()
with connect('temp/pred-4layer.db') as db:

    for d in db.select():
        hashs.add(d.hash)

    for x in factors:
        for atoms in images:
            cell = atoms.get_cell()
            f = x / np.linalg.norm(cell[0] / np.sqrt(7) / (0.5**0.5))

            delta = np.array([[f, 0, 0],
                              [0, f, 0],
                              [0, 0, f]])

            atoms.set_cell(np.dot(cell, delta),
                           scale_atoms=True)

            H = hash_image(atoms)
            if H not in hashs:
                hashs.add(H)

                calc = Amp('networks/db2/40-10-10-1/')
                atoms.set_calculator(calc)
                nrg10 = atoms.get_potential_energy()

                calc = Amp('networks/db2/40-12-12-1/')
                atoms.set_calculator(calc)
                nrg12 = atoms.get_potential_energy()
                atoms.set_calculator(None)

                db.write(atoms, hash=H,
                         data={'NN10': nrg10,
                               'NN12': nrg12})
            else:
                rp.write(atoms, hash=H)
#+END_SRC

* Analysis
** Database db0-bct
This database includes the DFT calculations mapping the pathway around the fcc to bcc transition. Other comparisons are also present. The pathway is compared to neural networks of multiple different frameworks.

*** BCT phase transition pathway
Figure ref:fig-db0-bct_fcc-to-bcc shows the energy barrier from fcc to bcc traveling through bct phase space.

#+caption: Neural network comparison to energy pathway of fcc to bcc transition through bct space. Shown for db0-bct networks.
#+label: fig-db0-bct_fcc-to-bcc
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/multinn-path1.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob

db = connect('data-pathway.db')

ca, nrg, img = [], [], []
for d in db.select('gga=PS'):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    ca.append(d.ca)
    nrg.append(d.total_energy / len(atoms))

plt.figure()
plt.plot(ca, nrg, 'k-', lw=4)
plt.annotate('bcc', xy=(ca[0], nrg[0]),
             xytext=(1.03, -5.248),
             arrowprops=dict(arrowstyle="->",
                             connectionstyle="arc3"),
             size=20,
            )
plt.annotate('fcc', xy=(ca[-1], nrg[-1]),
             xytext=(1.36, -5.225),
             arrowprops=dict(arrowstyle="->",
                             connectionstyle="arc3"),
             size=20,
            )

form = ['#FF0000', '#FF6600', '#FFFF33',
        '#006600', '#00FF00', '#00FFFF',
        '#0000FF', '#9933FF', '#FF0099']

for i, name in enumerate(glob('./networks/db0-bct/*trained-parameters.json')):
    n = name.split('/')[-1].split('-')[0]
    calc = BPNeural(json='{0}'.format(name))

    fit = []
    for atoms in img:
        atoms.set_calculator(calc)
        fit.append(atoms.get_potential_energy() / len(atoms))

    plt.plot(ca, fit, 'o-',
             label='{0}'.format(n),
             color=form[i])
plt.xlabel('c/a ratio')
plt.ylabel('Total energy (eV/atom)')
plt.xlim(ca[0], ca[-1])
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/multinn-path1.png')
#+END_SRC

*** All bulk structures
Figure ref:fig-db0-bct_all-bulk shows the residuals of various NN predictions for all bulk structures in db1. This includes the reaction pathway (section of low error on the end) along with various EOS generated from each of the ATAT predicted alloy structures.

#+caption: Energy differences between DFT and various NN predictions for all bulk structures in db1. Performed for networks generated from db0-bct data.
#+label: fig-db0-bct_all-bulk
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/multinn-differences.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob
import os

db = connect('networks/db1-cln/data.db')

nrg, img, ids = [], [], []
for d in db.select(['gga=PS', 'bulk=bct']):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    nrg.append(d.total_energy / len(atoms))
    ids.append(d.id)

form = ['#FF0000', '#FF6600', '#FFFF33',
        '#006600', '#00FF00', '#00FFFF',
        '#0000FF', '#9933FF', '#FF0099']

plt.figure()
plt.plot([ids[0], ids[-1]], [0, 0], 'k--', lw=2)

err = {}
for i, name in enumerate(glob('./networks/db0-bct/*trained-parameters.json')):
    n = name.split('/')[-1].split('-')[0]
    calc = BPNeural(json='{0}'.format(name))
    err[n] = []

    dif = []
    for j, atoms in enumerate(img):
        atoms.set_calculator(calc)
        e = atoms.get_potential_energy() / len(atoms)
        difference = e - nrg[j]
        if difference >= 0.1:
            err[n].append(ids[j])
        dif.append(difference)

    plt.plot(ids, dif, 'o',
             label='{0}'.format(n),
             color=form[i])
plt.xlabel('IDs')
plt.ylabel('Energy difference (eV/atom)')
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/multinn-bct.png')
#+END_SRC

** Database db1-train
*** BCT phase transition pathway
#+caption: Neural network comparison to energy pathway of fcc to bcc transition through bct space. Shown for db1-train networks.
#+label: fig-db1-train_fcc-to-bcc
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/rxn-path-db1.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob

db = connect('data-pathway.db')

ca, nrg, img = [], [], []
for d in db.select('gga=PS'):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    ca.append(d.ca)
    nrg.append(d.total_energy / len(atoms))

plt.figure()
plt.plot(ca, nrg, 'k-', lw=4)

form = ['#FF0000', '#FFFF33',
        '#006600', '#00FFFF',
        '#0000FF', '#FF0099']

for i, name in enumerate(glob('./networks/db1-50Cu/*/parameters-checkpoint.json')):

    n = name.split('/')[-2]
    calc = BPNeural(json='{0}'.format(name))

    fit = []
    for atoms in img:
        atoms.set_calculator(calc)
        fit.append(atoms.get_potential_energy() / len(atoms))

    plt.plot(ca, fit, 'o-',
             label='{0}'.format(n),
             color=form[i])

plt.xlabel('c/a ratio')
plt.ylabel('Total energy (eV/atom)')
plt.xlim(ca[0], ca[-1])
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/rxn-path-db1.png')
#+END_SRC

*** All bulk structures
#+caption: Energy differences between DFT and various NN predictions for all bulk structures in db1. Performed for networks generated from db1-train data.
#+label: fig-db1-train_all-bulk
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/all-db1.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob
import os

db = connect('networks/db1-cln/data.db')

nrg, img, ids = [], [], []
for d in db.select(['gga=PS']):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    nrg.append(d.total_energy / len(atoms))
    ids.append(d.id)

form = ['#FF0000', '#FFFF33',
        '#006600', '#00FFFF',
        '#0000FF', '#FF0099']

plt.figure()
plt.plot([ids[0], ids[-1]], [0, 0], 'k--', lw=2)

err = {}
for i, name in enumerate(glob('./networks/db1-50Cu/*/parameters-checkpoint.json')):
    n = name.split('/')[-2]
    calc = BPNeural(json='{0}'.format(name))
    err[n] = []

    dif = []
    for j, atoms in enumerate(img):
        atoms.set_calculator(calc)
        e = atoms.get_potential_energy() / len(atoms)
        difference = e - nrg[j]
        if difference >= 0.1:
            err[n].append(ids[j])
        dif.append(difference)

    plt.plot(ids, dif, 'o',
             label='{0}'.format(n),
             color=form[i])
plt.xlabel('IDs')
plt.ylabel('Energy difference (eV/atom)')
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/all-db1.png')
#+END_SRC

*** EOS reproduction
In this section, we reproduce EOS using various NN frameworks of the db1-train database. Figure ref:fig-db1-train_EOS-19 shows an example of an EOS which failed to be fit correctly by all frameworks.

#+caption: Example of reproduced EOS from ATAT structure 19 of the bcc configuration. This structure was not accurately fit to.
#+label: fig-db1-train_EOS-19
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/EOS-19-bcc.png]]

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from glob import glob

db = connect('networks/db1-50Cu/data.db')

cfgs = []
for d in db.select():
    if d.config not in cfgs:
        cfgs.append(d.config)

db = connect('networks/db1-cln/data.db')

bulk = ['fcc', 'bcc']

for cfg in cfgs:
    for b in bulk:
        nrg, img, ids = [], [], []
        try:
            for d in db.select(['config={0}'.format(cfg), 'bulk={0}'.format(b)]):
                atoms = db.get_atoms(d.id)
                img.append(atoms)
                nrg.append(d.total_energy / len(atoms))
                ids.append(d.volume / len(atoms))

            form = ['#FF0000', '#FFFF33',
                    '#006600', '#00FFFF',
                    '#0000FF', '#FF0099']

            f, ax = plt.subplots(2, sharex=True)
            ax[1].plot([ids[0], ids[-1]], [0, 0], 'k--', lw=2)
            ax[0].plot(ids, nrg, 'o', label='DFT', color='k', mfc='none', ms=6)

            err = {}
            for i, name in enumerate(glob('./networks/db1-50Cu/*/parameters-checkpoint.json')):
                n = name.split('/')[-2]
                calc = BPNeural(json='{0}'.format(name))
                err[n] = []

                dif, E = [], []
                for j, atoms in enumerate(img):
                    atoms.set_calculator(calc)
                    e = atoms.get_potential_energy() / len(atoms)
                    E.append(e)
                    difference = e - nrg[j]
                    if difference >= 0.1:
                        err[n].append(ids[j])
                    dif.append(difference)

                ax[0].plot(ids, E, '.',
                           label='{0}'.format(n),
                           color=form[i], alpha=0.5)
                ax[1].plot(ids, dif, '.',
                           label='{0}'.format(n),
                           color=form[i], alpha=0.5)
            ax[1].set_xlabel('Volume ($\AA$/atom)')
            ax[0].set_ylabel('Potential energy (eV/atom)')
            ax[1].set_ylabel('Energy difference (eV/atom)')
            ax[0].legend(loc='best', fontsize=8)
            plt.tight_layout()
            plt.savefig('./images/EOS-{0}-{1}.png'.format(cfg, b))
        except:
            pass
#+END_SRC

** Database db2-surf
*** Residuals
#+caption: Residual errors for the db2-surf training set.
#+label: fig-db2-surf_residual
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db2-surf.png]]

#+BEGIN_SRC python :results silent
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
from ase.db import connect
from neural.bp import BPNeural
import numpy as np
from glob import glob
from scipy.stats import norm
from matplotlib import gridspec

db = connect('networks/db2-surf/data.db')

img, nrg, ids = [], [], []
for d in db.select():
    img.append(db.get_atoms(d.id))
    nrg.append(d.total_energy / len(d.symbols))
    ids.append(d.id)

calc = BPNeural(json='networks/db2-surf/l3n30i0/parameters-checkpoint.json')

fit = []
for atoms in img:
    atoms.set_calculator(calc)
    fit.append(atoms.get_potential_energy() / len(atoms))
dif = np.array(fit) - np.array(nrg)

RMSE = np.sqrt(sum(dif ** 2) / len(dif))

(mu, sigma) = norm.fit(dif)

fig = plt.figure(figsize=(8, 6)) 
gs = gridspec.GridSpec(1, 2, width_ratios=[2, 1])
ax0 = plt.subplot(gs[0])
ax0.scatter(ids, dif, marker='o', color='k', alpha=0.5)
ax0.plot([0, len(dif)-1], [0, 0], 'r--', lw=2)
ax0.text(len(dif)*0.05, max(abs(dif)), 'RMSE: {0:1.3f}'.format(RMSE), fontsize=15, va='top', ha='left')
ax0.set_xlim(0, len(dif)-1)
ax0.set_ylim(-max(abs(dif))-0.1*max(abs(dif)), max(abs(dif))+0.1*max(abs(dif)))
ax0.set_xlabel('Calculation ID')
ax0.set_ylabel('Energy residual error (eV/atom)')

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(dif, 20,
                            range=(-max(abs(dif))-0.1*max(abs(dif)),
                                   max(abs(dif))+0.1*max(abs(dif))),
                            normed=True,
                            facecolor='k',
                            alpha=0.5,
                            orientation='horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(1, max(abs(dif)), '$\mu$: {0:1.3f}'.format(mu), fontsize=15, va='top', ha='left')
ax1.text(1, max(abs(dif))*0.9, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=15, va='top', ha='left')
ax1.plot(y, bins, 'k--', lw=2)
ax1.plot([0, 35], [0, 0], 'r--', lw=2)
ax1.set_xlabel('Probability density')
ax1.set_ylim(-max(abs(dif))-0.1*max(abs(dif)), max(abs(dif))+0.1*max(abs(dif)))
ax1.set_xlim(0, 35)
ax1.set_yticklabels(())

plt.subplots_adjust(left=0.11,
                    bottom=0.09,
                    right=0.97,
                    top=0.97,
                    wspace=0.02,
                    hspace=0.2)

plt.savefig('./images/db2-surf.png')
#+END_SRC

** Database db2
*** Lattice paramteres
In this section, we analyze the difference between energies predicted for various structures between two different neural network frameworks. Each figure demonstrates this effect for a different set of structures. Each set of structures is based on a root(7) \times root(7) fcc(111) surface lattice which is 5 layers deep. The only differences between these structures is the identity of the atoms filling the lattice positions, and also the lattice constant of the unit cell. Five evenly spaced lattice constants were chosen ranging from the lattice constant of bulk fcc Cu (3.634 \AA) to bulk Pd (3.939 \AA). This lattice grids are demonstrated in Figure ref:structure-types.

#+caption: Demonstration of the lattice structures utilized in the following section. The darker the atom, the deeper the layer. Only the 
#+label: structure-types
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 800
[[./images/structure-types.png]]    

#+BEGIN_SRC python :results silent
from ase.visualize import view
from ase.lattice.surface import fcc111_root
from ase.io import write
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
import matplotlib.image as mpimg
import os

lat = np.linspace(3.634, 3.939, 5)

p = np.linspace(0.05, 0.9, 5)

fig = plt.figure(figsize=(8, 3))
ax = fig.add_subplot(111)
for i, a in enumerate(lat):
    atoms = fcc111_root('Cu', root=7,
                        size=(1, 1, 5),
                        vacuum=6.0, a=a)

    col = abs((atoms.get_tags() / 5.0) - 1.0)

    kwargs = {
        'rotation': "-75x",
        'show_unit_cell': 2,
        'colors': np.array([col, col, col]).T,
        'radii': [0.3] * len(atoms)}

    write('images/temp.png', atoms, **kwargs)

    image = mpimg.imread('./images/temp.png')
    imagebox = OffsetImage(image, zoom=0.5)

    ax.add_artist(AnnotationBbox(imagebox,
                                 xy=(0, 0),
                                 xybox=(p[i], 0.5),
                                 pad=-0.2,
                                 frameon=False,
                                 arrowprops=None)
                 )
    ax.text(p[i], -0.13, '{0:1.3f} $\AA$'.format(a),
            va='center', ha='center')
    os.unlink('./images/temp.png')

fig.patch.set_visible(False)
ax.axis('off')
plt.tight_layout()
plt.savefig('images/structure-types.png')
#+END_SRC

*** Slab configurations
For a particular lattice (3.939 \AA), all combinations of Cu and Pd atoms were created for certain numbers of layers starting from the top. This was done for: 1, 2, and 3 layers. In Figure ref:composition-types, one possible configuration for a system where only the top most layer of atoms were allowed to be either Cu or Pd. Once all such configurations were enumerated on a Pd substrate (such a substrate is demonstrated on the right of Figure ref:composition-types), each structures energy was calculated using ASAP (https://wiki.fysik.dtu.dk/asap). Finally, only structures who ASAP energies are unique are kept.

#+caption: Demonstration of the lattice structures utilized in the following section. The darker the atom, the deeper the layer.
#+label: composition-types
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/composition-types.png]]

#+BEGIN_SRC python :results silent
from ase.visualize import view
from ase.lattice.surface import fcc111_root
from ase.io import write
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
import matplotlib.image as mpimg
import os

p = np.linspace(0.2, 0.8, 2)

fig = plt.figure(figsize=(4, 3))
ax = fig.add_subplot(111)
for i, M in enumerate(['Cu', 'Pd']):
    atoms = fcc111_root(M, root=7,
                        size=(1, 1, 5),
                        vacuum=6.0,
                        a=3.787)

    C = [200/255., 129/255., 51/255.] 
    B = [0/255., 105/255., 134/255.]

    if i == 0:
        col = [C] * 31 + [B] * 4
    else:
        col = [B] * 31 + [C] * 4

    kwargs = {
        'rotation': "-75x",
        'show_unit_cell': 2,
        'colors': col,
        'radii': None}

    write('images/temp.png', atoms, **kwargs)

    image = mpimg.imread('./images/temp.png')
    imagebox = OffsetImage(image, zoom=0.6)

    ax.add_artist(AnnotationBbox(imagebox,
                                 xy=(0, 0),
                                 xybox=(p[i], 0.5),
                                 pad=-0.2,
                                 frameon=False,
                                 arrowprops=None))
    os.unlink('./images/temp.png')

fig.patch.set_visible(False)
ax.axis('off')
plt.tight_layout()
plt.savefig('images/composition-types.png')
#+END_SRC

*** NN framework differences
For a single layer of configurations then, there are $2^{7}$ (128) possible configurations of atoms of the top most layer. Only 8 of these configurations are predicted to be energy unique by ASAP. Each of those configurations is energy unique for a Pd substrate, so we end up with twice as many unique configurations if we consider a Cu substrate as well. The result is 8 \times 2 (16) energy unique configurations on Cu and Pd substrate, and 16 \times 5 (80) total configurations with lattice constant ranging from 3.634 - 3.939 \AA.

From the two neural network trained, the difference between the energies predicted by the two systems can then be taken and used to determine the dependability of the fit for a wide range of different configurations.

#+caption: NN predicted energy differences for unique energy configurations of a root(7) \times root(7) slab. 1 layer is allowed to change its chemical composition.
#+label: fig-1layer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db0-1layer.png]]

#+caption: NN predicted energy differences for unique energy configurations of a root(7) \times root(7) slab. 2 layers are allowed to change their chemical composition.
#+label: fig-2layer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db0-2layer.png]]

#+caption: NN predicted energy differences for unique energy configurations of a root(7) \times root(7) slab. 3 layers are allowed to change their chemical composition.
#+label: fig-3layer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db0-3layer.png]]

#+caption: NN predicted energy differences for unique energy configurations of a root(7) \times root(7) slab. 4 layers are allowed to change their chemical composition.
#+label: fig-4layer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db0-4layer.png]]

To determine which structures AMP considers to be unique, we use the hashing method it utilizes to assign a simple hash to each atoms object. If we combine all of the unique hashes from the unique configurations shown above, Figure ref:fig-alayer-db0 is produced. We observe that the ASAP-EMT calculator eliminates a large number of unique configurations when the data set becomes quite large. Regardless, we observe that the results are well predicted in most cases.

#+caption: NN predicted energy differences for all unique energy configurations shown above which have a unique hash.
#+label: fig-alayer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db0-alayer.png]]

#+BEGIN_SRC python :results silent
from ase.db import connect
from amp import Amp
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/pred-config.db')

E = []
for d in db.select():
    E += [abs(d.data.NN10 / d.natoms - d.data.NN12 / d.natoms)]
E = np.array(E)

def nbins(x):
    from math import log10, floor, ceil
    p = -int(floor(log10(x)) - 2)
    w = ceil(x*10**p) / ceil(x*10**p)*10**-p
    m = ceil(x*10**p)
    return np.arange(0, m*w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.xlim(0, nbins(max(E)).max())
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/db0-alayer.png')
#+END_SRC

** Database db3
*** Residuals of db2 configurations
#+caption: Predicted energy differences between db3 frameworks for all unique energy configurations.
#+label: fig-alayer-db3
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db3-alayer.png]]

#+BEGIN_SRC python ;results silent
from ase.db import connect
from amp import Amp
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/db3-config.db')

E = []
for d in db.select():
    E += [abs(d.data['db3-6'] / d.natoms - d.data['db3-7'] / d.natoms)]
E = np.array(E)

def nbins(x):
    from math import log10, floor, ceil
    w = ceil(x*10**3) / ceil(x*10**3)*10**-3
    m = ceil(x*10**3)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.xlim(0, 0.111)
plt.ylim(0, 15000)
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/db3-alayer.png')
#+END_SRC

*** 5 free-layer -- 2 \times 2 slab
In Figure ref:fig-db3-2x2-5layer we demonstrate that every unique configuration predicted by ASAP-EMT is for a 2\times2 fcc(111) slab is well predicted by the db3 NNs as well. This demonstrates that we can accurately reproduce the energies of any simpler configuration of atoms. Interestingly, this also demonstrates the NNs ability to extrapolate to configurations which differ in the 5th layer as well, at least for small, relatively simple configurations.

#+caption: db3 NN predicted differences in energy for all 2 \times 2 unique energy configurations of a 5 layer fcc(111) slab.
#+label: fig-db3-2x2-5layer
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/cfg2x2-5layer-db3.png]]

#+BEGIN_SRC python ;results silent
from ase.db import connect
from amp import Amp
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/cfg2x2-5layer-db3.db')

E = []
for d in db.select():
    E += [abs(d.data['db3-6'] / d.natoms - d.data['db3-7'] / d.natoms)]
E = np.array(E)

def nbins(x):
    from math import log10, floor, ceil
    w = ceil(x*10**3) / ceil(x*10**3)*10**-3
    m = ceil(x*10**3)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/cfg2x2-5layer-db3.png')
#+END_SRC

** Database db4
This database includes all calculations from db3, plus additional calculations of bulk structures of a 3 \times 3 \times 3 primitive fcc unit cell. Only the bulk configurations predicted to be energy unique by EMT are included and only at lattice constants of 3.634 and 3.939 \AA.

*** Bulk configurations in db4
#+caption: Energy differences between db4 NN frameworks for energy unique bulk configurations at 10 lattice constants.
#+label: fig-db4_bulk_10lat
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db4_bulk.png]]

#+BEGIN_SRC python :results silent
from ase.io import read
from amp import Amp
import numpy as np
import matplotlib.pyplot as plt

images = read('networks/db4-bulk/data.db')

dE = []
for atoms in images:
    calc = Amp('networks/db4/40-8-8-1/')
    atoms.set_calculator(calc)
    E8 = atoms.get_potential_energy()

    calc = Amp('networks/db4/40-10-10-1/')
    atoms.set_calculator(calc)
    E10 = atoms.get_potential_energy()

    dE += [abs(E8 / len(atoms) - E10 / len(atoms))]
dE = np.array(dE)

def nbins(x):
    from math import log10, floor, ceil
    n = 4
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(dE, bins=nbins(max(dE)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(dE)))
plt.tight_layout()
plt.savefig('./images/db4_bulk.png')
#+END_SRC

*** Bulk configurations at 5 lattice constants
#+caption: Energy differences between db4 NN frameworks for energy unique bulk configurations at 10 lattice constants.
#+label: fig-db4_bulk_10lat
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db4_bulk_10lat.png]]

#+BEGIN_SRC python
from ase.db import connect
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/bulk-3x3.db')

E = []
for d in db.select():
    E += [abs(d.data['NN8'] / d.natoms - d.data['NN10'] / d.natoms)]
E = np.array(E)

def nbins(x):
    from math import log10, floor, ceil
    n = 2
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
print n
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/db4_bulk_10lat.png')
#+END_SRC

#+RESULTS:
: [ 4931.  1037.   556.   124.   124.   248.   628.   526.     6.]

** Database db5
Calculations for the next iteration of the bulk-only database.

*** Review of trained networks
#+BEGIN_SRC python
import os
from glob import glob
import shutil
import numpy as np

files = glob('networks/db5/40-*-*-1/train-log.txt')

for fil in files:
    fit = fil.split('/')[-2]

    with open(fil, 'r') as f:
        lines = f.readlines()

    print(fit, lines[-5])
#+END_SRC

#+RESULTS:
: ('40-7-7-1', '19839        2016-03-14T19:51:57  1.219e-02    7.086e-04\n')
: ('40-6-6-1', ' 9215        2016-03-13T18:36:16  1.321e-02    7.376e-04\n')

*** Fits to database data
[[./images/db5_bulk.png]]

#+BEGIN_SRC python :results silent
from ase.io import read
from amp import Amp
from ase.db import connect

db0 = connect('networks/db5-bulk/data.db')

with connect('temp/db5-bulk.db') as db:
    for d in db0.select():

        atoms = db0.get_atoms(d.id)

        calc = Amp('networks/db5/40-6-6-1/')
        atoms.set_calculator(calc)
        E6 = atoms.get_potential_energy()

        calc = Amp('networks/db5/40-7-7-1/')
        atoms.set_calculator(calc)
        E7 = atoms.get_potential_energy()

        atoms.set_calculator(None)
        db.write(atoms, key_value_pairs={'NN6': E6, 'NN7': E7})
#+END_SRC

#+BEGIN_SRC python :results silent
from ase.io import read
from amp import Amp
from ase.db import connect
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/db5-bulk.db')

dE = []
for d in db.select():
    dE += [(d.NN6 - d.NN7) / len(d.symbols)]
dE = np.array(dE)

def nbins(x):
    from math import log10, floor, ceil
    n = 4
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(dE, bins=nbins(max(dE)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(dE)))
plt.tight_layout()
plt.savefig('./images/db5_bulk.png')
#+END_SRC

*** for multi-lattice constants
#+caption: Energy differences between db5 NN frameworks for energy unique bulk configurations at 5 lattice constants.
#+label: fig-db5_bulk_5lat
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db5_bulk_5lat.png]]


#+BEGIN_SRC python
from ase.db import connect
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/db5-3x3-bulk.db')

E, lat = [], []
for d in db.select():
    E += [abs(d.data['NN6'] / d.natoms - d.data['NN7'] / d.natoms)]
    lat += [d.a]
E = np.array(E)
lat = np.array(lat)

ind = E > 0.007
print sum(ind)
print sorted(list(set(lat) ^ set(lat[ind])))

def nbins(x):
    from math import log10, floor, ceil
    n = 3
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/db5_bulk_5lat.png')
#+END_SRC

#+RESULTS:
: 2225
: [3.6339999999999999, 3.9051111111111112, 3.9390000000000001]

* Scratch Pad
** Making temp file for db4 NN predictions
Create a temporary database which will contain the NN calculations for all of the db4 data.

#+BEGIN_SRC python :results silent
from ase.db import connect
from amp import Amp

db = connect('temp/db4.db')

with connect('temp/db4b.db') as dbm:
    for d in db.select():
        atoms = db.get_atoms(d.id)

        calc = Amp('networks/db4-bulk/40-6-6-1/')
        atoms.set_calculator(calc)
        E8 = atoms.get_potential_energy()

        calc = Amp('networks/db4-bulk/40-8-8-1/')
        atoms.set_calculator(calc)
        E10 = atoms.get_potential_energy()

        data = d.data
        data.update({'NN6b': E8, 'NN8b': E10})
        
        dbm.write(d,
                  key_value_pairs=d.key_value_pairs,
                  data=data)
#+END_SRC

** Statistical analysis

#+caption: Statisitcal analysis of the db4 data. 3 Standard deviations of the data are shown for the residual errors of two frameworks and the difference between the predictions made by those frameworks. The actual outliers (~A), predicted outliers (~B), and outliers that are correctly predicted (~A & ~B) are shown in the lower left for \pm 3 \sigma.
#+label: fig-pred-corr
#+attr_latex: :width 5in :placement [H]
#+attr_org: :width 500
[[./images/prediction-correlation.png]]

#+BEGIN_SRC python :results silent
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
from matplotlib.path import Path
import matplotlib.patches as patches

db = connect('temp/db4.db')

Qe, n8, n10 = [], [], []
for d in db.select('train_set'):
    n8 += [d.data.NN8 / d.natoms]
    n10 += [d.data.NN10 / d.natoms]
    Qe += [d.energy / d.natoms]

Qe = np.array(Qe)
n8 = np.array(n8)
n10 = np.array(n10)

# Calculate the differences between 
dQ8 = n8 - Qe
dQ10 = n10 - Qe
dn = n10 - n8

x = np.linspace(-0.012, 0.012)

# I'm looking to solve the least squares regression of the
# function y = mx, we do this here by setting b = 0.
A = np.vstack([dn, np.zeros(len(dn))]).T
f8 = np.poly1d(np.linalg.lstsq(A, dQ8)[0])

A = np.vstack([dn, np.zeros(len(dn))]).T
f10 = np.poly1d(np.linalg.lstsq(A, dQ10)[0])

# Now we solve for the Pearson product-moment correlation coefficients
cov8 = np.corrcoef(dn, dQ8)[0][1]
cov10 = np.corrcoef(dn, dQ10)[0][1]

# Calculate the RMSE of the residuals
rmse = [np.sqrt((dQ8**2).mean()),
        np.sqrt((dQ10**2).mean())]

# Standard deviation of the framework difference
std = np.std(dn)

# here we sample a region around some tolerance to see the number of points which
# fall within it

# A certain number of standard devaitions
tol = 3
err = std * int(tol)

verts = [(-0.012, -err),
         (0.012, -err),
         (0.012, err),
         (-0.012, err),
         (0., 0.)]
codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]
path = Path(verts, codes)

Nc8 = path.contains_points(zip(dn, dQ8))
Ni8 = float(sum(Nc8)) / len(Nc8)

Nc10 = path.contains_points(zip(dn, dQ10))
Ni10 = float(sum(Nc10)) / len(Nc10)

# Now sample the same error range in the x-coordinate for overlap
verts2 = [(-err, -0.012),
          (err, -0.012),
          (err, 0.012),
          (-err, 0.012),
          (0., 0.)]
path2 = Path(verts2, codes)

xNc8 = path2.contains_points(zip(dn, dQ8))
xNi8 = float(sum(xNc8)) / len(xNc8)

xNc10 = path2.contains_points(zip(dn, dQ10))
xNi10 = float(sum(xNc10)) / len(xNc10)

fig, ax1 = plt.subplots()
plt.text(-0.0065, 0.0095, 'Correlation\ncoefficients',
         ha='right', fontsize=14)
plt.text(-0.0075, 0.0085, '{:1.3f}'.format(cov8),
         color='b', ha='right', fontsize=14)
plt.text(-0.0075, 0.0075, '{:1.3f}'.format(cov10),
         color='r', ha='right', fontsize=14)

plt.text(0, 0.0095, 'RMSE', ha='center', fontsize=14)
plt.text(0, 0.0085, '{0:1.2e}'.format(rmse[0]), color='b', ha='center', fontsize=14)
plt.text(0, 0.0075, '{0:1.2e}'.format(rmse[1]), color='r', ha='center', fontsize=14)

patch = patches.PathPatch(path, facecolor='m', edgecolor='m', alpha=0.3)
ax1.add_patch(patch)

patch2 = patches.PathPatch(path2, facecolor='c', edgecolor='c', alpha=0.3)
ax1.add_patch(patch2)

plt.plot([-0.012, 0.012], [-0.012, 0.012], 'k--', lw=2)
ax1.plot(dn, dQ8, 'bo', alpha=0.5)
ax1.plot(x, f8(x), 'b--', lw=2)

ax2 = ax1.twinx()
ax2.plot(dn, dQ10, 'ro', alpha=0.5)
ax2.plot(x, f10(x), 'r--', lw=2)

plt.text(-0.01, err - 0.0005, '$\pm$ {} $\sigma$'.format(int(tol)),
         va='top', ha='center', fontsize=14)
plt.text(-0.01, err - 0.0015, '{:1.1%}'.format(Ni8), color='r',
         va='top', ha='center', fontsize=14)
plt.text(-0.01, err - 0.0025, '{:1.1%}'.format(Ni10), color='b',
         va='top', ha='center', fontsize=14)

plt.text(err - 0.0015, -0.008, '$\pm$ {} $\sigma$'.format(int(tol)),
         va='top', ha='center', fontsize=14)
plt.text(err - 0.0015, -0.009, '{:1.1%}'.format(xNi8), color='r',
         va='top', ha='center', fontsize=14)
plt.text(err - 0.0015, -0.010, '{:1.1%}'.format(xNi10), color='b',
         va='top', ha='center', fontsize=14)

plt.text(0.0035, -0.0075, 'Outliers:', fontsize=14)
plt.text(0.0035, -0.0085, '~A', color='m', fontsize=14)
plt.text(0.0057, -0.0085, '~B', color='c', fontsize=14)
plt.text(0.0079, -0.0085, '~A & ~B', fontsize=14)
plt.text(0.0035, -0.0095, '{:<8} {:<8} {:<8}'.format(sum(~Nc8), sum(~xNc8), sum(~Nc8 * ~xNc8)),
         color='b', fontsize=14)
plt.text(0.0035, -0.0105, '{:<8} {:<8} {:<8}'.format(sum(~Nc10), sum(~xNc10), sum(~Nc10 * ~xNc10)),
         color='r', fontsize=14)

ax1.tick_params(axis='y', colors='b')
ax2.tick_params(axis='y', colors='r')

ax1.set_ylabel('40-8-8-1 residual error (eV/atom)', color='b', fontsize=14)
ax2.set_ylabel('40-10-10-1 residual error (eV/atom)', color='r', fontsize=14)

ax1.set_ylim(-0.012, 0.012)
ax2.set_ylim(-0.012, 0.012)

ax1.set_xlabel('Framework difference (eV/atom)')
plt.xlim(-0.012, 0.012)
plt.tight_layout()
plt.savefig('./images/prediction-correlation.png')
#+END_SRC

#+caption: Relation of correctly predicted outliers to standard deviations of calculations. This is a representation of the cost to benefit of restarting a set of calculations.
#+label: fig-cost-benif
#+attr_latex: :width 5in :placement [H]
#+attr_org: :width 500
[[./images/cost-benefit.png]]

#+BEGIN_SRC python :results silent
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
from matplotlib.path import Path
import matplotlib.patches as patches

db = connect('temp/db4.db')

Qe, n8, n10 = [], [], []
for d in db.select('train_set'):
    n8 += [d.data.NN8 / d.natoms]
    n10 += [d.data.NN10 / d.natoms]
    Qe += [d.energy / d.natoms]

Qe = np.array(Qe)
n8 = np.array(n8)
n10 = np.array(n10)

# Calculate the differences between 
dQ8 = n8 - Qe
dQ10 = n10 - Qe
dn = n10 - n8

codes = [Path.MOVETO,
         Path.LINETO,
         Path.LINETO,
         Path.LINETO,
         Path.CLOSEPOLY]

fig, ax1 = plt.subplots()

x = np.linspace(0, 4.0, 81)

for E, c, label in [[dQ8, 'b', '40-8-8-1'], [dQ10, 'r', '40-10-10-1']]:
    
    y = []
    cost = []
    for tol in x:
        err = np.std(dn) * tol

        vertx = [(-err, -0.012),
                 (err, -0.012),
                 (err, 0.012),
                 (-err, 0.012),
                 (0., 0.)]
        verty = [(-0.012, -err),
                 (0.012, -err),
                 (0.012, err),
                 (-0.012, err),
                 (0., 0.)]

        pathx = Path(vertx, codes)
        px = pathx.contains_points(zip(dn, E))

        pathy = Path(verty, codes)
        py = pathy.contains_points(zip(dn, E))

        pred = sum(~px)
        true = sum(~py)
        pos = sum(~px * ~py)
        ROS = pos / float(true)

        cost += [pred]
        y += [ROS]


    cost = np.array(cost) / float(cost[0])
    ax1.plot(cost, y, '{}-'.format(c), label=label)

ax2 = ax1.twiny()

ax2.plot(x, np.zeros(len(x)))
ax2.invert_xaxis()
ax2.set_xlabel('Standard deviations')

plt.legend(loc='best')

ax1.plot([0, 1], [0, 1], 'k--')
ax1.set_xlabel('Cost fraction')
ax1.set_ylabel('Fraction of positive outliers')
plt.tight_layout()
plt.savefig('./images/cost-benefit.png')
#+END_SRC

** monte carlo simulation


[[./images/MC-spin-20.png]]

[[./images/MC-spin.png]]

#+BEGIN_SRC python :results raw
func = """
import matplotlib.pyplot as plt
import numpy as np

def ising(N, T):
    J = 1  # Strength of interaction (Joules)
    k = 1  # J/K

    # Generate random initial configuration

    grid = (np.random.ranf(size=(N, N)) > 0.5) * 2 - 1

    # Evaluate the system for a fixed number of steps

    for i in range(1000):
        # Calculate the number of neighbors for each cell
        neighbors = np.roll(grid, 1, axis=1) + \
                    np.roll(grid, -1, axis=1) + \
                    np.roll(grid, 1, axis=0) + \
                    np.roll(grid, -1, axis=0)


        # Calculate energy change from spin flip
        dE = 2 * J * (grid * neighbors)

        # Calculate the transition probability
        P = np.exp(-dE/(k * T))

        # Transition which will occur
        transitions = np.random.random(size=(N, N)) < P


        # Screen all but 10% of transitions
        screen = (np.random.random(size=(N, N)) < 0.1)


        transitions = (transitions * screen) * -2 + 1

        # Perform the transitions
        grid = grid * transitions

        # Sum variables of interest
        M = grid.sum() / (N**2.)
        E = -dE.sum() / 2 / (N**2.)

    return M, E

n_grid = 20
Ms, Ts, Es = [], [], []

for i in range(1000):
    # Random temperature from 0 - 5
    T = np.random.random() * 5 + 1e-10

    M, E = ising(n_grid, T)

    Ms += [M]
    Es += [E]
    Ts += [T]

plt.figure()
plt.scatter(Ts, Ms)
plt.xlim(0, 5)
plt.ylim(-1, 1)
plt.title('20 x 20 grid')
plt.xlabel('inverse beta (J)')
plt.ylabel('Average spin')
plt.savefig('images/MC-spin-20.png')
"""

import timeit

time = timeit.timeit(func, number=1) / 60.
print('1 million calculations on 20 x 20 grid in {:1.1f} min'.format(time))
#+END_SRC

#+RESULTS:
1 million calculations on 20 x 20 grid in 1.6 min
1 million calculations on 50 x 50 grid in 3.9 min

#+BEGIN_SRC python
import matplotlib.pyplot as plt

plt.plot([0], [1], 'bo')
plt.xlabel('$\beta$')
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
from mpl_toolkits.mplot3d import Axes3D

k = 1  # Normalized by Boltzmann cosntant J / K

temps = np.linspace(0.6, 1, 100)
nrgs = np.linspace(-1, 1, 100)
T, E = np.meshgrid(temps, nrgs)
P = np.exp(-E/(k * T))

fig = plt.figure()
ax = fig.gca(projection='3d')

ax.plot_surface(T, E, P) 

ax.set_xlabel('Boltzmann normalized temperature (K)')
ax.set_ylabel('Energy (eV)')
ax.set_zlabel('Probability distribution')
plt.show()
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
from jasp import *
from amp import Amp
from glob import glob
JASPRC['restart_unconverged'] = False

files = glob('../archive/cluster-expansion-PBE/CuPd_fcc/*/')

delta = []
for wd in files:
    try:
	with jasp(wd) as calc:
            try:
		atoms = calc.get_atoms()
		nrg = atoms.get_potential_energy() / len(atoms)
            except(VaspQueued, VaspSubmitted):
                pass

        calc = Amp('networks/db5/40-7-7-1/')
        atoms.set_calculator(calc)
	delta += [atoms.get_potential_energy() / len(atoms) - nrg]
    except(VaspNotFinished, VaspNotConverged):
        pass

print delta
#+END_SRC

#+RESULTS:
: [-0.004442877373188825, -0.059599315805680675, 9.522945089646129e-05, -0.019087544011419766, -0.025345979116320194, 0.01447687663729269, -0.011149054164117267, -0.015150699341703877, -0.005505132646609567, -0.013227297925100245, -0.014929814353989102, -0.02504895227412618, 0.00016171948147114534, -0.011441674548032132, -0.005635441144927533, -0.01213655547501613, -0.011378423119922765, -0.019507470996535048, -0.03003397730923041]

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

SIZE = 5
STEPS = 1
T = 1

def bc(i):
    if i+1 > SIZE-1:
        return 0
    if i-1 < 0:
        return SIZE-1
    else:
        return i
    

def delta_energy(system, N, M):
    return -1 * system[N,M] * (system[bc(N-1), M] \
                               + system[bc(N+1), M] \
                               + system[N, bc(M-1)] \
                               + system[N, bc(M+1)])


def build_system():
    system = np.random.random_integers(0, 1, (SIZE, SIZE))
    system[system==0] =- 1

    return system


def main(T, N=500):
    B = 1. / (k * T)

    ## define the initial atoms object
    # atoms = [DEFINE ATOMS]
    # index = atoms.get_index()

    ## Calculate the initial energy and store it
    # Ei = atoms.get_potential_energy()

    ## Perform MC steps
    for i in range(N):

        ## Choose a random atom
        # n = random.choice(index)

        # new_atoms = Atoms.copy(atoms)

        ## Change atom chemical symbol
        # if new_atoms[n].symbol == 'Cu':
        #     new_atoms[n].symbol == 'Pd'
        # else:
        #     new_atoms[n].symbol == 'Cu'

        ## Calculate the energy of the new system
        # Ef = new_atoms.get_potential_energy()

        if Ef <= Ei:
            system[N, M] *= -1
        elif np.exp(-Ef * B) > np.random.rand():
            system[N, M] *= -1

system = build_system()

M = np.random.randint(0, SIZE)
N = np.random.randint(0, SIZE)
print M, N
print('\nsystem')
print system
print('\nrandom point')
print system[N, M]
print('\nneighbors')
print system[bc(N - 1), M]
print system[bc(N + 1), M]
print system[N, bc(M - 1)]
print system[N, bc(M + 1)]
print('\ndE')
print delta_energy(system, N, M)
#+END_SRC

#+RESULTS:
#+begin_example
0 2

system
[[ 1  1  1  1  1]
 [ 1 -1  1  1 -1]
 [ 1  1 -1  1  1]
 [ 1 -1  1 -1  1]
 [ 1 -1 -1 -1  1]]

random point
1

neighbors
1
1
1
1

dE
-4
#+end_example

** BCT via EMT

#+caption: EMT predicted equation of states for the fcc and bcc configurations.
#+label: fig-emt-eos
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/EMT-EOS.png]]

#+name: EMT-minimum-lattice-constants
#+BEGIN_SRC python
from ase.lattice.tetragonal import CenteredTetragonal as bct
import numpy as np
from asap3 import EMT
import matplotlib.pyplot as plt

A = np.linspace(2.4, 3.2, 1000)
CA = {'fcc':np.sqrt(2), 'bcc':1.0}

plt.figure()
nrg = {}
for name, ca in CA.iteritems():

    nrg[name] = []

    for a in A:
        atoms = bct('Cu', latticeconstant={'a': a, 'c/a': ca})
        atoms[1].symbol = 'Pd'

        atoms.set_calculator(EMT())
        nrg[name] += [atoms.get_potential_energy()]

Emin = [min(l) for l in nrg.values()]
dEmin = (max(Emin) - min(Emin))

Amin = [A[Es.index(min(Es))] for Es in nrg.values()]
print(Amin)


plt.plot(A, nrg['fcc'], 'g-')
plt.text(Amin[0], Emin[0], 'fcc', ha='center', va='top', color='g', size=20)
plt.plot(A, nrg['bcc'], 'b-')
plt.text(Amin[1], Emin[1], 'bcc', ha='center', va='top', color='b', size=20)
plt.xlim(2.55, 3.05)
plt.ylim(-0.08, -0.02)
plt.xlabel('bcc lattice constant, a ($\AA$)')
plt.ylabel('Potential energy (eV)')
plt.tight_layout()
plt.savefig('./images/EMT-EOS.png')
#+END_SRC

#+caption: 3D Minimum energy pathway of transition through bct geometry space as predicted by EMT.
#+label: fig-3d-cupd-min-emt
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/3D-EMT-pathway.png]]

#+caption: 2D Minimum energy pathway of transition through bct geometry space as predicted by EMT.
#+label: fig-2d-cupd-min-emt
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/2D-EMT-pathway.png]]

#+RESULTS: EMT-minimum-lattice-constants

#+BEGIN_SRC python :results silent :var eos=EMT-minimum-lattice-constants
from ase.lattice.tetragonal import CenteredTetragonal as bct
import numpy as np
from asap3 import EMT
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d
from matplotlib import cm

aref = [float(eos) for eos in eos[1:-2].split(',')]

# Create a list of sample points
ca0 = np.linspace(0.9, 1.5, 98)
ca0 = np.append(ca0, [1.0, np.sqrt(2)])
a0 = np.linspace(2.5, 3.1, 98)
a0 = np.append(a0, [aref[0], aref[1]])

a0 = np.unique(a0)
ca0 = np.unique(ca0)

X, Y = np.meshgrid(a0, ca0)

xifcc = list(X[0]).index(aref[0])
yifcc = list(Y.T[0]).index(np.sqrt(2))

xibcc = list(X[0]).index(aref[1])
yibcc = list(Y.T[0]).index(1.0)

Z = np.zeros(X.shape)

for i, a in enumerate(a0):

    for j, ca in enumerate(ca0):

        # Generate structure based on sample points
        atoms = bct('Cu', latticeconstant={'a': a, 'c/a': ca})
        atoms[1].symbol = 'Pd'

        atoms.set_calculator(EMT())
        Z[j][i] += [atoms.get_potential_energy()]

eminZ, cminZ, aminZ = [], [], []
for i, c in enumerate(ca0[yibcc:yifcc+1]):
    data = Z[i+yibcc, :]
    ind = list(data).index(min(data))

    eminZ.append(min(data))
    cminZ.append(c)
    aminZ.append(a0[ind])

delta = (max(eminZ) - min(eminZ))
rng = [min(eminZ), max(eminZ) + delta]

Z[Z > rng[1]] = np.nan

fig = plt.figure(figsize=(8, 6))
ax = fig.gca(projection='3d')
CM = cm.autumn
cset = ax.contourf(X, Y, Z, zdir='z', offset=rng[0] - delta, cmap=CM, vmin=rng[0], vmax=rng[1])

ax.plot_surface(X, Y, Z,
                rstride=1,
                cstride=1,
                cmap=CM,
                linewidth=0,
                vmin=rng[0],
                vmax=rng[1])

ax.scatter(aminZ[1:-1], cminZ[1:-1], eminZ[1:-1], c='k')

ax.plot([aref[0], aref[0]], [np.sqrt(2), np.sqrt(2)], [rng[0] - delta, eminZ[-1]], 'go-', zorder=99)
ax.text(aref[0], np.sqrt(2), eminZ[-1]+0.01, 'fcc', color='g', zorder=99, size='large')

ax.plot([aref[1], aref[1]], [1.0, 1.0], [rng[0] - delta, eminZ[0]], 'bo-', zorder=99)
ax.text(aref[1], 1.0, eminZ[0]+0.01, 'bcc', color='b', zorder=99, size='large')

ax.set_xlabel('a')
ax.set_xlim(2.4, 3.2)
ax.set_ylabel('c/a')
ax.set_ylim(0.8, 1.6)
ax.set_zlabel('Total energy (eV)')
ax.set_zlim(rng[0] - delta, rng[1])
plt.tight_layout()
plt.savefig('./images/3D-EMT-pathway.png')

plt.figure()
plt.plot(cminZ, eminZ, 'k-')
plt.xlim(min(cminZ), max(cminZ))

plt.annotate('bcc', xy=(cminZ[0], eminZ[0]),
             xytext=(cminZ[0] + .02, eminZ[0] - .005),
             size=20, ha='left', arrowprops=dict(arrowstyle='->'))

plt.annotate('fcc', xy=(cminZ[-1], eminZ[-1]),
             xytext=(cminZ[-1] - .02, eminZ[-1] + .005),
             size=20, ha='right', arrowprops=dict(arrowstyle='->'))

plt.xlabel('c/a ratio')
plt.ylabel('Total energy (eV)')

plt.savefig('./images/2D-EMT-pathway.png')
#+END_SRC

** MD simulations on various compositions

[[./images/calc-time.png]]

#+BEGIN_SRC python
from timeit import timeit
import matplotlib.pyplot as plt
import numpy as np

t = []
n = np.array(range(1, 8))
natoms = 27*n**3

for i in n:
    script = '''from amp import Amp
from ase.visualize import view
from ase.db import connect

db = connect('temp/bulk-3x3.db')
atoms = db.get_atoms(['a=3.634', 'config=1000'])

calc = Amp('networks/db5/40-7-7-1/')

atoms *= ({0}, {0}, {0})
atoms.set_calculator(calc)
atoms.get_potential_energy()
'''.format(i)
    t += [float(timeit(script, number=1)) / 60.]

fit = np.poly1d(np.polyfit(natoms, t, 2))
print(fit)

x = np.linspace(natoms[0], natoms[-1])

plt.figure()
plt.plot(natoms, t, 'bo')
plt.plot(x, fit(x), 'b-')
plt.xlabel('number of atoms')
plt.ylabel('Calculation time (min)')
plt.tight_layout()
plt.savefig('images/calc-time.png')
#+END_SRC

#+RESULTS:
:            2
: 1.858e-08 x + 0.0001521 x + 0.09639

Calculating the energies of various structures at their natural lattice constant.

#+BEGIN_SRC python
from ase.db import connect
from jbtools.utils import get_composition
from amp import Amp
from ase.lattice.cubic import FaceCenteredCubic as fcc
import numpy as np

db0 = connect('temp/bulk-3x3.db')

def aPd(x):
    return (3.939 - 3.634) * x + 3.634

with connect('temp/vegard-3x3.db') as db:
    for d in db0.select(['a=3.939']):

	atoms = db0.get_atoms(d.id)
	c = get_composition(atoms, 'Pd')

        f = aPd(c) / 3.939

        delta = np.array([[f, 0, 0],
                          [0, f, 0],
                          [0, 0, f]])

        cell = atoms.get_cell()
        atoms.set_cell(np.dot(cell, delta), scale_atoms=True)

        keys = {'a': aPd(c), 'config': int(d.config)}

	data = {}
	for l in [6, 7]:
	    key = 'NN{}'.format(l)
	    calc = Amp('networks/db5/40-{0}-{0}-1/'.format(l))
	    atoms.set_calculator(calc)
	    data[key] = atoms.get_potential_energy()

	atoms.set_calculator(None)

	db.write(atoms, key_value_pairs=keys, data=data)
#+END_SRC

#+RESULTS:

[[./images/vegard-error-bulk.png]]

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from ase.visualize import view

db = connect('temp/vegard-3x3.db')

data = {}
ID, LAT, ERR = [], [], []
for d in db.select():

    ERR += [(d.data.NN6 - d.data.NN7) / d.natoms]
    ID += [d.id]
    LAT += [d.a]

    if d.a not in data.keys():

        data[d.a] = np.array([d.id,
                      d.data.NN6,
                      d.data.NN7,
                      (d.data.NN6 - d.data.NN7) / d.natoms])
    else:
        data[d.a] = np.vstack([data[d.a], np.array([d.id,
                       d.data.NN6,
                       d.data.NN7,
                       (d.data.NN6 - d.data.NN7) / d.natoms])])




mins = []
fig = plt.figure(figsize=(6, 4))
ax = fig.add_subplot(111)
ax.plot([3.634, 3.939], [0, 0], 'k--', lw=2)

ax.set_title('click on a point')
ax.plot(LAT, ERR, 'bo', picker=5)

for lat, v in data.iteritems():
    error = v.T[-1]
    if isinstance(error, float):
        error = np.array([error])

    # find the minimum energy structure
    try:
        mc1 = int(list(v.T[1]).index(v.T[1].min()))
        mc2 = int(list(v.T[2]).index(v.T[2].min()))
        mins += [int(v.T[0][mc2])]
    except(TypeError):
        mc1, mc2 = 0, 0
        mins += [int(v.T[0])]

    # ax.plot(np.zeros(error.shape) + lat, error, 'bo')
    ax.plot(lat, error[mc1], 'ro')
    ax.plot(lat, error[mc2], 'go')

def onpick(event):
    ind = event.ind
    ax.set_title('Data point {0} is labeled "{1}"'.format(ind, ID[ind]))
    atoms = db.get_atoms(ID[ind])
    view(atoms)

    ax.figure.canvas.draw()  # this line is critical to change the linewidth
    plt.savefig('./images/vegard-error-bulk.png')

fig.canvas.mpl_connect('pick_event', onpick)

ax.set_xlim(3.634, 3.939)
ax.set_xlabel('fcc lattice constant ($\AA$)')
ax.set_ylabel('Difference in neural networks (eV/atom)')
plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
: 19

#+BEGIN_SRC python :results silent

MES = [1, 2, 23, 389, 432, 576, 815, 816, 918, 1173, 1174, 1175, 1179, 1303, 1390, 1497, 1544, 1573, 1584, 1604, 1605, 1616, 1621, 1631, 1633, 1634, 1635, 1636]

for n in MES:

    script = '''#!/usr/bin/env python
# from ase.db import connect
from amp import Amp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units

images = Trajectory("/home-research/jboes/research/cluster-expansion/script/out-{0}.traj", "r")
atoms = images[-1]

# db = connect("/home-research/jboes/research/cluster-expansion/temp/vegard-3x3.db")
# atoms = db.get_atoms({0})

atoms.set_calculator(Amp("/home-research/jboes/research/cluster-expansion/networks/db5/40-7-7-1/"))

T = 500
dyn = Langevin(atoms, 5 * units.fs, T * units.kB, 0.002)

def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy()
    ekin = a.get_kinetic_energy()

# Record the energies in the trajectory file
dyn.attach(printenergy, interval=1)

# We also want to save the positions of all atoms after every 100th time step.
traj = Trajectory("/home-research/jboes/research/cluster-expansion/script/out-{0}.traj", "a", atoms)
dyn.attach(traj.write, interval=1)

# Now run the dynamics
dyn.run(5000)
'''.format(n)

    with open('script/run-{}.py'.format(n), 'w') as f:
        f.write(script)
#+END_SRC

#+BEGIN_SRC python
MES = [1, 2, 23, 389, 432, 576, 815, 816, 918, 1173, 1174, 1175, 1179, 1303, 1390, 1497, 1544, 1573, 1584, 1604, 1605, 1616, 1621, 1631, 1633, 1634, 1635, 1636]

str_list = []
for n in MES:
    str_list += ['bpsh 30 -m ./run-{}.py &'.format(n)]

print ' '.join(str_list)
#+END_SRC

#+RESULTS:
: bpsh 30 -m ./run-1.py & bpsh 30 -m ./run-2.py & bpsh 30 -m ./run-23.py & bpsh 30 -m ./run-389.py & bpsh 30 -m ./run-432.py & bpsh 30 -m ./run-576.py & bpsh 30 -m ./run-815.py & bpsh 30 -m ./run-816.py & bpsh 30 -m ./run-918.py & bpsh 30 -m ./run-1173.py & bpsh 30 -m ./run-1174.py & bpsh 30 -m ./run-1175.py & bpsh 30 -m ./run-1179.py & bpsh 30 -m ./run-1303.py & bpsh 30 -m ./run-1390.py & bpsh 30 -m ./run-1497.py & bpsh 30 -m ./run-1544.py & bpsh 30 -m ./run-1573.py & bpsh 30 -m ./run-1584.py & bpsh 30 -m ./run-1604.py & bpsh 30 -m ./run-1605.py & bpsh 30 -m ./run-1616.py & bpsh 30 -m ./run-1621.py & bpsh 30 -m ./run-1631.py & bpsh 30 -m ./run-1633.py & bpsh 30 -m ./run-1634.py & bpsh 30 -m ./run-1635.py & bpsh 30 -m ./run-1636.py &

** Analysis of the MD simulations
#+BEGIN_SRC python :results raw
from ase.visualize import view
from glob import glob
from ase.io.trajectory import Trajectory
import matplotlib.pyplot as plt
import numpy as np

files = glob('script/out-*.traj')

for f in files:
    traj = Trajectory(f)
    name = f.split('/')[-1].split('.')[0]

    pE, kE, c = [], [], []
    for i, atoms in enumerate(traj):
        c += [i]
        pE += [atoms.get_potential_energy()]
        kE += [atoms.get_kinetic_energy()]

    pE = np.array(pE) - pE[0]
    kE = np.array(kE) - kE[0]

    ind = [kE < 5.0] or [pE < 5.0]

    pE = pE[ind]
    kE = kE[ind]
    c = np.array(c)[ind]
    
    plt.figure(figsize=(6, 4))
    plt.plot(c, pE, 'b-', label='potential')
    plt.plot(c, kE, 'r-', label='kinetic')
    plt.xlabel('Step')
    plt.ylabel('Energy (eV/atom)')
    plt.legend(loc='best')
    plt.tight_layout()
    plt.savefig('./images/{}.png'.format(name))

    if np.array(ind).all():
        print('{} still running'.format(name))
    else:
        print('{} failure step: {}'.format(name, np.array(ind).sum()))
    # print('[[./images/{}.png]]'.format(name))
#+END_SRC

#+RESULTS:
out-1 failure step: 1808
out-23 failure step: 1606
out-1173 failure step: 270
out-389 failure step: 857
out-432 still running
out-815 failure step: 1867
out-1634 still running
out-1175 failure step: 296
out-576 failure step: 1526
out-1544 failure step: 1776
out-1636 still running
out-1635 still running
out-1303 failure step: 615
out-1174 failure step: 271
out-1497 failure step: 119
out-1179 failure step: 410
out-1573 failure step: 606
out-1631 failure step: 2615
out-2 failure step: 1228
out-918 failure step: 719
out-816 failure step: 961
out-1621 still running
out-1605 failure step: 2025
out-1604 failure step: 2076
out-1633 still running
out-1584 failure step: 153
out-1390 failure step: 674
out-1616 failure step: 1211
out-1 failure step: [1 1 1 ..., 0 0 0]
out-23 failure step: [1 1 1 ..., 0 0 0]
out-1173 failure step: [1 1 1 ..., 0 0 0]
out-389 failure step: [1 1 1 ..., 0 0 0]
out-432 still running
out-815 failure step: [1 1 1 ..., 0 0 0]
out-1634 still running
out-1175 failure step: [1 1 1 ..., 0 0 0]
out-576 failure step: [1 1 1 ..., 0 0 0]
out-1544 failure step: [1 1 1 ..., 0 0 0]
out-1636 still running
out-1635 still running
out-1303 failure step: [1 1 1 ..., 0 0 0]
out-1174 failure step: [1 1 1 ..., 0 0 0]
out-1497 failure step: [1 1 1 ..., 0 0 0]
out-1179 failure step: [1 1 1 ..., 0 0 0]
out-1573 failure step: [1 1 1 ..., 0 0 0]
out-1631 still running
out-2 failure step: [1 1 1 ..., 0 0 0]
out-918 failure step: [1 1 1 ..., 0 0 0]
out-816 failure step: [1 1 1 ..., 0 0 0]
out-1621 still running
out-1605 failure step: [1 1 1 ..., 0 0 0]
out-1604 failure step: [1 1 1 ..., 0 0 0]
out-1633 still running
out-1584 failure step: [1 1 1 ..., 0 0 0]
out-1390 failure step: [1 1 1 ..., 0 0 0]
out-1616 failure step: [1 1 1 ..., 0 0 0]
out-1 failure step: [1 1 1 ..., 0 0 0]
out-23 failure step: [1 1 1 ..., 0 0 0]
out-1173 failure step: [1 1 1 ..., 0 0 0]
out-389 failure step: [1 1 1 ..., 0 0 0]
out-432 still running
out-815 failure step: [1 1 1 ..., 1 1 0]
out-1634 still running
out-1175 failure step: [1 1 1 ..., 0 0 0]
out-576 failure step: [1 1 1 ..., 0 0 0]
out-1544 failure step: [1 1 1 ..., 0 0 0]
out-1636 still running
out-1635 still running
out-1303 failure step: [1 1 1 ..., 0 0 0]
out-1174 failure step: [1 1 1 ..., 0 0 0]
out-1497 failure step: [1 1 1 ..., 0 0 0]
out-1179 failure step: [1 1 1 ..., 0 0 0]
out-1573 failure step: [1 1 1 ..., 0 0 0]
out-1631 still running
out-2 failure step: [1 1 1 ..., 0 0 0]
out-918 failure step: [1 1 1 ..., 0 0 0]
out-816 failure step: [1 1 1 ..., 0 0 0]
out-1621 still running
out-1605 failure step: [1 1 1 ..., 0 0 0]
out-1604 failure step: [1 1 1 ..., 0 0 0]
out-1633 still running
out-1584 failure step: [1 1 1 ..., 0 0 0]
out-1390 failure step: [1 1 1 ..., 0 0 0]
out-1616 failure step: [1 1 1 ..., 0 0 0]
out-1 failure step: 1
out-23 failure step: 1
out-1173 failure step: 1
out-389 failure step: 1
out-432 still running
out-815 failure step: 1
out-1634 still running
out-1175 failure step: 1
out-576 failure step: 1
out-1544 failure step: 1
out-1636 still running
out-1635 still running
out-1303 failure step: 1
out-1174 failure step: 1
out-1497 failure step: 1
out-1179 failure step: 1
out-1573 failure step: 1
out-1631 still running
out-2 failure step: 1
out-918 failure step: 1
out-816 failure step: 1
out-1621 still running
out-1605 failure step: 1
out-1604 failure step: 1
out-1633 still running
out-1584 failure step: 1
out-1390 failure step: 1
out-1616 failure step: 1

