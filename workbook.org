* ATAT
** Setting up calculations
*** Initializing the files
#+BEGIN_SRC python :results silent
import numpy as np
from subprocess import call

# This code is used to get a better starting point for lattice constant
lattice = np.array([3.631, 3.712, 3.792, 3.872, 3.953])
rad = 1 / (2*np.sqrt(2)) * lattice
scale = rad[2] / rad[-1]

call(["makelat", "-s={0}".format(scale), "Cu,Pd", "fcc,bcc"])

script = '''[INCAR]
ENCUT = 400
NSW = 50
IBRION = 2
ISIF = 7
KPPRA = 2500
EDIFF = 1e-6
GGA = PS
USEPOT = PAWPBE
'''

with open('vasp.wrap', 'w') as f:
    f.write(script)
#+END_SRC

** Binary alloy calculations
*** fcc
#+BEGIN_SRC python :results silent
from os import system, chdir
from os.path import exists
from time import sleep

N = 10

chdir('./CuPd_fcc')
system('maps -t=0.25 &')
for n in range(N):
    open('ready', 'w').close()
    while exists('ready'):
        sleep(0.1)
open('stop', 'w').close()
#+END_SRC

#+BEGIN_SRC python :results silent
from subprocess import call
from os import chdir

chdir('./CuPd_fcc')
call(["foreachfile", "wait", "run_atat_vasp.py"])
#+END_SRC

*** bcc
#+BEGIN_SRC python :results silent
from os import system, chdir
from os.path import exists
from time import sleep

N = 10

chdir('./CuPd_bcc')
system('maps -t=0.25 &')
for n in range(N):
    open('ready', 'w').close()
    while exists('ready'):
        sleep(0.1)
open('stop', 'w').close()
#+END_SRC

#+BEGIN_SRC python :results silent
from subprocess import call
from os import chdir

chdir('./CuPd_bcc')
call(["foreachfile", "wait", "run_atat_vasp.py"])
#+END_SRC

** Checking cluster expansion progress
*** CuPd fcc
#+BEGIN_SRC python
from subprocess import call

call(["atatstatus.py", "CuPd_fcc"])
#+END_SRC

#+RESULTS:
#+begin_example
Fit not up to date
    0:   energy = -4.0214
    1:   energy = -5.8350
    2:   energy = -10.0318
    3:   energy = -10.0449
    4:   energy = -13.9792
    5:   energy = -15.7919
    6:   energy = -14.1422
    7:   energy = -15.8687
    8:   energy = -14.0352
    9:   energy = -15.8523
   10:   energy = -17.9918
   11:   energy = -19.7291
   12:   energy = -21.6136
   13:   energy = -18.1387
   14:   energy = -20.0568
   15:   energy = -21.7531
   16:   energy = -18.1619
   17:   energy = -21.7823
   18:   energy = -18.2653
   19:   energy = -20.1122
   20:   energy = -21.7827
   21:   energy = -18.1469
   22:   energy = -19.9558
   23:   energy = -21.7161
   24:   energy = -18.0163
   25:   energy = -19.8097
   26:   energy = -21.6629
   27:   energy = -18.3046
   28:   energy = -21.8114
   37:   energy = -24.1672
   39:   energy = -25.8991
   40:   energy = -27.5631
   41:   energy = -22.2577
   42:   energy = -24.2132
   44:   energy = -27.5951
   46:   energy = -24.1920
   47:   energy = -23.8940
   49:   energy = -25.7091
   50:   energy = -27.5124
   53:   energy = -23.6418
   54:   energy = -25.8268
   56:   energy = -27.4268
   63:   energy = -31.7197
   70:   energy = -31.7452
   74:   energy = -28.3136
   77:   energy = -30.0401
   78:   energy = -31.7967
   84:   energy = -30.0419
   95:   energy = -31.7234
   98:   energy = -28.2037
  102:   energy = -31.8128
  104:   energy = -33.4273
  119:   energy = -31.7661
  140:   energy = -34.1757
  142:   energy = -35.9704
  174:   energy = -37.5647
  230:   energy = -34.0250
  234:   energy = -35.7792
  274:   energy = -39.8346
  276:   energy = -39.8679
  438:   energy = -38.3428
  446:   energy = -39.9947
  502:   energy = -38.3249
  505:   energy = -41.9561
  545:   energy = -38.2419
  548:   energy = -40.1003
  552:   energy = -39.9547
  955:   energy = -46.0056
 9808:   energy = -39.2919
 9992:   energy = -61.9444
#+end_example
    
*** CuPd bcc
#+BEGIN_SRC python
from subprocess import call

call(["atatstatus.py", "CuPd_bcc"])
#+END_SRC

#+RESULTS:
#+begin_example
Fit not up to date
    0:   energy = -3.9769
    1:   energy = -5.7884
    2:   energy = -9.8877
    3:   energy = -10.0998
    4:   energy = -7.7146
    5:   energy = -8.4585
    6:   energy = -14.1047
    7:   energy = -15.7319
    8:   energy = -13.9517
    9:   energy = -15.6574
   10:   energy = -17.7374
   11:   energy = -19.4663
   12:   energy = -21.3528
   13:   energy = -18.0715
   14:   energy = -19.6778
   15:   energy = -21.5013
   16:   energy = -18.0797
   17:   energy = -19.9108
   18:   energy = -21.5214
   19:   energy = -18.1146
   20:   energy = -21.5709
   21:   energy = -17.9217
   22:   energy = -19.7344
   23:   energy = -21.4618
   24:   energy = -17.9091
   25:   energy = -21.5236
   26:   energy = -18.1295
   27:   energy = -19.7810
   28:   energy = -21.4997
   29:   energy = -13.0591
   31:   energy = -16.3437
   34:   energy = -12.7813
   35:   energy = -22.0440
   36:   energy = -24.2140
   37:   energy = -23.5896
   38:   energy = -25.8306
   39:   energy = -25.4102
   40:   energy = -27.3142
   41:   energy = -22.0452
   45:   energy = -21.8694
   46:   energy = -23.8320
   47:   energy = -23.6712
   48:   energy = -25.5460
   49:   energy = -25.4622
   50:   energy = -27.2273
   51:   energy = -22.0702
   53:   energy = -23.8848
   54:   energy = -25.7058
   55:   energy = -25.5577
   56:   energy = -27.2860
   60:   energy = -29.8335
   81:   energy = -26.0306
   90:   energy = -28.2950
   93:   energy = -29.6533
   95:   energy = -31.5346
  105:   energy = -25.6394
  112:   energy = -32.9307
  116:   energy = -29.2618
  130:   energy = -28.0172
  134:   energy = -31.3237
  441:   energy = -39.7619
  479:   energy = -38.4438
  494:   energy = -38.4328
  581:   energy = -38.4466
  603:   energy = -38.4733
  618:   energy = -38.4510
 1098:   energy = -40.2134
 1273:   energy = -41.9288
 1721:   energy = -48.5707
 2237:   energy = -48.5666
#+end_example
   
* DFT
** CuPd fcc and bcc '3' configuration
#+BEGIN_SRC python :results silent
from jasp import *
from ase.io import read
JASPRC['queue.walltime'] = '24:00:00'

# Run for fcc and bcc
for lbl in ['fcc', 'bcc']:

    # Get the CuPd structure for fcc and bcc from ATAT
    # Configuration '3'
    atoms = read('CuPd_{0}/3/CONTCAR'.format(lbl))

    # Will run these calculations on PBEsol and PBE
    for gga in ['PS', 'None']:

        with jasp('DFT/bulk={0}/config=3/xc=PBE/gga={1}'.format(lbl, gga),
                  xc='PBE',
                  gga='{0}'.format(gga),
                  encut=400,
                  kpts=(12, 12, 12),
                  nsw=10,
                  ibrion=2,
                  isif=7,
                  ediff=1e-8,
                  atoms=atoms) as calc:
            try:
                calc.calculate()
            except(VaspQueued, VaspSubmitted):
                pass
#+END_SRC

** fcc to fcc transition through bct geometry
*** data generation
#+BEGIN_SRC python
from ase.lattice.tetragonal import CenteredTetragonal as bct
import numpy as np
from ase.visualize import view
from jbutil import makedb
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

# Configuration '3' for fcc
with jasp('DFT/bulk=fcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

# This is the 'a' parameter from the calculation
afcc = np.linalg.norm(cell[0])

# Configuration '3' for bcc i.e. B2
with jasp('DFT/bulk=bcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

# This is the 'a' parameter from the calculation
abcc = np.linalg.norm(cell[0])


print '     fcc', '           bcc'
print 'a:   {0:1.3f}  {1:1.3f}'.format(afcc, abcc)
print 'c/a: {0:1.3f}  {1:1.3f}'.format(np.sqrt(2), 1.0)

# Create a list of sample points
ca0 = np.linspace(0.9, 1.5, 31)
ca0 = np.append(ca0, [np.sqrt(2)])
a0 = np.linspace(2.5, 3.1, 31)
a0 = np.append(a0, [afcc, abcc])

for a in a0:

    for ca in ca0:

        # Generate structure based on sample points
        atoms = bct('Cu', latticeconstant={'a': a, 'c/a': ca})
        atoms[1].symbol = 'Pd'

        wd = 'DFT/bulk=bct/config=3/a={0}/ca={1}/xc=PBE/gga=PS'.format(a, ca)

        with jasp(wd,
                  xc='PBE',
                  gga='PS',
                  encut=400,
                  kpts=(12, 12, 12),
                  ibrion=-1,
                  ediff=1e-8,
                  atoms=atoms) as calc:
            try:
                calc.calculate()
            except(VaspQueued, VaspSubmitted):
                print wd, 'Queued'
#+END_SRC

#+RESULTS:
#+begin_example
     fcc           bcc
a:   2.64179025643 2.96063403586
c/a: 1.41421356237 1.0
[ 0.9    0.92   0.94   0.96   0.98   1.     1.02   1.04   1.06   1.08   1.1
  1.12   1.14   1.16   1.18   1.2    1.22   1.24   1.26   1.28   1.3    1.32
  1.34   1.36   1.38   1.4    1.42   1.44   1.46   1.48   1.5    1.414]
[ 2.5    2.52   2.54   2.56   2.58   2.6    2.62   2.64   2.66   2.68   2.7
  2.72   2.74   2.76   2.78   2.8    2.82   2.84   2.86   2.88   2.9    2.92
  2.94   2.96   2.98   3.     3.02   3.04   3.06   3.08   3.1    2.642
  2.961]
#+end_example

*** data visualization
#+caption: 3D Minimum energy pathway of fcc to bcc transition through bct geometry space
#+label: fig-3d-cupd-min
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/3D-bcc-pathway.png]]

#+BEGIN_SRC python
from ase.lattice.tetragonal import CenteredTetragonal as bct
from ase.db import connect
from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt
from matplotlib import cm
from jasp import *
from jbutil import makedb
JASPRC['queue.walltime'] = '24:00:00'

# Retrive the data
db = connect('data.db')
A, C = [], []
E = {}
for d in db.select([]):

    if d.a not in E.keys():
        E[d.a] = {}
    if d.ca not in E[d.a].keys():
        E[d.a][d.ca] = d.total_energy

    A.append(d.a)
    C.append(d.ca)

with jasp('DFT/bulk=fcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

    efcc = atoms.get_potential_energy()
    afcc = np.linalg.norm(cell[0])

with jasp('DFT/bulk=bcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

    ebcc = atoms.get_potential_energy()
    abcc = np.linalg.norm(cell[0])

uA = np.unique(A)
uC = np.unique(C)
X, Y = np.meshgrid(uA, uC)
Z = np.zeros(X.shape)

for i, a in enumerate(uA):
    for j, c in enumerate(uC):
        Z[j][i] = E[a][c]

fccZ, bccZ = [], []
eminZ = []
cminZ = []
aminZ = []

for i, c in enumerate(uC[5:-5]):
    data = Z[i+5, :]
    ind = data.tolist().index(min(data))

    eminZ.append(min(data))
    cminZ.append(c)
    aminZ.append(uA[ind])


rng = [ebcc, -10.2]

Z[Z > rng[1]] = np.nan

fig = plt.figure(figsize=(8, 6))
ax = fig.gca(projection='3d')
CM = cm.autumn

cset = ax.contourf(X, Y, Z, zdir='z', offset=-10.8, cmap=CM, vmin=rng[0], vmax=rng[1])

ax.plot_surface(X, Y, Z,
                rstride=1,
                cstride=1,
                cmap=CM,
                linewidth=0,
                vmin=rng[0],
                vmax=rng[1])


ax.scatter(aminZ[1:-1], cminZ[1:-1], eminZ[1:-1], c='k')

ax.plot([afcc, afcc], [np.sqrt(2), np.sqrt(2)], [-10.8, eminZ[-1]], 'go-', zorder=99)
ax.text(afcc, np.sqrt(2), eminZ[-1]+0.01, 'fcc', color='g', zorder=99, size='large')

ax.plot([abcc, abcc], [1.0, 1.0], [-10.8, eminZ[0]], 'bo-', zorder=99)
ax.text(abcc, 1.0, eminZ[0]+0.01, 'bcc', color='b', zorder=99, size='large')

ax.set_xlabel('a')
ax.set_xlim(2.4, 3.2)
ax.set_ylabel('c/a')
ax.set_ylim(0.8, 1.6)
ax.set_zlabel('Total energy (eV)')
ax.set_zlim(-10.8, rng[1])
plt.tight_layout()
plt.savefig('images/3D-bcc-pathway.png')

for gga in ['PS', 'None']:

    for i, ca in enumerate(cminZ):

        atoms = bct('Cu', latticeconstant={'a': aminZ[i], 'c/a': ca})
        atoms[1].symbol = 'Pd'

        wd = 'DFT/bulk=bct/config=3/pathway=True/ca={0}/xc=PBE/gga={1}'.format(ca, gga)

        with jasp(wd,
                  xc='PBE',
                  gga='{0}'.format(gga),
                  encut=400,
                  kpts=(12, 12, 12),
                  nsw=20,
                  ibrion=2,
                  isif=7,
                  ediff=1e-9,
                  atoms=atoms) as calc:
            try:
                calc.calculate()

            except(VaspQueued, VaspSubmitted):
                print wd, 'Queued'
#+END_SRC

#+caption: 2D Minimum energy pathway of fcc to bcc transition through bct geometry space
#+label: fig-2d-cupd-min
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/diffusion-path.png]]

#+BEGIN_SRC python :results silent
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np

# Retrive the data
db = connect('data-pathway.db')

C, E = [], []
for d in db.select(['gga=PS']):
    C.append(d.ca)
    E.append(d.total_energy)


E = np.array(E) - E[0]

plt.figure()
plt.plot(C, E, 'ko-', ms=4)

plt.scatter(C[0], E[0], s=30, c='b', zorder=99)
plt.text(C[0]-0.003, E[0]+0.001, 'bcc', color='b', ha='left', size='large')

plt.scatter(C[-1], E[-1], s=30, c='g', zorder=99)
plt.text(C[-1]+0.003, E[-1]+0.001, 'fcc', color='g', ha='right', size='large')

plt.xlabel('c/a')
plt.ylabel('Energy relative to bcc phase (eV)')
plt.xlim(0.995, np.sqrt(2)+0.005)
plt.ylim(-0.001, E[-1]+0.003)
plt.tight_layout()
plt.savefig('images/diffusion-path.png')
#+END_SRC

* ATAT analysis
** ground state figure
#+caption: Ground state hull of CuPd for fcc and bcc phases
#+label: fig-cupd-gs
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/groundstate.png]]

#+BEGIN_SRC python : results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

config = ['fcc', 'bcc']
color = ['b', 'r']

plt.figure()
plt.plot([0.0, 1.0], [0, 0], 'k--')

for i, cfg in enumerate(config):

    with open('CuPd_{0}/gs.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        GS, EGS, CGS = [], [], []

        for line in lines:
            # Composition, DFT energy, Fit energy, Configuration
            x, y, z, c = line.split()

            CGS.append(x)
            EGS.append(y)
            GS.append(c)

    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        C, E = [], []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            x, y, z, e, w, c = line.split()

            C.append(x)
            E.append(y)

    plt.scatter(C, E, c='k', s=15)
    plt.plot(CGS, EGS, c='{0}'.format(color[i]), marker='o', label='{0}'.format(cfg))
    for j, gs in enumerate(GS[1:-1]):
        plt.text(CGS[1:-1][j], float(EGS[1:-1][j])-0.004,
                 '{0}'.format(gs),
                 color='{0}'.format(color[i]),
                 va='top', ha='center',
                 zorder=99)

plt.legend(loc='best')
plt.xlim(0, 1)
plt.xlabel('Composition (Pd)')
plt.ylabel('Heat of formation (eV/atom)')
plt.ylim(-0.15, 0.01)
plt.tight_layout()
plt.savefig('./images/groundstate.png')
#+END_SRC

** EOS for all structures
#+BEGIN_SRC python
import numpy as np
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

# For fcc and bcc configurations
for i, cfg in enumerate(['fcc', 'bcc']):

    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        # Begin a list of configurations
        C = []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            x, y, z, e, w, c = line.split()

            # We only need the configuration
            C.append(c)

    # Fraction of equilibrium lattice constant to be calculated.
    frac_eos = np.append(np.linspace(0.85, 1.15, 61), np.linspace(1.2, 2.0, 17))

    # This array represents all types of deformations we want to calculate.
    # The nominclature being used is as follows:
    # [ x , a , c ]
    # [ a , y , b ]
    # [ c , b , z ]
    # where a, b, and c are the xy, yz, and zx tensors, respectively.
    deformations = [['xyz', frac_eos]]

    for j, c in enumerate(C):

        for dfm in deformations:

            for frac in dfm[1]:

                # This code retrieves the optimized volume and atom positions from the ISIF=3 calculation.
                with jasp('CuPd_{0}/{1}'.format(cfg, c)) as calc:
                    atoms = calc.get_atoms()
                    cell0 = atoms.get_cell()
                    k1, k2, k3 = calc.input_params['kpts']

                dis = {}
                for vector in ['x', 'y', 'z', 'a', 'b', 'c']:
                    dis[vector] = 1.0

                    if vector in dfm[0]:
                        dis[vector] = frac

                delta = np.array([[dis['x']      , 0.5 * (dis['a'] - 1), 0.5 * (dis['c'] - 1)],
                                  [0.5 * (dis['a'] - 1), dis['y']      , 0.5 * (dis['b'] - 1)],
                                  [0.5 * (dis['c'] - 1), 0.5 * (dis['b'] - 1), dis['z']      ]])

                # This line adjusts the cell volume by the fraction specified above. 
                # The atoms are scaled accordingly inside the new unit cell.
                atoms.set_cell(np.dot(cell0, delta), scale_atoms=True)
                wd = 'DFT/bulk={0}/config={1}/strain={2}/factor={3}/xc=PBE/gga=PS'.format(cfg, c, dfm[0], frac)

                try:
                    with jasp(wd,
                              xc='PBE',
                              gga='PS',
                              kpts=(k1, k2, k3),
                              encut=400,
                              ibrion=-1,
                              ediff=1e-8,
                              atoms=atoms) as calc:
                        try:
                            atoms = calc.get_atoms()
                            nrg = atoms.get_potential_energy()
                            print 
                        except(VaspSubmitted, VaspQueued):
                            print wd, 'Queued'
                except(IOError):
                    print wd, 'IOError'
                except(VaspNotFinished):
                    print wd, 'VaspNotFinished'
#+END_SRC

#+BEGIN_SRC python
import numpy as np
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

# For fcc and bcc configurations
for cfg in ['fcc', 'bcc']:

    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        # Begin a list of configurations
        C = []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            x, y, z, e, w, c = line.split()

            # We only need the configuration
            C.append(c)

    # Fraction of equilibrium lattice constant to be calculated.
    frac_eos = np.append(np.linspace(0.85, 1.15, 61), np.linspace(1.2, 2.0, 17))

    for j, c in enumerate(C):

        for frac in frac_eos:

            wd = 'DFT/bulk={0}/config={1}/strain=xyz/factor={2}/xc=PBE/gga=PS'.format(cfg, c, frac)

            try:
                with jasp(wd) as calc:
                    try:
                        atoms = calc.get_atoms()
                        nrg = atoms.get_potential_energy()
                    except(VaspSubmitted, VaspQueued):
                        print wd, 'Queued'
            except(IOError):
                print wd, 'IOError'
            except(VaspNotFinished):
                print wd, 'VaspNotFinished'
#+END_SRC

#+RESULTS:
#+begin_example
DFT/bulk=fcc/config=3/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
6339: |      Your highest band is occupied at some k-points! Unless you are         |

Converged: False

DFT/bulk=fcc/config=9/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=15/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=17/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=17/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=17/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=20/strain=xyz/factor=1.8/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=20/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=20/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=23/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=23/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=26/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=28/strain=xyz/factor=1.85/xc=PBE/gga=PS VaspNotFinished
Errors found:
Converged: False

DFT/bulk=fcc/config=39/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=40/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=40/strain=xyz/factor=1.95/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=40/strain=xyz/factor=2.0/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=44/strain=xyz/factor=1.8/xc=PBE/gga=PS VaspNotFinished
Errors found:
Converged: False

DFT/bulk=fcc/config=44/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=44/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=44/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=44/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=49/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=49/strain=xyz/factor=2.0/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=53/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=53/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=54/strain=xyz/factor=1.8/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=54/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=54/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=56/strain=xyz/factor=1.85/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=56/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=56/strain=xyz/factor=1.95/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=56/strain=xyz/factor=2.0/xc=PBE/gga=PS VaspNotFinished
Errors found:
Converged: False

DFT/bulk=fcc/config=104/strain=xyz/factor=1.7/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=104/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=104/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=119/strain=xyz/factor=1.8/xc=PBE/gga=PS Queued
Errors found:
9739: |      Your highest band is occupied at some k-points! Unless you are         |

Converged: False

DFT/bulk=fcc/config=119/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=63/strain=xyz/factor=1.8/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=63/strain=xyz/factor=1.85/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=63/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=63/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=63/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=70/strain=xyz/factor=1.8/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=70/strain=xyz/factor=1.85/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=70/strain=xyz/factor=1.9/xc=PBE/gga=PS VaspNotFinished
Errors found:
Converged: False

DFT/bulk=fcc/config=70/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=70/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=77/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=77/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=78/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=95/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=95/strain=xyz/factor=1.95/xc=PBE/gga=PS VaspNotFinished
Errors found:
Converged: False

DFT/bulk=fcc/config=95/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=98/strain=xyz/factor=0.915/xc=PBE/gga=PS IOError
Errors found:
Converged: False

DFT/bulk=fcc/config=174/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=174/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=174/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=174/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=234/strain=xyz/factor=1.8/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=234/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=234/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=276/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
DFT/bulk=fcc/config=505/strain=xyz/factor=1.85/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=505/strain=xyz/factor=1.9/xc=PBE/gga=PS VaspNotFinished
DFT/bulk=fcc/config=505/strain=xyz/factor=2.0/xc=PBE/gga=PS VaspNotFinished
Errors found:
Converged: False

DFT/bulk=fcc/config=545/strain=xyz/factor=1.035/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=545/strain=xyz/factor=1.04/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=545/strain=xyz/factor=1.055/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=545/strain=xyz/factor=1.065/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=545/strain=xyz/factor=1.09/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=545/strain=xyz/factor=1.1/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=545/strain=xyz/factor=1.2/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=fcc/config=552/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=7/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=15/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=15/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=15/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=18/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=18/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=20/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=23/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=23/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=25/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=28/strain=xyz/factor=1.75/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=28/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=29/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=29/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=29/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=31/strain=xyz/factor=1.75/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=31/strain=xyz/factor=1.8/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=31/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=31/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=31/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=31/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=34/strain=xyz/factor=1.8/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=34/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=34/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=34/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=34/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=36/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=36/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=38/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=39/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=48/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=48/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=49/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=50/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=54/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=56/strain=xyz/factor=1.65/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=56/strain=xyz/factor=1.75/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=56/strain=xyz/factor=1.8/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=56/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=56/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=105/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=112/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
Errors found:
7978: |      Your highest band is occupied at some k-points! Unless you are         |

Converged: False

DFT/bulk=bcc/config=112/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=112/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
7978: |      Your highest band is occupied at some k-points! Unless you are         |

Converged: False

DFT/bulk=bcc/config=112/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=134/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=134/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=60/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=93/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=95/strain=xyz/factor=1.8/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=95/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=441/strain=xyz/factor=1.7/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=441/strain=xyz/factor=1.85/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=441/strain=xyz/factor=1.9/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=441/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
DFT/bulk=bcc/config=603/strain=xyz/factor=1.95/xc=PBE/gga=PS VaspNotFinished
Errors found:
Converged: False

DFT/bulk=bcc/config=618/strain=xyz/factor=1.95/xc=PBE/gga=PS Queued
Errors found:
Converged: False

DFT/bulk=bcc/config=618/strain=xyz/factor=2.0/xc=PBE/gga=PS Queued
#+end_example

#+BEGIN_SRC python
import numpy as np
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

# For fcc and bcc configurations
for cfg in ['fcc', 'bcc']:

    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

    # Begin a list of configurations
    C = []

    for line in lines:
        # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
        x, y, z, e, w, c = line.split()

        # We only need the configuration
        C.append(int(c))
    C = np.array(C)

    # Fraction of equilibrium lattice constant to be calculated.
    frac_eos = np.append(np.linspace(0.85, 1.15, 61), np.linspace(1.2, 2.0, 17))

    for j, c in enumerate(C):

        for frac in frac_eos:

            wd = 'DFT/bulk={0}/config={1}/strain=xyz/factor={2}/xc=PBE/gga=PS'.format(cfg, c, frac)

            try:
                with jasp(wd) as calc:
                    atoms = calc.get_atoms()
                    nrg = atoms.get_potential_energy()
            except:
                print '~/research/cluster-expansion/' + wd
#+END_SRC

#+RESULTS:
#+begin_example
Errors found:
Converged: False

~/research/cluster-expansion/DFT/bulk=fcc/config=3/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=9/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=15/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=17/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=17/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=17/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=20/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=20/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=20/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=23/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=23/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=26/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=28/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=39/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=40/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=40/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=40/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=44/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=44/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=44/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=44/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=44/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=49/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=49/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=53/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=53/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=54/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=54/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=54/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=56/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=56/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=56/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=56/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=104/strain=xyz/factor=1.7/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=104/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=104/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=119/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=119/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=63/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=63/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=63/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=63/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=63/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=70/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=70/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=70/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=70/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=70/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=77/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=77/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=78/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=95/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=95/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=95/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=98/strain=xyz/factor=0.915/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=174/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=174/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=174/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=174/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=234/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=234/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=234/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=276/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=505/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=505/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=505/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=545/strain=xyz/factor=1.035/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=545/strain=xyz/factor=1.04/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=545/strain=xyz/factor=1.055/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=545/strain=xyz/factor=1.065/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=545/strain=xyz/factor=1.09/xc=PBE/gga=PS
Errors found:
Converged: False

~/research/cluster-expansion/DFT/bulk=fcc/config=545/strain=xyz/factor=1.1/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=545/strain=xyz/factor=1.2/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=fcc/config=552/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=7/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=15/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=15/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=15/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=18/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=18/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=20/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=23/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=23/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=25/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=28/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=29/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=29/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=29/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=31/strain=xyz/factor=1.75/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=31/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=31/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=31/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=31/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=31/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=34/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=34/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=34/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=34/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=34/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=36/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=36/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=38/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=39/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=48/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=48/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=49/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=50/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=54/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=56/strain=xyz/factor=1.65/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=56/strain=xyz/factor=1.75/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=56/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=56/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=56/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=105/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=112/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=112/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=112/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=112/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=134/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=134/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=60/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=93/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=95/strain=xyz/factor=1.8/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=95/strain=xyz/factor=2.0/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=441/strain=xyz/factor=1.7/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=441/strain=xyz/factor=1.85/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=441/strain=xyz/factor=1.9/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=441/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=603/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=618/strain=xyz/factor=1.95/xc=PBE/gga=PS
~/research/cluster-expansion/DFT/bulk=bcc/config=618/strain=xyz/factor=2.0/xc=PBE/gga=PS
#+end_example

* Database tools
** database generation
#+BEGIN_SRC python :results silent
import jbtools.gilgamesh as jb

jb.write_database('DFT/surf=fcc')
#+END_SRC

#+BEGIN_SRC python :results silent
from ase.db import connect
import os
import random
import numpy as np

db = connect('networks/db2/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#db0 = connect('train.db')

#for d in db.select(['train_set=True']):
#    db0.write(d, key_value_pairs=d.key_value_pairs)
#+END_SRC

#+BEGIN_SRC python :results silent
from amp import Amp
from amp.descriptor import *
from amp.regression import *

for n in [10]:
    label = '40-{0}-{0}-1'.format(n)

    calc = Amp(label="./networks/db2/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))

    calc.train("./train.db",
               cores=8,
               #global_search=None,
               extend_variables=False) # feature does not work properly and will crash
#+END_SRC

#+BEGIN_SRC python
import os
import shutil
import subprocess
import time

home = os.getcwd()

# We will try an iteration for 2 and 3 nodes with 2 hidden layers.
for n in [12, 15, 18, 20]:

    label = '40-{0}-{0}-1'.format(n)
    wd = os.path.join(home, 'networks/db2/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(label="./",
           descriptor=Behler(cutoff=6.0),
           regression=NeuralNetwork(hiddenlayers=(2, {0})))

calc.train("../../../train.db",
           cores=12,
           extend_variables=False)
'''.format(n)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    shutil.copyfile('../../../run.sh', 'submit.sh')
    os.chdir(wd)
#+END_SRC

#+RESULTS:

** Data visualization 
This is a tool which allows one to visualize the data set via the number of atoms and volume of atoms in the structure.

#+BEGIN_SRC python :results silent
from jbdb import visualize

visualize('networks/db2-surf/data.db')
#+END_SRC

** database manipulation
#+BEGIN_SRC python
from ase.db import connect
import os

fcc = [2, 3, 446, 25, 11, 19, 22, 14, 77, 84, 552, 548, 276, 274]
bcc = [2, 3, 14, 60, 93, 11, 441, 116, 22, 27, 17]

db0 = connect('networks/db1-cln/data.db')

wd = 'networks/db1-50Cu'

if not os.path.exists(wd):
    os.makedirs(wd)

db = connect(wd + '/data.db')

for cfg in fcc:
    for d in db0.select(['bulk=fcc', 'gga=PS', 'config={0}'.format(cfg)]):
        db.write(d,
                 key_value_pairs=d.key_value_pairs)

for cfg in bcc:
    for d in db0.select(['bulk=bcc', 'gga=PS', 'config={0}'.format(cfg)]):
        db.write(d,
                 key_value_pairs=d.key_value_pairs)
#+END_SRC

#+RESULTS:

* Neural tools
** GS energy prediction
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from jbutil import get_composition
from ase.io import write

BPcalc = BPNeural(json='networks/db0-PS/trained-parameters.json')

config = ['fcc', 'bcc']
color = ['b', 'r']

f, ax = plt.subplots(1, 2, figsize=(10, 5))

for i, cfg in enumerate(config):

    # Open ground states file and collect a list of all GS configs
    with open('CuPd_{0}/gs.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        GS = []

        for line in lines:
            # Composition, DFT energy, Fit energy, Configuration
            comp, dftE, fitE, s = line.split()

            GS.append(s)

    # Open fit file and collect a list of all configs
    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        S = []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            comp, dftE, fitE, err, w, s = line.split()

            S.append(s)

    dft, fit, var = [], [], []
    
    for s in S:
        with jasp('CuPd_{0}/{1}'.format(cfg, s)) as calc:
            atoms = calc.get_atoms()
            n = len(atoms)
            
            var.append(get_composition(atoms, 'Cu'))
            dft.append(atoms.get_potential_energy() / n)

            atoms.set_calculator(BPcalc)
            fit.append(atoms.get_potential_energy() / n)

    var = np.array(var)
    dft = np.array(dft)
    fit = np.array(fit)
    res = fit - dft

    ax[0].scatter(dft, fit, c=color[i], edgecolor='none', marker='.', s=40, zorder=9, label='{0}'.format(cfg))

    ax[1].scatter(var, res, c=color[i], edgecolor='none', marker='.', s=40, zorder=9)

    anom = []

    for j, s in enumerate(S):

        if s in GS:
            plt.text(var[j], float(res[j])-0.006,
                 '{0}'.format(s),
                 color=color[i], weight='bold',
                 va='top', ha='center',
                 zorder=99)

        if abs(res[j]) > 0.9:
            anom.append(s)
            plt.text(var[j], float(res[j])-0.006,
                 '{0}'.format(s),
                 color=color[i],
                 va='top', ha='center',
                 zorder=99)

    for a in anom:
        with jasp('CuPd_{0}/{1}'.format(cfg, a)) as calc:
            atoms = calc.get_atoms()
        write('./images/{0}-{1}-A.png'.format(cfg, a), atoms, rotation='45x, 45y')

    for a in GS:
        with jasp('CuPd_{0}/{1}'.format(cfg, a)) as calc:
            atoms = calc.get_atoms()
        write('./images/{0}-{1}-GS.png'.format(cfg, a), atoms, rotation='45x, 45y')

ax[1].plot([0.0, 1.0], [0, 0], 'k-')
ax[1].set_xlim(0.0, 1.0)
ax[1].set_xlabel('Composition (Cu)')
ax[1].set_ylabel('Residuals to fit, Neural - DFT (eV/atom)')

#ax[0].plot([-0.6, -0.25], [-0.6, -0.25], 'k-', zorder=1)
ax[0].set_xlabel('DFT total energy (eV/atom)')
#ax[0].set_xlim(-0.6, -0.25)

ax[0].set_ylabel('Neural fitted total energy (eV/atom)')
#ax[0].set_ylim(-0.6, -0.25)
ax[1].set_xticks(ax[1].get_xticks()[1:])
ax[0].legend(loc='best')
plt.tight_layout()

plt.savefig('images/db0-PS-eosfit.png')
plt.show()
#+END_SRC

#+RESULTS:
#+begin_example
['0', '27', '19', '505', '28', '1']
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '11', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '37', '39', '40', '41', '42', '44', '46', '47', '49', '53', '54', '56', '102', '104', '119', '63', '70', '74', '77', '78', '84', '95', '98', '140', '142', '174', '230', '234', '274', '276', '438', '446', '502', '505', '545', '548', '552']
[ 1.     0.     0.5    0.5    0.667  0.333  0.667  0.333  0.667  0.333  0.5
  0.75   0.5    0.25   0.75   0.25   0.75   0.5    0.25   0.75   0.5    0.25
  0.75   0.5    0.25   0.75   0.25   0.6    0.4    0.2    0.8    0.6    0.2
  0.6    0.6    0.4    0.6    0.4    0.2    0.333  0.167  0.333  0.333
  0.333  0.667  0.5    0.333  0.5    0.333  0.667  0.571  0.429  0.286
  0.571  0.429  0.5    0.5    0.625  0.5    0.625  0.375  0.625  0.5    0.5  ]
[-0.287 -0.126 -0.186 -0.198 -0.421 -1.681 -0.237 -0.194 -0.34  -0.429
 -1.871 -0.28  -0.212 -0.213 -0.27  -0.186 -0.258 -0.196 -0.197 -0.297
 -0.316 -0.335 -0.63  -1.146 -0.792 -0.243 -0.159 -0.228 -0.218 -0.398
 -0.282 -0.227 -0.249 -0.243 -0.558 -0.599 -1.925 -0.407 -1.038 -0.184
 -0.288 -0.354 -0.339 -0.338 -0.261 -0.305 -0.258 -0.273 -0.28  -0.246
 -0.226 -0.205 -0.554 -0.329 -0.352 -0.365 -0.373 -0.249 -0.28  -0.231
 -0.181 -0.238 -0.242 -0.264]
['0', '26', '603', '3', '1']
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '34', '35', '36', '37', '38', '39', '41', '45', '46', '47', '48', '49', '50', '51', '53', '54', '55', '56', '105', '112', '116', '130', '134', '60', '81', '90', '93', '95', '441', '479', '494', '603', '618', '1098']
[ 1.     0.     0.5    0.5    0.667  0.333  0.667  0.333  0.667  0.333
  0.75   0.5    0.25   0.75   0.5    0.25   0.75   0.5    0.25   0.75   0.25
  0.75   0.5    0.25   0.75   0.25   0.75   0.5    0.25   0.8    0.6    0.2
  0.8    0.6    0.6    0.4    0.4    0.8    0.8    0.6    0.6    0.4    0.4
  0.2    0.8    0.6    0.4    0.4    0.2    0.833  0.167  0.5    0.667
  0.333  0.5    0.833  0.667  0.5    0.333  0.5    0.625  0.625  0.625
  0.625  0.778]
[-0.301 -0.114 -0.199 -0.194 -2.457 -2.973 -0.249 -0.245 -0.235 -0.165
 -0.707 -1.851 -0.972 -0.308 -0.438 -0.439 -0.263 -0.188 -0.168 -0.256
 -0.139 -0.304 -0.26  -0.244 -0.288 -0.145 -0.246 -0.141 -0.121 -3.525
 -3.474 -4.745 -0.287 -0.258 -0.756 -0.308 -0.727 -0.31  -0.348 -0.229
 -0.396 -0.218 -0.449 -0.459 -0.295 -0.203 -0.193 -0.165 -0.18  -1.566
 -0.954 -1.784 -0.226 -0.158 -0.178 -0.308 -0.225 -0.274 -0.22  -0.19
 -0.208 -0.197 -0.213 -0.219 -0.251]
#+end_example

** Network training
#+BEGIN_SRC python
from jbnn import train

train('networks/db2-surf')
#+END_SRC

#+RESULTS:
#+begin_example
1268606.gilgamesh.cheme.cmu.edu
1268607.gilgamesh.cheme.cmu.edu
1268608.gilgamesh.cheme.cmu.edu
1268609.gilgamesh.cheme.cmu.edu
1268610.gilgamesh.cheme.cmu.edu
1268611.gilgamesh.cheme.cmu.edu
1268612.gilgamesh.cheme.cmu.edu
1268613.gilgamesh.cheme.cmu.edu
1268614.gilgamesh.cheme.cmu.edu
1268615.gilgamesh.cheme.cmu.edu
1268616.gilgamesh.cheme.cmu.edu
1268617.gilgamesh.cheme.cmu.edu
1268618.gilgamesh.cheme.cmu.edu
1268619.gilgamesh.cheme.cmu.edu
1268620.gilgamesh.cheme.cmu.edu
1268621.gilgamesh.cheme.cmu.edu
#+end_example

** Neural Network progress check
Code to check the progress of a neural network currently being run out of a selected directory

#+BEGIN_SRC python
from jbnn import NN_progress

NN_progress(directory='db2-surf')
#+END_SRC

#+RESULTS:
#+begin_example
Job ID       Queue    Itr.     Energy
l2n20i0      N        5455     2.604e-03
l2n25i1      N        3576     5.001e-03
l2n30i0      N        6121     2.475e-03
l2n30i1      N        5206     2.646e-03
l2n35i0      N        5087     5.375e-03
l2n35i1      N        4996     3.674e-03
l2n40i0      N        4805     3.487e-03
l2n40i1      N        4582     2.625e-03
l3n25i0      N        4271     1.609e-03
l3n25i1      N        4198     1.732e-03
l3n30i0      N        4669     1.398e-03
l3n30i1      N        4523     1.681e-03
l3n35i0      N        4792     1.843e-03
l3n35i1      N        4248     1.471e-03
l3n40i0      N        4393     1.575e-03
l3n40i1      N        4336     1.679e-03
#+end_example

* db0-bct trails
** phase transition pathway
[[./images/multinn-path1.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob
import os

db = connect('data-pathway.db')

ca, nrg, img = [], [], []
for d in db.select('gga=PS'):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    ca.append(d.ca)
    nrg.append(d.total_energy / len(atoms))

plt.figure()
plt.plot(ca, nrg, 'k-', lw=4)
plt.annotate('bcc', xy=(ca[0], nrg[0]),
             xytext=(1.03, -5.248),
             arrowprops=dict(arrowstyle="->",
                             connectionstyle="arc3"),
             size=20,
            )
plt.annotate('fcc', xy=(ca[-1], nrg[-1]),
             xytext=(1.36, -5.225),
             arrowprops=dict(arrowstyle="->",
                             connectionstyle="arc3"),
             size=20,
            )

form = ['#FF0000', '#FF6600', '#FFFF33',
        '#006600', '#00FF00', '#00FFFF',
        '#0000FF', '#9933FF', '#FF0099']

for i, name in enumerate(glob('./networks/db0-bct/*trained-parameters.json')):
    n = name.split('/')[-1].split('-')[0]
    calc = BPNeural(json='{0}'.format(name))

    fit = []
    for atoms in img:
        atoms.set_calculator(calc)
        fit.append(atoms.get_potential_energy() / len(atoms))

    plt.plot(ca, fit, 'o-',
             label='{0}'.format(n),
             color=form[i])
plt.xlabel('c/a ratio')
plt.ylabel('Total energy (eV/atom)')
plt.xlim(ca[0], ca[-1])
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/multinn-path1.png')
#+END_SRC

** All bulk structures

[[./images/multinn-differences.png]]

[[./images/multinn-bct.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob
import os

db = connect('networks/db1-cln/data.db')

nrg, img, ids = [], [], []
for d in db.select(['gga=PS', 'bulk=bct']):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    nrg.append(d.total_energy / len(atoms))
    ids.append(d.id)

form = ['#FF0000', '#FF6600', '#FFFF33',
        '#006600', '#00FF00', '#00FFFF',
        '#0000FF', '#9933FF', '#FF0099']

plt.figure()
plt.plot([ids[0], ids[-1]], [0, 0], 'k--', lw=2)

err = {}
for i, name in enumerate(glob('./networks/db0-bct/*trained-parameters.json')):
    n = name.split('/')[-1].split('-')[0]
    calc = BPNeural(json='{0}'.format(name))
    err[n] = []

    dif = []
    for j, atoms in enumerate(img):
        atoms.set_calculator(calc)
        e = atoms.get_potential_energy() / len(atoms)
        difference = e - nrg[j]
        if difference >= 0.1:
            err[n].append(ids[j])
        dif.append(difference)

    plt.plot(ids, dif, 'o',
             label='{0}'.format(n),
             color=form[i])
plt.xlabel('IDs')
plt.ylabel('Energy difference (eV/atom)')
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/multinn-bct.png')
#+END_SRC

** surface predictions

[[./images/multinn-surface.png]]

#+BEGIN_SRC python :results silent
import numpy as np
from ase.lattice.surface import fcc111_root
from ase.visualize import view
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from glob import glob
import matplotlib.patches as mpatches
import matplotlib.lines as mlines
import os

lattice = np.array([3.631, 3.712, 3.792, 3.872, 3.953])
site = [[None], [6], [6, 7], [6, 7, 8]]

colr = ['#FF0000', '#FF6600', '#FFFF33',
        '#006600', '#00FF00', '#00FFFF',
        '#0000FF', '#9933FF', '#FF0099']

shape = ['o', '^', 's', 'p']

patches = [] 

for i, name in enumerate(glob('./networks/db0-bct/*trained-parameters.json')):
    n = name.split('/')[-1].split('-')[0]
    calc = BPNeural(json='{0}'.format(name))
    patches.append(mpatches.Patch(color=colr[i], label='{0}'.format(n)))
    for a in lattice:
        

        nrg = []
        for h, s in enumerate(site):
            atoms = fcc111_root('Cu', root=3, size=(1, 1, 3), vacuum=6.0, a=a)
            for si in s:
                atoms[si].symbol = 'Pd'

            atoms.set_calculator(calc)
            nrg = atoms.get_potential_energy() / len(atoms)

            plt.scatter(a, nrg,
                        color=colr[i],
                        marker=shape[h])

for i, s in enumerate(shape):
    patches.append(mlines.Line2D([], [], color='k', marker=s, lw=0,
                          markersize=10, label='{0}Pd'.format(i)))

plt.xlabel('Lattice constant ($\AA$)')
plt.ylabel('Total energy (eV/atom)')
plt.legend(loc='best', handles=patches)
plt.tight_layout()
#plt.savefig('./images/multinn-surface.png')
plt.show()
#+END_SRC

* db1-train trails
Section containing code used to recreate 

#+BEGIN_SRC python
from jbdb import get_keys

get_keys('./networks/db1-50Cu/data.db')
#+END_SRC

#+RESULTS:
#+begin_example
keyword          value           2985 calculations total
---------------------------------------------------------
xc             : PBE
ca             : 1.5, 1.0, 0.94, 1.26, 1.46, 1.14, 1.02, 1.42, 1.41421356, 1.4, etc...
encut          : 400.0
strain         : xyz
ibz_kpts       : 128, 64, 98, 35, 196, 105, 42, 75, 205, 80, etc...
nbands         : 25, 50, 37, 14
ediff          : 1e-08
nsw            : 10
total_energy   : -20.223436, -9.6299781, -39.928924, -2.0309181, -28.139411, -9.7537688, -40.143355, -5.6516627, -3.0178203, -3.6205497, etc...
factor         : 0.875, 1.0, 2.0, 0.99, 1.075, 0.94, 1.125, 1.35, 0.88, 0.98, etc...
converged      : True
config         : 116, 2, 3, 548, 276, 552, 11, 77, 14, 17, etc...
pathway        : False
kpt1           : 5, 6, 7, 8, 9, 11, 12, 13
kpt3           : 5, 6, 7, 8, 9, 11, 12, 13
kpt2           : 5, 6, 7, 8, 9, 11, 12, 13
bulk           : bct, fcc, bcc
ibrion         : 2, -1
gga            : PS
path           : /home-rese, /home-rese, /home-rese, /home-rese, /home-rese, /home-rese, /home-rese, /home-rese, /home-rese, /home-rese, etc...
a              : 2.5, 3.0, 2.76, 2.52, 2.78, 2.54, 2.96063403, 2.8, 2.86, 2.56, etc...
volume         : 18.4375, 17.1875, 62.6934205, 53.2972310, 129.226014, 44.4870761, 219.281467, 15.0, 20.6317065, 20.570824, etc...
traj           : 0, 1, 2, 3, 4
isif           : 7
fermi          : 5.5, 10.125, 11.5371, 13.1686, 11.889, 9.2329, 8.9466, 7.691, 8.4918, 4.0231, etc...
kppra          : 1728
calc_time      : 53.75, 84.875, 63.465, 3279.25, 53.806, 3390.69, 563.678, 65.745, 402.083, 322.791, etc...
#+end_example

** phase transition pathway
#+org_attr: :width 400
[[./images/rxn-path-db1.png]]

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob
import os

db = connect('data-pathway.db')

ca, nrg, img = [], [], []
for d in db.select('gga=PS'):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    ca.append(d.ca)
    nrg.append(d.total_energy / len(atoms))

plt.figure()
plt.plot(ca, nrg, 'k-', lw=4)

form = ['#FF0000', '#FFFF33',
        '#006600', '#00FFFF',
        '#0000FF', '#FF0099']

for i, name in enumerate(glob('./networks/db1-50Cu/*/parameters-checkpoint.json')):

    n = name.split('/')[-2]
    calc = BPNeural(json='{0}'.format(name))

    fit = []
    for atoms in img:
        atoms.set_calculator(calc)
        fit.append(atoms.get_potential_energy() / len(atoms))

    plt.plot(ca, fit, 'o-',
             label='{0}'.format(n),
             color=form[i])

plt.xlabel('c/a ratio')
plt.ylabel('Total energy (eV/atom)')
plt.xlim(ca[0], ca[-1])
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/rxn-path-db1.png')
#+END_SRC

#+RESULTS:

** All bulk structures
#+org_attr: :width 400
[[./images/all-db1.png]]

#+org_attr: :width 400
[[./images/bct-db1.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob
import os

db = connect('networks/db1-cln/data.db')

nrg, img, ids = [], [], []
for d in db.select(['gga=PS']): #, 'bulk=bct'
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    nrg.append(d.total_energy / len(atoms))
    ids.append(d.id)

form = ['#FF0000', '#FFFF33',
        '#006600', '#00FFFF',
        '#0000FF', '#FF0099']

plt.figure()
plt.plot([ids[0], ids[-1]], [0, 0], 'k--', lw=2)

err = {}
for i, name in enumerate(glob('./networks/db1-50Cu/*/parameters-checkpoint.json')):
    n = name.split('/')[-2]
    calc = BPNeural(json='{0}'.format(name))
    err[n] = []

    dif = []
    for j, atoms in enumerate(img):
        atoms.set_calculator(calc)
        e = atoms.get_potential_energy() / len(atoms)
        difference = e - nrg[j]
        if difference >= 0.1:
            err[n].append(ids[j])
        dif.append(difference)

    plt.plot(ids, dif, 'o',
             label='{0}'.format(n),
             color=form[i])
plt.xlabel('IDs')
plt.ylabel('Energy difference (eV/atom)')
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/all-db1.png')
#+END_SRC

** surface predictions

[[./images/surf-db1.png]]

#+BEGIN_SRC python :results silent
import numpy as np
from ase.lattice.surface import fcc111_root
from ase.visualize import view
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from glob import glob
import matplotlib.patches as mpatches
import matplotlib.lines as mlines
import os

lattice = np.array([3.631, 3.712, 3.792, 3.872, 3.953])
site = [[None], [6], [6, 7], [6, 7, 8]]

colr = ['#FF0000', '#FF6600', '#FFFF33',
        '#006600', '#00FF00', '#00FFFF',
        '#0000FF', '#9933FF', '#FF0099']

shape = ['o', '^', 's', 'p']

patches = [] 

for i, name in enumerate(glob('./networks/db1-train/*/trained-parameters.json')):
    n = name.split('/')[-2]
    calc = BPNeural(json='{0}'.format(name))
    patches.append(mpatches.Patch(color=colr[i], label='{0}'.format(n)))
    for a in lattice:
        

        nrg = []
        for h, s in enumerate(site):
            atoms = fcc111_root('Cu', root=3, size=(1, 1, 3), vacuum=6.0, a=a)
            for si in s:
                atoms[si].symbol = 'Pd'

            atoms.set_calculator(calc)
            nrg = atoms.get_potential_energy() / len(atoms)

            plt.scatter(a, nrg,
                        color=colr[i],
                        marker=shape[h])

for i, s in enumerate(shape):
    patches.append(mlines.Line2D([], [], color='k', marker=s, lw=0,
                          markersize=10, label='{0}Pd'.format(i)))

plt.xlabel('Lattice constant ($\AA$)')
plt.ylabel('Total energy (eV/atom)')
plt.legend(loc='best', handles=patches)
plt.tight_layout()
plt.savefig('./images/surf-db1.png')
#plt.show()
#+END_SRC

** EOS reproduction

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob
import os

db = connect('networks/db1-50Cu/data.db')

cfgs = []
for d in db.select():
    if d.config not in cfgs:
        cfgs.append(d.config)

db = connect('networks/db1-cln/data.db')

bulk = ['fcc', 'bcc']

for cfg in cfgs:
    for b in bulk:
        nrg, img, ids = [], [], []
        try:
            for d in db.select(['config={0}'.format(cfg), 'bulk={0}'.format(b)]):
                atoms = db.get_atoms(d.id)
                img.append(atoms)
                nrg.append(d.total_energy / len(atoms))
                ids.append(d.volume / len(atoms))

            form = ['#FF0000', '#FFFF33',
                    '#006600', '#00FFFF',
                    '#0000FF', '#FF0099']

            f, ax = plt.subplots(2, sharex=True)
            ax[1].plot([ids[0], ids[-1]], [0, 0], 'k--', lw=2)
            ax[0].plot(ids, nrg, 'o', label='DFT', color='k', mfc='none', ms=6)

            err = {}
            for i, name in enumerate(glob('./networks/db1-50Cu/*/parameters-checkpoint.json')):
                n = name.split('/')[-2]
                calc = BPNeural(json='{0}'.format(name))
                err[n] = []

                dif, E = [], []
                for j, atoms in enumerate(img):
                    atoms.set_calculator(calc)
                    e = atoms.get_potential_energy() / len(atoms)
                    E.append(e)
                    difference = e - nrg[j]
                    if difference >= 0.1:
                        err[n].append(ids[j])
                    dif.append(difference)

                ax[0].plot(ids, E, '.',
                           label='{0}'.format(n),
                           color=form[i], alpha=0.5)
                ax[1].plot(ids, dif, '.',
                           label='{0}'.format(n),
                           color=form[i], alpha=0.5)
            ax[1].set_xlabel('Volume ($\AA$/atom)')
            ax[0].set_ylabel('Potential energy (eV/atom)')
            ax[1].set_ylabel('Energy difference (eV/atom)')
            ax[0].legend(loc='best', fontsize=8)
            plt.tight_layout()
            plt.savefig('./images/EOS-{0}-{1}.png'.format(cfg, b))
        except:
            pass
#+END_SRC

#+BEGIN_SRC python
from neural.bp import BPNeural
from ase.db import connect
from ase.visualize import view

calc = BPNeural(json='./networks/db1-50Cu/l3n40/parameters-checkpoint.json')
db = connect('networks/db1-cln/data.db')

img = []
for i, d in enumerate(db.select(['config=3', 'bulk=fcc'])):
    atoms = db.get_atoms(d.id)
    img.append(atoms)  
    ref = d.total_energy / len(atoms)

    atoms.set_calculator(calc)
    nrg = atoms.get_potential_energy() / len(atoms)
    dif = nrg - ref
    if abs(dif) >= 0.1:
        print '{0} {1} {2}'.format(nrg, ref, dif)
        print d.path, d.traj
        #view(atoms)
#+END_SRC

#+RESULTS:
: -5.21842918214 -4.566719705 -0.651709477143
: /home-research/jboes/research/cluster-expansion/DFT/bulk=fcc/config=3/xc=PBE/gga=None 2
: -5.19402538259 -4.566840455 -0.627184927588
: /home-research/jboes/research/cluster-expansion/DFT/bulk=fcc/config=3/xc=PBE/gga=None 1
: -5.20790152126 -4.568850525 -0.639050996258
: /home-research/jboes/research/cluster-expansion/DFT/bulk=fcc/config=3/xc=PBE/gga=None 0



* Surface calculations / manually selected configurations
  
** Relaxations of root 7 x root 7 slab
#+BEGIN_SRC python
from jasp import *
from ase.lattice.surface import fcc111_root
from ase.visualize import view
import numpy as np

# Energy unique onfigurations were manually determined 
configurations = {0:[[]],
                  1:[[32]],
                  2:[[32, 31]],
                  3:[[28, 31, 32],
                     [31, 32, 33]],
                  4:[[29, 30, 33, 34],
                     [28, 29, 30, 34]],
                  5:[[28, 29, 30, 33, 34]],
                  6:[[28, 29, 30, 31, 33, 34]],
                  7:[[28, 29, 30, 31, 32, 33, 34]]}

basis = [['Cu', 'Pd', 3.634],
         ['Pd', 'Cu', 3.939]]

for base in basis:
    b, i, a = base
    for j, cfgs in configurations.iteritems():
        for k, cfg in enumerate(cfgs):

            atoms = fcc111_root(b, 7, [1, 1, 5], a=a)
            for l in cfg:
                atoms[l].symbol = i
            wd = 'DFT/surf=fcc/host={0}/lattice={1:1.3f}/cnt={2}/config={3}'.format(b, a, j, k)

            with jasp(wd,
                      xc='PBE',
                      gga='PS',
                      encut=400,
                      kpts=(5, 5, 1),
                      ibrion=2,
                      isif=2,
                      nsw=40,
                      ediff=1e-5,
                      atoms=atoms) as calc:
                try:
                    atoms = calc.get_atoms()
                    nrg = atoms.get_potential_energy()
                except(VaspQueued, VaspSubmitted):
                    print wd, 'Queued'
#+END_SRC

** xy strain effect surface
#+BEGIN_SRC python
from jasp import *
from ase.lattice.surface import fcc111_root
from ase.visualize import view
import numpy as np
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 4

configurations = {0:[[]],
                  1:[[32]],
                  2:[[32, 31]],
                  3:[[28, 31, 32],
                     [31, 32, 33]],
                  4:[[29, 30, 33, 34],
                     [28, 29, 30, 34]],
                  5:[[28, 29, 30, 33, 34]],
                  6:[[28, 29, 30, 31, 33, 34]],
                  7:[[28, 29, 30, 31, 32, 33, 34]]}

basis = [['Cu', 'Pd', 3.634, np.linspace(0.96, 1.16, 14)],
         ['Pd', 'Cu', 3.939, np.linspace(0.84, 1.04, 14)]]

cells = {}
for b, i, a, fac in basis:
    with jasp('DFT/surf=fcc/host={0}/lattice={1:1.3f}/cnt=0/config=0'.format(b, a)) as calc:
        atoms = calc.get_atoms()
        cell0 = atoms.get_cell()

    pos = atoms.get_positions()
    z = pos[12][-1] - pos[5][-1]
    cells['{0:1.3f}'.format(z)] = []
    for f in fac:
        delta = np.array([[f, 0, 0],
                          [0, f, 0],
                          [0, 0, 1.0]])

        cells['{0:1.3f}'.format(z)].append(np.dot(cell0, delta))
    cells['{0:1.3f}'.format(z)] = np.array(cells['{0:1.3f}'.format(z)])

for b, i, a, fac in basis:

    for j, cfgs in configurations.iteritems():
        for k, cfg in enumerate(cfgs):

            for z, cell in cells.iteritems():

                for c in cell:

                    wd = 'DFT/surf=fcc/host={0}/lattice={1:1.3f}/cnt={2}/config={3}'.format(b, a, j, k)

                    with jasp(wd) as calc:
                        atoms = calc.get_atoms()

                    atoms.set_cell(c, scale_atoms=True)

                    pos = atoms.get_positions()
                    lat = np.linalg.norm(pos[5] - pos[12])

                    nwd = 'DFT/surf=fcc/host={0}/z={1}/xy={2:1.3f}/cnt={3}/config={4}'.format(b, z, lat, j, k)
                    print nwd

                    with jasp(nwd,
                              xc='PBE',
                              gga='PS',
                              encut=400,
                              kpts=(5, 5, 1),
                              ibrion=-1,
                              ediff=1e-5,
                              atoms=atoms) as calc:
                        try:
                            calc.get_required_memory()
                            atoms = calc.get_atoms()
                            nrg = atoms.get_potential_energy()
                        except(VaspSubmitted, VaspQueued):
                            pass
#+END_SRC

#+BEGIN_SRC python
from jasp import *
from ase.lattice.surface import fcc111_root
from ase.visualize import view
import numpy as np
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 4

configurations = {0:[[]],
                  1:[[32]],
                  2:[[32, 31]],
                  3:[[28, 31, 32],
                     [31, 32, 33]],
                  4:[[29, 30, 33, 34],
                     [28, 29, 30, 34]],
                  5:[[28, 29, 30, 33, 34]],
                  6:[[28, 29, 30, 31, 33, 34]],
                  7:[[28, 29, 30, 31, 32, 33, 34]]}

with jasp('DFT/surf=fcc/host=Pd/lattice=3.939/cnt=0/config=0') as calc:
    atoms = calc.get_atoms()
    cell0 = atoms.get_cell()


f = 1.04

delta = np.array([[f, 0, 0],
                  [0, f, 0],
                  [0, 0, 1.0]])

atoms.set_cell(np.dot(cell0, delta), scale_atoms=True)

pos = atoms.get_positions()
z = pos[12][-1] - pos[5][-1]
lat = np.linalg.norm(pos[5] - pos[12])
print lat, z
#+END_SRC

#+RESULTS:
: 4.04472202041 2.27418271034

** surface predictions

#+BEGIN_SRC python
import numpy as np
from ase.lattice.surface import fcc111_root
from ase.visualize import view
import matplotlib.pyplot as plt
from neural.bp import BPNeural
from ase.db import connect
import matplotlib.patches as mpatches

var = np.linspace(0.9, 1.3, 20)
site = [31, 32, 28]

c = ['k', 'b', 'g']

dirs = ['./networks/db2-surf/l3n35i1/parameters-checkpoint.json',
        './networks/db2-surf/l3n30i0/parameters-checkpoint.json',
        './networks/db2-surf/l3n25i0/parameters-checkpoint.json']

patches = []
for i, name in enumerate(dirs):
    patches.append(mpatches.Patch(color=c[i],
                                  label='{0}'.format(name.split('/')[-2])))

    calc = BPNeural(json='{0}'.format(name))
    for a in var:
        atoms = fcc111_root('Cu', root=13, size=(1, 1, 5), vacuum=6.0, a=3.634)
        cell = atoms.get_cell()
        delta = np.array([[a, 0, 0],
                          [0, a, 0],
                          [0, 0, 1]])
        atoms.set_cell(np.dot(cell, delta), scale_atoms=True)
        for s in site:
            atoms[s].symbol = 'Pd'

        atoms.set_calculator(calc)

        plt.scatter(a,
                    atoms.get_potential_energy() / len(atoms),
                    color=c[i])

view(atoms)
plt.xlabel('Varaible ($\AA$)')
plt.ylabel('Total energy (eV/atom)')
plt.legend(loc='best')
plt.tight_layout()
plt.show()
#+END_SRC

** training set residuals
#+attr_org: :width 500
[[./images/db2-surf.png]]

#+BEGIN_SRC python :results silent
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
from ase.db import connect
from neural.bp import BPNeural
import numpy as np
from glob import glob
from scipy.stats import norm
from matplotlib import gridspec

db = connect('networks/db2-surf/data.db')

img, nrg, ids = [], [], []
for d in db.select():
    img.append(db.get_atoms(d.id))
    nrg.append(d.total_energy / len(d.symbols))
    ids.append(d.id)

calc = BPNeural(json='networks/db2-surf/l3n30i0/parameters-checkpoint.json')

fit = []
for atoms in img:
    atoms.set_calculator(calc)
    fit.append(atoms.get_potential_energy() / len(atoms))
dif = np.array(fit) - np.array(nrg)

RMSE = np.sqrt(sum(dif ** 2) / len(dif))

(mu, sigma) = norm.fit(dif)

fig = plt.figure(figsize=(8, 6)) 
gs = gridspec.GridSpec(1, 2, width_ratios=[2, 1])
ax0 = plt.subplot(gs[0])
ax0.scatter(ids, dif, marker='o', color='k', alpha=0.5)
ax0.plot([0, len(dif)-1], [0, 0], 'r--', lw=2)
ax0.text(len(dif)*0.05, max(abs(dif)), 'RMSE: {0:1.3f}'.format(RMSE), fontsize=15, va='top', ha='left')
ax0.set_xlim(0, len(dif)-1)
ax0.set_ylim(-max(abs(dif))-0.1*max(abs(dif)), max(abs(dif))+0.1*max(abs(dif)))
ax0.set_xlabel('Calculation ID')
ax0.set_ylabel('Energy residual error (eV/atom)')

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(dif, 20,
                            range=(-max(abs(dif))-0.1*max(abs(dif)),
                                   max(abs(dif))+0.1*max(abs(dif))),
                            normed=True,
                            facecolor='k',
                            alpha=0.5,
                            orientation='horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(1, max(abs(dif)), '$\mu$: {0:1.3f}'.format(mu), fontsize=15, va='top', ha='left')
ax1.text(1, max(abs(dif))*0.9, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=15, va='top', ha='left')
ax1.plot(y, bins, 'k--', lw=2)
ax1.plot([0, 35], [0, 0], 'r--', lw=2)
ax1.set_xlabel('Probability density')
ax1.set_ylim(-max(abs(dif))-0.1*max(abs(dif)), max(abs(dif))+0.1*max(abs(dif)))
ax1.set_xlim(0, 35)
ax1.set_yticklabels(())

plt.subplots_adjust(left=0.11,
                    bottom=0.09,
                    right=0.97,
                    top=0.97,
                    wspace=0.02,
                    hspace=0.2)

plt.savefig('./images/db2-surf.png')
#+END_SRC

* Surface calculations via EMT permutation

** Unique structure calculator
This code uses ASAPs EMT calculator to calculate the energy of /all/ permutations given to it. It will then add the energy unique permutations to a trajectory file for later reference. 
#+BEGIN_SRC python
from itertools import product
from ase.lattice.surface import fcc111_root
from asap3 import EMT
from ase import Atoms
from ase.db import connect
from amp.utilities import hash_image

base = fcc111_root('Cu', 7, size=(1, 1, 5), vacuum=6.0, a=3.634)
natoms = [a.index for a in base if a.tag <= 1]
metals = ['Cu', 'Pd']

with connect('traj/unique-1layer.db') as db:
    nrgs = set()
    for i, c in enumerate(product(metals, repeat=len(natoms))):
        atoms0 = Atoms.copy(base)
        for j, s in enumerate(natoms):
            atoms0[s].symbol = c[j]

        atoms = Atoms.copy(atoms0)
        atoms.set_calculator(EMT())
        nrg = round(atoms.get_potential_energy(), 3)
        atoms.set_calculator(None)

        if nrg not in nrgs:
            nrgs.add(nrg)
            db.write(atoms)
#+END_SRC

#+RESULTS:
: 21

** JASP calculations of unique configurations
#+BEGIN_SRC python
from ase.lattice.surface import fcc111_root
from ase.db import connect
from jasp import *
from ase.constraints import FixAtoms
from ase.visualize import view
import jbutil as jb
JASPRC['queue.ppn'] = 4
JASPRC['restart_unconverged'] = False

db = connect('traj/unique-2layer.db')

basis = [['Cu', 3.634], ['Pd', 3.939]]


UF = []
for base in basis:

    b, a = base

    for i, d in enumerate(db.select()):

        atoms = fcc111_root(b, 7, [1, 1, 5], a=a, vacuum=6.0)
        n = [atom.index for atom in atoms if atom.tag <= 2]
        cfg = d.symbols[21:]

        for j, s in enumerate(n):
            atoms[s].symbol = cfg[j]

        constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
        atoms.set_constraint(constraint)

        wd = 'DFT/surf=fcc/host={0}/lattice={1:1.3f}/type=layers2/cfg={2}/xy=1.00'.format(b, a, i)

        try:
            with jasp(wd,
                      xc='PBE',
                      encut=400,
                      kpts=(5, 5, 1),
                      ibrion=2,
                      isif=2,
                      nsw=40,
                      ediff=1e-5,
                      atoms=atoms) as calc:
                try:
                    calc.get_required_memory()
                    atoms = calc.get_atoms()
                    nrg = atoms.get_potential_energy()
                    print nrg
                except(VaspQueued, VaspSubmitted):
                    pass
        except(VaspNotFinished):
            UF += [wd]
            jb.reset(wd)

JASPRC['restart_unconverged'] = True

for wd in UF:
    with jasp(wd) as calc:
        try:
            calc.get_required_memory()
            calc.calculate()
        except(VaspQueued, VaspSubmitted):
            pass
#+END_SRC

** single point calculations for xy and isotropic strain effects
#+BEGIN_SRC python
import numpy as np
import os
from jasp import *
from ase.visualize import view
JASPRC['queue.ppn'] = 5
JASPRC['queue.walltime'] = '24:00:00'

# Fraction determined by hand, but could also be calculated from fcc lattice geometry
# basis = [['Cu', 3.634, np.linspace(1.00, 1.08392955421, 4)],]
basis = [['Pd', 3.939, np.linspace(1.00, 1.0/1.08392955421, 4)]]

for M, a, factors in basis:

    for cfg in range(343): # The number of unique 2-layer configurations

        wd0 = 'DFT/surf=fcc/host={0}/lattice={1}/type=layers2/cfg={2}/xy=1.00'.format(M, a, cfg)

        for f in factors:

            # For each configurations, start from relaxed geom and apply isotropic strain
            delta = np.array([[f, 0, 0],
                              [0, f, 0],
                              [0, 0, f]])

            with jasp(wd0) as calc:
                atoms = calc.get_atoms()
                cell = atoms.get_cell()

            atoms.set_cell(np.dot(cell, delta), scale_atoms=True)
            lat = atoms.get_distance(2, 10)

            wd = './DFT/surf=fcc/host={0}/lattice={1:1.3f}/type=layers2/cfg={2}/xy=1.00'.format(M, lat, cfg)

            if not os.path.exists(wd):
                with jasp(wd,
                          xc='PBE',
                          encut=400,
                          kpts=(5, 5, 1),
                          ibrion=-1,
                          atoms=atoms) as calc:
                    try:
                        calc.get_required_memory()
                        calc.calculate()
                    except(VaspSubmitted, VaspQueued):
                        pass
#+END_SRC

#+RESULTS:

* Analysis of first NN

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.mlab as mlab

db = connect('networks/db2/data.db')

E = {}
E[1], E[0] = [], []
tags = []
for d in db.select([]):
    
    if d.train_set:
        E[1] += [[d.energy / d.natoms,
                  d.NN10 / d.natoms,
                  d.NN12 / d.natoms,
                  d.NN14 / d.natoms,
                  d.NN16 / d.natoms]]
    else:
        E[0] += [[d.energy / d.natoms,
                  d.NN10 / d.natoms,
                  d.NN12 / d.natoms,
                  d.NN14 / d.natoms,
                  d.NN16 / d.natoms]]

E[1] = np.array(E[1])
E[0] = np.array(E[0])

Qe = E[1].T[0]
Ne = E[1].T[1]

vQe = E[0].T[0]
vNe = E[0].T[1]

RMSE = np.sqrt(((Ne - Qe) ** 2).mean())
vRMSE = np.sqrt(((vNe - vQe) ** 2).mean())

(mu, sig) = norm.fit(Ne - Qe)
(vmu, vsig) = norm.fit(vNe - vQe)

fig = plt.figure(figsize=(6, 4)) 
gs = gridspec.GridSpec(1, 2, width_ratios=[2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), max(Qe)], [0, 0], 'k--', lw=2)
ax0.scatter(Qe, Ne - Qe, marker='o', color='b')
ax0.scatter(vQe, vNe - vQe, marker='o', color='r')
ax0.text(min(Qe) + 0.1, 0.014,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize=12, va='top', ha='left', color='b')
ax0.text(min(vQe) + 0.1, -0.014,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize=12, va='bottom', ha='left', color='r')
ax0.set_xlim(min(Qe), max(Qe))
ax0.set_ylim(-0.015, 0.015)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Residual error (eV/atom)')
#ax0.legend(loc='best', handles=hdl, fontsize=12, frameon=False)

ax1 = plt.subplot(gs[1])

n, bins, patches = ax1.hist(Ne - Qe, 60,
                            range=(-0.015, 0.015),
                            weights=np.ones_like(Ne - Qe)/len(Ne),
                            facecolor='b',
                            alpha=0.3,
                            orientation='horizontal')

vn, vbins, vpatches = ax1.hist(vNe - vQe, 60,
                               range=(-0.015, 0.015),
                               weights=np.ones_like(vNe - vQe)/len(vNe),
                               facecolor='r',
                               alpha=0.3,
                               orientation='horizontal')

y = mlab.normpdf(bins, mu, sig)
ax1.text(0.05, 0.0142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.0122, '$\sigma$: {0:1.3f}'.format(sig), fontsize=12, va='top', ha='left')
ax1.plot(y / sum(y), bins, 'k--', lw=2)
ax1.plot([0, 0.5], [0, 0], 'k--', lw=2)
ax1.set_xlabel('Probability')
# ax1.set_ylim(-0.015, 0.015)
# ax1.set_xlim(0, 0.6)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad=-0.5)
plt.show()
#plt.savefig('./images/fig-neural-train.png')
print (np.abs(Ne - Qe) > sig*3).sum()
print (np.abs(vNe - vQe) > vsig*3).sum()
print (np.abs(Ne - E[1].T[2]) > vsig*6).sum()
print '-----'
print len(Qe)
print len(vQe)
print vsig*6
#+END_SRC

#+RESULTS:
: 278
: 27
: 79
: -----
: 17417
: 1935
: 0.00587838138904

* Second NN iteration
** Predictions
*** Update unique configurations
Each of the unique configurations produced above will also have an Cu based equivalent. We generate those here:

#+BEGIN_SRC python :results silent
from ase.db import connect
from ase.io import read
import numpy as np
from ase.visualize import view

images = read('traj/unique-1layer.db')

with connect('traj/unique-1layer.db') as db:
    for atoms in images:
        symbols = []
        for atom in atoms:
            if atom.symbol == 'Pd':
                symbols += ['Cu']
            else:
                symbols += ['Pd']
        atoms.set_chemical_symbols(symbols)

        db.write(atoms)
#+END_SRC

*** Producing files for predictions
**** Creating lattice constant perturbations
#+BEGIN_SRC python :results silent
from ase.db import connect
from ase.io import read
import numpy as np
from amp.utilities import hash_image
from amp import Amp
import os

images = read('traj/unique-1layer.db')
factors = np.linspace(3.634, 3.939, 5)

rp = connect('temp/rep-1layer.db')

hashs = set()
with connect('temp/pred-1layer.db') as db:

    for d in db.select():
        hashs.add(d.hash)

    for x in factors:
        for atoms in images:
            cell = atoms.get_cell()
            f = x / np.linalg.norm(cell[0] / np.sqrt(7) / (0.5**0.5))

            delta = np.array([[f, 0, 0],
                              [0, f, 0],
                              [0, 0, f]])

            atoms.set_cell(np.dot(cell, delta),
                           scale_atoms=True)

            H = hash_image(atoms)
            if H not in hashs:
                hashs.add(H)

                calc = Amp('networks/db2/40-10-10-1/')
                atoms.set_calculator(calc)
                nrg10 = atoms.get_potential_energy()

                calc = Amp('networks/db2/40-12-12-1/')
                atoms.set_calculator(calc)
                nrg12 = atoms.get_potential_energy()
                atoms.set_calculator(None)

                db.write(atoms, hash=H,
                         data={'NN10': nrg10,
                               'NN12': nrg12})
            else:
                rp.write(atoms, hash=H)
#+END_SRC

*** Analysis of prediction files
In this section, we analyze the difference between energies predicted for various structures between two different neural network frameworks. Each figure demonstrates this effect for a different set of structures. Each set of structures is based on a root(7) \times root(7) fcc(111) surface lattice which is 5 layers deep. The only differences between these structures is the identity of the atoms filling the lattice positions, and also the lattice constant of the unit cell.

#+caption: Demonstration of the lattice structures utilized in the following section. The darker the atom, the deeper the layer.
#+label: structure-types
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 800
[[./images/structure-types.png]]    

#+BEGIN_SRC python :results silent
from ase.visualize import view
from ase.lattice.surface import fcc111_root
from ase.io import write
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
import matplotlib.image as mpimg
import os

lat = np.linspace(3.634, 3.939, 5)

p = np.linspace(0.05, 0.9, 5)

fig = plt.figure(figsize=(8, 3))
ax = fig.add_subplot(111)
for i, a in enumerate(lat):
    atoms = fcc111_root('Cu', root=7,
                        size=(1, 1, 5),
                        vacuum=6.0, a=a)

    col = abs((atoms.get_tags() / 5.0) - 1.0)

    kwargs = {
        'rotation': "-75x",
        'show_unit_cell': 2,
        'colors': np.array([col, col, col]).T,
        'radii': [0.3] * len(atoms)}

    write('images/temp.png', atoms, **kwargs)

    image = mpimg.imread('./images/temp.png')
    imagebox = OffsetImage(image, zoom=0.5)

    ax.add_artist(AnnotationBbox(imagebox,
                                 xy=(0, 0),
                                 xybox=(p[i], 0.5),
                                 pad=-0.2,
                                 frameon=False,
                                 arrowprops=None)
                 )
    ax.text(p[i], -0.13, '{0:1.3f} $\AA$'.format(a),
            va='center', ha='center')
    os.unlink('./images/temp.png')

fig.patch.set_visible(False)
ax.axis('off')
plt.tight_layout()
plt.savefig('images/structure-types.png')
#+END_SRC

For a particular lattice (3.939 $\AA$), all combinations of Cu and Pd atoms were created for a particular number of layers. In Figure ref:composition-types, this is demonstrated 

#+caption: Demonstration of the lattice structures utilized in the following section. The darker the atom, the deeper the layer.
#+label: composition-types
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/composition-types.png]]

#+BEGIN_SRC python :results silent
from ase.visualize import view
from ase.lattice.surface import fcc111_root
from ase.io import write
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
import matplotlib.image as mpimg
import os

p = np.linspace(0.2, 0.8, 2)

fig = plt.figure(figsize=(4, 3))
ax = fig.add_subplot(111)
for i, M in enumerate(['Cu', 'Pd']):
    atoms = fcc111_root(M, root=7,
                        size=(1, 1, 5),
                        vacuum=6.0,
                        a=3.787)

    C = [200/255., 129/255., 51/255.] 
    B = [0/255., 105/255., 134/255.]

    if i == 0:
        col = [C] * 31 + [B] * 4
    else:
        col = [B] * 31 + [C] * 4

    kwargs = {
        'rotation': "-75x",
        'show_unit_cell': 2,
        'colors': col,
        'radii': None}

    write('images/temp.png', atoms, **kwargs)

    image = mpimg.imread('./images/temp.png')
    imagebox = OffsetImage(image, zoom=0.6)

    ax.add_artist(AnnotationBbox(imagebox,
                                 xy=(0, 0),
                                 xybox=(p[i], 0.5),
                                 pad=-0.2,
                                 frameon=False,
                                 arrowprops=None))
    os.unlink('./images/temp.png')

fig.patch.set_visible(False)
ax.axis('off')
plt.tight_layout()
plt.savefig('images/composition-types.png')
#+END_SRC

#+caption: 
#+label: fig-1layer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db0-1layer.png]]

[[./images/db0-2layer.png]]

[[./images/db0-3layer.png]]

#+BEGIN_SRC python :results silent
from ase.db import connect
from amp import Amp
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/pred-1layer.db')

E = []
for d in db.select():
    E += [abs(d.data.NN10 / d.natoms - d.data.NN12 / d.natoms)]
E = np.array(E)

def nbins(x):
    from math import log10, floor, ceil
    p = -int(floor(log10(x)) - 1)
    w = ceil(x*10**p) / ceil(x*10**p)*10**-p
    m = ceil(x*10**p)
    return np.arange(0, m*w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.xlim(0, nbins(max(E)).max())
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/db0-1layer.png')
#+END_SRC


** Beginning additional calculations
#+BEGIN_SRC python
from ase.db import connect
import numpy as np
from ase.visualize import view
import os
from jasp import *
JASPRC['queue.ppn'] = 5
JASPRC['queue.walltime'] = '24:00:00'

db = connect('traj/unique-3layer.db')

for cfg, d in enumerate(db.select()):
    E = abs(d.NN10 / d.natoms - d.NN12 / d.natoms)
    if E > 0.11:
        atoms = db.get_atoms(d.id)
        lat = atoms.get_distance(5, 12)
        M = atoms[0].symbol

        wd = './DFT/surf=fcc/host={0}/lattice={1:1.3f}/type=layers3/cfg={2}/xy=1.00'.format(M, lat, cfg)
        if not os.path.exists(wd):
            with jasp(wd,
                      xc='PBE',
                      encut=400,
                      kpts=(5, 5, 1),
                      ibrion=-1,
                      atoms=atoms) as calc:
                try:
                    calc.get_required_memory()
                    calc.calculate()
                except(VaspSubmitted, VaspQueued):
                    pass
#+END_SRC
