* ATAT
This section is designated for all ATAT related calculation and analysis.

** Calculations
Section for setting up various ATAT calculations.

*** Binary alloy calculations
Here we initialize files using a dynamic scaling method which adjusts the lattice size depending on the alloy composition.

#+BEGIN_SRC python :results silent
import numpy as np
from subprocess import call

# This code is used to get a better starting point for lattice constant
lattice = np.array([3.631, 3.712, 3.792, 3.872, 3.953])
rad = 1 / (2*np.sqrt(2)) * lattice
scale = rad[2] / rad[-1]

call(["makelat", "-s={0}".format(scale), "Cu,Pd", "fcc,bcc"])

script = '''[INCAR]
ENCUT = 400
NSW = 50
IBRION = 2
ISIF = 7
KPPRA = 2500
EDIFF = 1e-6
GGA = PS
USEPOT = PAWPBE
'''

with open('vasp.wrap', 'w') as f:
    f.write(script)
#+END_SRC

In this section we begin generate certain number of initial configurations predicted to be unique by ATAT using the existing cluster expansion. The second portion of the code then performs VASP calculations on these structures.

#+BEGIN_SRC python :results silent
import os
import time

# The number of structures to create
N = 10

for d in ['./CuPd_bcc', './CuPd_fcc']:
    os.chdir(d)
    os.system('maps -t=0.25 &')
    for n in range(N):
        open('ready', 'w').close()
        while os.path.exists('ready'):
            time.sleep(0.1)
    open('stop', 'w').close()

time.sleep(3)

# In this section we perfrom VASP calculations on all non-completed configurations
from subprocess import call
for d in ['./CuPd_bcc', './CuPd_fcc']:
    os.chdir(d)
    call(["foreachfile", "wait", "run_atat_vasp.py"])
#+END_SRC

*** Status check
This code performs a simple iteration over all of the structures generated by ATAT and reports their status.

#+BEGIN_SRC python
from subprocess import call

for d in ['./CuPd_bcc', './CuPd_fcc']:
    call(["atatstatus.py", d])
#+END_SRC

** Cluster expansion using NN
Here we initialize files using a dynamic scaling method which adjusts the lattice size depending on the alloy composition.

#+BEGIN_SRC python :result silent
import numpy as np
from subprocess import call

# This code is used to get a better starting point for lattice constant
scale = 3.7865 / 4.157788

call(["makelat", "-s={}".format(scale), "Cu,Pd", "fcc"])
#+END_SRC

In this section we begin generate certain number of initial configurations predicted to be unique by ATAT using the existing cluster expansion. The second portion of the code then performs VASP calculations on these structures.

#+BEGIN_SRC python :results silent
import os
import time

# The number of structures to create
N = 2000
t = 0.5

os.chdir('./CuPd_fcc')
os.system('maps -t={} &'.format(t))
for n in range(N):
    open('ready', 'w').close()
    while os.path.exists('ready'):
	time.sleep(t / 5)
open('stop', 'w').close()
#+END_SRC

#+BEGIN_SRC python :result silent
import os
from ase.lattice.cubic import FaceCenteredCubic as fcc
import numpy as np
from ase.db import connect
from ase.visualize import view
from atat import str2atoms, atoms2str
from amp import Amp
from ase.calculators.vasp import Vasp
from jasp import *
from jbtools.gilgamesh import compile_trajectory
from ase.io.trajectory import Trajectory
import jbtools.gilgamesh as jb
import sys
JASPRC['queue.walltime'] = '168:00:00'
JASPRC['queue.mem'] = '2GB'

def lat(comp):
    return (3.939 - 3.634)*comp + 3.634

os.chdir('./CuPd_fcc')

HOME = os.getcwd()

db = connect('~/research/cluster-expansion/CuPd_fcc/atat_atoms.db')

for r, d, f in os.walk('.'):

    if 'wait' in f and 'str.out' in f:
	ind = r.lstrip('./')

	wd = r + '/str.out'

	atoms = str2atoms(wd)
	syms = atoms.get_chemical_symbols()
	nPd = float(syms.count('Pd'))
	nCu = float(syms.count('Cu'))
	a = lat(nPd / (nCu + nPd))

	vol = atoms.get_volume()
	scal = a / (4 * vol / len(atoms))**(1/3.)

	fac = [[scal, 0., 0.],
	       [0., scal, 0.],
	       [0., 0., scal]]

	atoms.set_cell(np.dot(atoms.get_cell(), fac), scale_atoms=True)

	keys = {'a': float(a), 'atat': int(ind)}
	atoms.set_calculator(Amp('../networks/db5/40-7-7-1/'))
	nrg1 = atoms.get_potential_energy()
	keys.update({'nrg1': float(nrg1)})

	atoms.set_calculator(Amp('../networks/db5/40-6-6-1/'))
	nrg2 = atoms.get_potential_energy()
	keys.update({'nrg2': float(nrg2)})

	atoms.set_calculator(None)

	if os.path.exists(os.path.join(r, 'vasp.in')):
	    os.unlink(wd)
	    atoms2str(atoms, strout=wd)

	    os.chdir(r)
	    os.system('str2ezvasp')  # creates vasp.in
	    os.system('ezvasp -n vasp.in')  # creates VASP input files
	    os.chdir(HOME)

        try:
            with jasp(r) as calc:
                try:
                    atoms0 = calc.get_atoms()
                    nrg = atoms0.get_potential_energy()

                    try:
		        compile_trajectory(calc)
                    # The reset is creating identical OUTCAR files
                    # Without new XDATCAT files.
                    except(IndexError):
                        from glob import glob 
                        extra = glob('*.0')
                        for files in extra:
                            os.unlink(files)
                        compile_trajectory(calc)
                    traj = Trajectory('out.traj')

                    db.write(traj[0], key_value_pairs=keys)
                    with open('energy', 'w') as f:
                        f.write(str(nrg) + '\n')
                    os.unlink('wait')
                except(VaspQueued, VaspSubmitted):
                    pass
        except(VaspNotFinished):
            jb.reset(r)
            with jasp(r) as calc:
                try:
                    calc.calculate()
                except(VaspQueued, VaspSubmitted):
                    pass
#+END_SRC

#+RESULTS:

[[./images/atat-cluster-expansion.png]]

#+BEGIN_SRC python
from jasp import *
from glob import iglob
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 4

for wd in iglob('CuPd_fcc/*/'):

    nwd = wd.split('/')
    nwd[0] = 'ion_relax'
    nwd = '/'.join(nwd)

    with jasp(wd) as calc:
        atoms = calc.get_atoms()
	calc.clone(nwd)

    with jasp(nwd,
              isif=2,
              ibrion=2,
              nsw=40,
              atoms=atoms) as calc:
        calc.get_required_memory()
        calc.calculate()
#+END_SRC

#+BEGIN_SRC python :results silent
from ase.db import connect
from jbtools.utils import get_composition
import matplotlib.pyplot as plt

db = connect('./CuPd_fcc/atat_atoms.db')

Cu = db.get('atat=0')
Pd = db.get('atat=1')

I, C, Qe, Ne, dE = [], [], [], [], []
for d in db.select():
    syms = d.symbols
    nCu = float(syms.count('Cu'))
    nPd = float(syms.count('Pd'))

    I += [d.atat]
    C += [nPd / (nCu + nPd)]
    Qe += [(d.energy - nPd*Pd.energy - nCu*Cu.energy) / d.natoms]
    Ne += [(d.nrg1 - nPd*Pd.nrg1 - nCu*Cu.nrg1) / d.natoms]
    dE += [Ne[-1] - Qe[-1]]

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(6, 4))
ax[0].scatter(C, Qe)
ax[1].scatter(C, Ne)
ax[0].set_xlim(0, 1)
ax[1].set_xticks(ax[1].get_xticks()[2:])
ax[1].set_xlim(0, 1)
ax[0].set_xlabel('Composition Cu$_{1-x}$Pd$_{x}$, ($x$)')
ax[1].set_xlabel('Composition Cu$_{1-x}$Pd$_{x}$, ($x$)')
ax[0].set_ylabel('Heat of formation (eV/atom)')
plt.tight_layout(w_pad=-0.4)
plt.savefig('./images/atat-cluster-expansion.png')
#+END_SRC

** Analysis
Analysis of ATAT calculations.

*** Ground state hull of the
#+caption: Ground state hull of CuPd for fcc and bcc phases.
#+label: fig-cupd-gs
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/groundstate.png]]

#+BEGIN_SRC python : results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
JASPRC['restart_unconverged'] = False

config = ['fcc', 'bcc']
color = ['b', 'r']

plt.figure()
plt.plot([0.0, 1.0], [0, 0], 'k--')

for i, cfg in enumerate(config):

    with open('CuPd_{0}/gs.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        GS, EGS, CGS = [], [], []

        for line in lines:
            # Composition, DFT energy, Fit energy, Configuration
            x, y, z, c = line.split()

            CGS.append(x)
            EGS.append(y)
            GS.append(c)

    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        C, E = [], []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            x, y, z, e, w, c = line.split()

            C.append(x)
            E.append(y)

    plt.scatter(C, E, c='k', s=15)
    plt.plot(CGS, EGS, c='{0}'.format(color[i]), marker='o', label='{0}'.format(cfg))
    for j, gs in enumerate(GS[1:-1]):
        plt.text(CGS[1:-1][j], float(EGS[1:-1][j])-0.004,
                 '{0}'.format(gs),
                 color='{0}'.format(color[i]),
                 va='top', ha='center',
                 zorder=99)

plt.legend(loc='best')
plt.xlim(0, 1)
plt.xlabel('Composition (Pd)')
plt.ylabel('Heat of formation (eV/atom)')
plt.ylim(-0.15, 0.01)
plt.tight_layout()
plt.savefig('./images/groundstate.png')
#+END_SRC

* DFT
Section for running and organizing on going DFT calculations.

** CuPd fcc and bcc B2 configuration
Perform a high level DFT calculation on the fcc and bcc B2 phase. This is configuration 3 from the ATAT calculation set for both phases.

#+BEGIN_SRC python :results silent
from jasp import *
from ase.io import read
JASPRC['queue.walltime'] = '24:00:00'

# Run for fcc and bcc
for lbl in ['fcc', 'bcc']:

    # Get the CuPd structure for fcc and bcc from ATAT
    # Configuration '3', or B2 phase
    atoms = read('CuPd_{0}/3/CONTCAR'.format(lbl))

    # Will run these calculations on PBEsol and PBE
    for gga in ['PS', 'None']:

        with jasp('DFT/bulk={0}/config=3/xc=PBE/gga={1}'.format(lbl, gga),
                  xc='PBE',
                  gga='{0}'.format(gga),
                  encut=400,
                  kpts=(12, 12, 12),
                  nsw=10,
                  ibrion=2,
                  isif=7,
                  ediff=1e-8,
                  atoms=atoms) as calc:
            try:
                calc.calculate()
            except(VaspQueued, VaspSubmitted):
                pass
#+END_SRC

** fcc to fcc transition through bct geometry
*** data generation
#+BEGIN_SRC python :results silent
from ase.lattice.tetragonal import CenteredTetragonal as bct
import numpy as np
from ase.visualize import view
from jbutil import makedb
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

# Configuration '3' for fcc
with jasp('DFT/bulk=fcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

# This is the 'a' parameter from the calculation
afcc = np.linalg.norm(cell[0])

# Configuration '3' for bcc i.e. B2
with jasp('DFT/bulk=bcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

# This is the 'a' parameter from the calculation
abcc = np.linalg.norm(cell[0])

# Create a list of sample points
ca0 = np.linspace(0.9, 1.5, 31)
ca0 = np.append(ca0, [np.sqrt(2)])
a0 = np.linspace(2.5, 3.1, 31)
a0 = np.append(a0, [afcc, abcc])

for a in a0:

    for ca in ca0:

        # Generate structure based on sample points
        atoms = bct('Cu', latticeconstant={'a': a, 'c/a': ca})
        atoms[1].symbol = 'Pd'

        wd = 'DFT/bulk=bct/config=3/a={0}/ca={1}/xc=PBE/gga=PS'.format(a, ca)

        with jasp(wd,
                  xc='PBE',
                  gga='PS',
                  encut=400,
                  kpts=(12, 12, 12),
                  ibrion=-1,
                  ediff=1e-8,
                  atoms=atoms) as calc:
            try:
                calc.calculate()
            except(VaspQueued, VaspSubmitted):
                pass
#+END_SRC

*** data visualization
#+caption: 3D Minimum energy pathway of fcc to bcc transition through bct geometry space.
#+label: fig-3d-cupd-min
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/3D-bcc-pathway.png]]

#+BEGIN_SRC python
from ase.lattice.tetragonal import CenteredTetragonal as bct
from ase.db import connect
from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt
from matplotlib import cm
from jasp import *
from jbutil import makedb
JASPRC['queue.walltime'] = '24:00:00'

# Retrive the data
db = connect('data.db')
A, C = [], []
E = {}
for d in db.select([]):

    if d.a not in E.keys():
        E[d.a] = {}
    if d.ca not in E[d.a].keys():
        E[d.a][d.ca] = d.total_energy

    A.append(d.a)
    C.append(d.ca)

with jasp('DFT/bulk=fcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

    efcc = atoms.get_potential_energy()
    afcc = np.linalg.norm(cell[0])

with jasp('DFT/bulk=bcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

    ebcc = atoms.get_potential_energy()
    abcc = np.linalg.norm(cell[0])

uA = np.unique(A)
uC = np.unique(C)
X, Y = np.meshgrid(uA, uC)
Z = np.zeros(X.shape)

for i, a in enumerate(uA):
    for j, c in enumerate(uC):
        Z[j][i] = E[a][c]

fccZ, bccZ = [], []
eminZ = []
cminZ = []
aminZ = []

for i, c in enumerate(uC[5:-5]):
    data = Z[i+5, :]
    ind = data.tolist().index(min(data))

    eminZ.append(min(data))
    cminZ.append(c)
    aminZ.append(uA[ind])


rng = [ebcc, -10.2]

Z[Z > rng[1]] = np.nan

fig = plt.figure(figsize=(8, 6))
ax = fig.gca(projection='3d')
CM = cm.autumn

cset = ax.contourf(X, Y, Z, zdir='z', offset=-10.8, cmap=CM, vmin=rng[0], vmax=rng[1])

ax.plot_surface(X, Y, Z,
                rstride=1,
                cstride=1,
                cmap=CM,
                linewidth=0,
                vmin=rng[0],
                vmax=rng[1])


ax.scatter(aminZ[1:-1], cminZ[1:-1], eminZ[1:-1], c='k')

ax.plot([afcc, afcc], [np.sqrt(2), np.sqrt(2)], [-10.8, eminZ[-1]], 'go-', zorder=99)
ax.text(afcc, np.sqrt(2), eminZ[-1]+0.01, 'fcc', color='g', zorder=99, size='large')

ax.plot([abcc, abcc], [1.0, 1.0], [-10.8, eminZ[0]], 'bo-', zorder=99)
ax.text(abcc, 1.0, eminZ[0]+0.01, 'bcc', color='b', zorder=99, size='large')

ax.set_xlabel('a')
ax.set_xlim(2.4, 3.2)
ax.set_ylabel('c/a')
ax.set_ylim(0.8, 1.6)
ax.set_zlabel('Total energy (eV)')
ax.set_zlim(-10.8, rng[1])
plt.tight_layout()
plt.savefig('images/3D-bcc-pathway.png')

for i, ca in enumerate(cminZ):

    atoms = bct('Cu', latticeconstant={'a': aminZ[i], 'c/a': ca})
    atoms[1].symbol = 'Pd'

    wd = 'DFT/bulk=bct/config=3/pathway=True/ca={0}/xc=PBE/gga=None'.format(ca)

    with jasp(wd,
              xc='PBE',
              encut=400,
              kpts=(12, 12, 12),
              nsw=20,
              ibrion=2,
              isif=7,
              ediff=1e-9,
              atoms=atoms) as calc:
        try:
            calc.calculate()
        except(VaspQueued, VaspSubmitted):
            pass
#+END_SRC

** Generation of EOS from all ATAT configurations
Generates an EOS for each of the configurations produced by ATAT. This is done for both the fcc and bcc phase cluster expansions.

#+BEGIN_SRC python :results silent
import numpy as np
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

# For fcc and bcc configurations
for i, cfg in enumerate(['fcc', 'bcc']):

    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        # Begin a list of configurations
        C = []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            x, y, z, e, w, c = line.split()

            # We only need the configuration
            C.append(c)

    # Fraction of equilibrium lattice constant to be calculated.
    frac_eos = np.append(np.linspace(0.85, 1.15, 61), np.linspace(1.2, 2.0, 17))

    # This array represents all types of deformations we want to calculate.
    # The nominclature being used is as follows:
    # [ x , a , c ]
    # [ a , y , b ]
    # [ c , b , z ]
    # where a, b, and c are the xy, yz, and zx tensors, respectively.
    deformations = [['xyz', frac_eos]]

    for j, c in enumerate(C):

        for dfm in deformations:

            for frac in dfm[1]:

                # This code retrieves the optimized volume and atom positions from the ISIF=3 calculation.
                with jasp('CuPd_{0}/{1}'.format(cfg, c)) as calc:
                    atoms = calc.get_atoms()
                    cell0 = atoms.get_cell()
                    k1, k2, k3 = calc.input_params['kpts']

                dis = {}
                for vector in ['x', 'y', 'z', 'a', 'b', 'c']:
                    dis[vector] = 1.0

                    if vector in dfm[0]:
                        dis[vector] = frac

                delta = np.array([[dis['x']      , 0.5 * (dis['a'] - 1), 0.5 * (dis['c'] - 1)],
                                  [0.5 * (dis['a'] - 1), dis['y']      , 0.5 * (dis['b'] - 1)],
                                  [0.5 * (dis['c'] - 1), 0.5 * (dis['b'] - 1), dis['z']      ]])

                # This line adjusts the cell volume by the fraction specified above. 
                # The atoms are scaled accordingly inside the new unit cell.
                atoms.set_cell(np.dot(cell0, delta), scale_atoms=True)
                wd = 'DFT/bulk={0}/config={1}/strain={2}/factor={3}/xc=PBE/gga=PS'.format(cfg, c, dfm[0], frac)

                try:
                    with jasp(wd,
                              xc='PBE',
                              gga='PS',
                              kpts=(k1, k2, k3),
                              encut=400,
                              ibrion=-1,
                              ediff=1e-8,
                              atoms=atoms) as calc:
                        try:
                            atoms = calc.get_atoms()
                            nrg = atoms.get_potential_energy()
                            print 
                        except(VaspSubmitted, VaspQueued):
                            print wd, 'Queued'
                except(IOError):
                    print wd, 'IOError'
                except(VaspNotFinished):
                    print wd, 'VaspNotFinished'
#+END_SRC

** Relaxations of root 7 x root 7 slab (manual)
Manually determined configurations of an fcc root(7) \times root(7) slab. Only the chemical symbols of the first layer are allowed to change between Cu and Pd.

*** Full relaxation
#+BEGIN_SRC python
from jasp import *
from ase.lattice.surface import fcc111_root
import numpy as np

# Energy unique configurations were manually determined 
configurations = {0:[[]],
                  1:[[32]],
                  2:[[32, 31]],
                  3:[[28, 31, 32],
                     [31, 32, 33]],
                  4:[[29, 30, 33, 34],
                     [28, 29, 30, 34]],
                  5:[[28, 29, 30, 33, 34]],
                  6:[[28, 29, 30, 31, 33, 34]],
                  7:[[28, 29, 30, 31, 32, 33, 34]]}

basis = [['Cu', 'Pd', 3.634],
         ['Pd', 'Cu', 3.939]]

for base in basis:
    b, i, a = base
    for j, cfgs in configurations.iteritems():
        for k, cfg in enumerate(cfgs):

            atoms = fcc111_root(b, 7, [1, 1, 5], a=a)
            for l in cfg:
                atoms[l].symbol = i
            wd = 'DFT/surf=fcc/host={0}/lattice={1:1.3f}/cnt={2}/config={3}'.format(b, a, j, k)

            with jasp(wd,
                      xc='PBE',
                      gga='PS',
                      encut=400,
                      kpts=(5, 5, 1),
                      ibrion=2,
                      isif=2,
                      nsw=40,
                      ediff=1e-5,
                      atoms=atoms) as calc:
                try:
                    atoms = calc.get_atoms()
                    nrg = atoms.get_potential_energy()
                except(VaspQueued, VaspSubmitted):
                    print wd, 'Queued'
#+END_SRC

*** Strain effects xy
#+BEGIN_SRC python
from jasp import *
from ase.lattice.surface import fcc111_root
import numpy as np
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 4

configurations = {0:[[]],
                  1:[[32]],
                  2:[[32, 31]],
                  3:[[28, 31, 32],
                     [31, 32, 33]],
                  4:[[29, 30, 33, 34],
                     [28, 29, 30, 34]],
                  5:[[28, 29, 30, 33, 34]],
                  6:[[28, 29, 30, 31, 33, 34]],
                  7:[[28, 29, 30, 31, 32, 33, 34]]}

basis = [['Cu', 'Pd', 3.634, np.linspace(0.96, 1.16, 14)],
         ['Pd', 'Cu', 3.939, np.linspace(0.84, 1.04, 14)]]

cells = {}
for b, i, a, fac in basis:
    with jasp('DFT/surf=fcc/host={0}/lattice={1:1.3f}/cnt=0/config=0'.format(b, a)) as calc:
        atoms = calc.get_atoms()
        cell0 = atoms.get_cell()

    pos = atoms.get_positions()
    z = pos[12][-1] - pos[5][-1]
    cells['{0:1.3f}'.format(z)] = []
    for f in fac:
        delta = np.array([[f, 0, 0],
                          [0, f, 0],
                          [0, 0, 1.0]])

        cells['{0:1.3f}'.format(z)].append(np.dot(cell0, delta))
    cells['{0:1.3f}'.format(z)] = np.array(cells['{0:1.3f}'.format(z)])

for b, i, a, fac in basis:

    for j, cfgs in configurations.iteritems():
        for k, cfg in enumerate(cfgs):

            for z, cell in cells.iteritems():

                for c in cell:

                    wd = 'DFT/surf=fcc/host={0}/lattice={1:1.3f}/cnt={2}/config={3}'.format(b, a, j, k)

                    with jasp(wd) as calc:
                        atoms = calc.get_atoms()

                    atoms.set_cell(c, scale_atoms=True)

                    pos = atoms.get_positions()
                    lat = np.linalg.norm(pos[5] - pos[12])

                    nwd = 'DFT/surf=fcc/host={0}/z={1}/xy={2:1.3f}/cnt={3}/config={4}'.format(b, z, lat, j, k)
                    print nwd

                    with jasp(nwd,
                              xc='PBE',
                              gga='PS',
                              encut=400,
                              kpts=(5, 5, 1),
                              ibrion=-1,
                              ediff=1e-5,
                              atoms=atoms) as calc:
                        try:
                            calc.get_required_memory()
                            atoms = calc.get_atoms()
                            nrg = atoms.get_potential_energy()
                        except(VaspSubmitted, VaspQueued):
                            pass
#+END_SRC

** EMT unique configurations
DFT calculations to perform on EMT determined energy unique configurations.

*** 2 free-layer configurations
**** Ground state
#+BEGIN_SRC python :results silent
from ase.lattice.surface import fcc111_root
from ase.db import connect
from jasp import *
from ase.constraints import FixAtoms
from ase.visualize import view
import jbutil as jb
JASPRC['queue.ppn'] = 4
JASPRC['restart_unconverged'] = False

db = connect('traj/unique-2layer.db')

basis = [['Cu', 3.634], ['Pd', 3.939]]

UF = []
for base in basis:

    b, a = base

    for i, d in enumerate(db.select()):

        atoms = fcc111_root(b, 7, [1, 1, 5], a=a, vacuum=6.0)
        n = [atom.index for atom in atoms if atom.tag <= 2]
        cfg = d.symbols[21:]

        for j, s in enumerate(n):
            atoms[s].symbol = cfg[j]

        constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
        atoms.set_constraint(constraint)

        wd = 'DFT/surf=fcc/host={0}/lattice={1:1.3f}/type=layers2/cfg={2}/xy=1.00'.format(b, a, i)

        try:
            with jasp(wd,
                      xc='PBE',
                      encut=400,
                      kpts=(5, 5, 1),
                      ibrion=2,
                      isif=2,
                      nsw=40,
                      ediff=1e-5,
                      atoms=atoms) as calc:
                try:
                    calc.get_required_memory()
                    atoms = calc.get_atoms()
                    nrg = atoms.get_potential_energy()
                    print nrg
                except(VaspQueued, VaspSubmitted):
                    pass
        except(VaspNotFinished):
            UF += [wd]
            jb.reset(wd)

JASPRC['restart_unconverged'] = True

for wd in UF:
    with jasp(wd) as calc:
        try:
            calc.get_required_memory()
            calc.calculate()
        except(VaspQueued, VaspSubmitted):
            pass
#+END_SRC

**** Strain effects xyz
#+BEGIN_SRC python :results silent
import numpy as np
import os
from jasp import *
from ase.visualize import view
JASPRC['queue.ppn'] = 5
JASPRC['queue.walltime'] = '24:00:00'

# Fraction determined by hand, but could also be calculated from fcc lattice geometry
# basis = [['Cu', 3.634, np.linspace(1.00, 1.08392955421, 4)],]
basis = [['Pd', 3.939, np.linspace(1.00, 1.0/1.08392955421, 4)]]

for M, a, factors in basis:

    for cfg in range(343): # The number of unique 2-layer configurations

        wd0 = 'DFT/surf=fcc/host={0}/lattice={1}/type=layers2/cfg={2}/xy=1.00'.format(M, a, cfg)

        for f in factors:

            # For each configurations, start from relaxed geom and apply isotropic strain
            delta = np.array([[f, 0, 0],
                              [0, f, 0],
                              [0, 0, f]])

            with jasp(wd0) as calc:
                atoms = calc.get_atoms()
                cell = atoms.get_cell()

            atoms.set_cell(np.dot(cell, delta), scale_atoms=True)
            lat = atoms.get_distance(2, 10)

            wd = './DFT/surf=fcc/host={0}/lattice={1:1.3f}/type=layers2/cfg={2}/xy=1.00'.format(M, lat, cfg)

            if not os.path.exists(wd):
                with jasp(wd,
                          xc='PBE',
                          encut=400,
                          kpts=(5, 5, 1),
                          ibrion=-1,
                          atoms=atoms) as calc:
                    try:
                        calc.get_required_memory()
                        calc.calculate()
                    except(VaspSubmitted, VaspQueued):
                        pass
#+END_SRC

*** bulk
#+BEGIN_SRC python
from jasp import *
from ase.io import read
from ase.visualize import view
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 4

images = read('traj/unique-bulk-bcc.db', ':')

lat = abs(2.890 - 3.012)/2. + 2.890
print lat
f =  lat / 2.8843
print f
delta = np.array([[f, 0, 0],
                  [0, f, 0],
                  [0, 0, f]])

for i, atoms in enumerate(images):
    cell0 = atoms.get_cell()
    atoms.set_cell(np.dot(cell0, delta), scale_atoms=True)

    wd = 'DFT/bulk=bcc/lattice={:.3f}/config={}'.format(lat, i)

    # with jasp(wd,
    #           xc='PBE',
    #           encut=400,
    #           kpts=(int(12/3), int(12/3), int(12/3)),
    #           ibrion=-1,
    #           atoms=atoms) as calc:
    #     try:
    #         calc.get_required_memory()
    #         calc.calculate()
    #     except(VaspSubmitted, VaspQueued):
    #         pass
#+END_SRC

#+RESULTS:
: 2.951
: 1.02312519502

** 3 free-layer configurations
#+BEGIN_SRC python
from ase.db import connect
import numpy as np
from ase.visualize import view
import os
from jasp import *
JASPRC['queue.ppn'] = 5
JASPRC['queue.walltime'] = '24:00:00'

db = connect('traj/unique-3layer.db')

for cfg, d in enumerate(db.select()):
    E = abs(d.NN10 / d.natoms - d.NN12 / d.natoms)
    if E > 0.11:
        atoms = db.get_atoms(d.id)
        lat = atoms.get_distance(5, 12)
        M = atoms[0].symbol

        wd = './DFT/surf=fcc/host={0}/lattice={1:1.3f}/type=layers3/cfg={2}/xy=1.00'.format(M, lat, cfg)
        if not os.path.exists(wd):
            with jasp(wd,
                      xc='PBE',
                      encut=400,
                      kpts=(5, 5, 1),
                      ibrion=-1,
                      atoms=atoms) as calc:
                try:
                    calc.get_required_memory()
                    calc.calculate()
                except(VaspSubmitted, VaspQueued):
                    pass
#+END_SRC

** Bulk configurations
*** fcc
Need to start running the worst of these calculations. (i.e. everything above 0.5 eV/atom should be a good number)

#+BEGIN_SRC python
from ase.db import connect
import numpy as np
from amp import Amp
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 4

db = connect('temp/bulk-3x3.db')

dE, ids = [], []
a, cfg = [], []
for d in db.select():
    a += [d.a]
    cfg += [d.config]
    ids += [d.id]
    dE += [abs(d.data['NN8'] / d.natoms - d.data['NN10'] / d.natoms)]

ids = np.array(ids)

# The index of energy differences greater than 0.03
ind = np.array([True if d > 0.03 else False for d in dE])

for i in ids[ind]:
    atoms = db.get_atoms(i)

    wd = 'DFT/bulk=fcc/lattice={0:1.3f}/config={1}'.format(a[i], cfg[i])

    with jasp(wd,
              xc='PBE',
              encut=400,
              kpts=(int(12/3), int(12/3), int(12/3)),
              ibrion=-1,
              atoms=atoms) as calc:
        try:
            calc.get_required_memory()
            calc.calculate()
        except(VaspSubmitted, VaspQueued):
            pass
#+END_SRC

*** bcc
Unique bcc configurations are defined by their volume per atom since this is expected to be approximately equal to that of the fcc structure.

Will begin with the extreme ends and center most lattice volumes.

#+BEGIN_SRC python
from ase.db import connect
import numpy as np
from amp import Amp
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 2
JASPRC['queue.mem'] = '1GB'

db = connect('temp/lat5-bulk-bcc.db')

vols = set()
for d in db.select():
    vols.add(d.aV)
vols = sorted(list(vols))

for d in db.select():
    if d.aV != vols[1] and d.aV != vols[3]:
        atoms = db.get_atoms(d.id)

	wd = 'DFT/bulk=bcc/Vpa={0:1.3f}/config={1}'.format(d.aV, d.cfg)

	with jasp(wd,
		  xc='PBE',
		  encut=400,
		  kpts=(int(12/3), int(12/3), int(12/3)),
		  isif=0,
		  nsw=0,
		  atoms=atoms) as calc:
	    try:
		calc.calculate()
	    except(VaspSubmitted, VaspQueued):
		pass
#+END_SRC

#+RESULTS:

[[./images/pred-mem-efficiency.png]]

#+BEGIN_SRC python
import json
from glob import glob
import matplotlib.pyplot as plt
import numpy as np

mdfiles = glob('DFT/bulk=fcc/lattice=*/config=*/METADATA')

deltas = []
for mdf in mdfiles:
    kvp = mdf.split('/')
    kvp[-1] = 'OUTCAR'
    ouf = '/'.join(kvp)

    with open(mdf) as f:
        data = json.load(f)
        req_mem = float(data['recommended.memory'])

    with open(ouf) as f:
        lines = f.readlines()
        for line in lines:
            if 'memory' in line:
                act_mem = float(line.split()[-2]) / 1e6
                break

    delta = float(req_mem - act_mem)
    deltas += [delta]

deltas = np.array(deltas)

def nbins(x):
    from math import ceil
    n = 1
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)


plt.figure(figsize=(6, 4))
plt.hist(deltas, bins=nbins(max(deltas)), color='r', alpha=0.5)
plt.xlabel('Over estimation of required memory (GB)')
plt.ylabel('Count')
plt.tight_layout()
plt.savefig('./images/pred-mem-efficiency.png')
#+END_SRC

Get calculation times with 4 ppn

[[./images/pred-time-bulk.png]]

#+BEGIN_SRC python
from glob import glob
import matplotlib.pyplot as plt
import numpy as np

files = glob('DFT/bulk=fcc/lattice=*/config=*/OUTCAR')


times = []
for outcar in files:

    with open(outcar) as f:
        lines = f.readlines()
        for line in lines:
            if 'Elapsed time' in line:
                times += [float(line.split()[-1]) / 60. / 60. * 2]
                break

times = np.array(times)

def nbins(x):
    from math import ceil
    n = 0
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
plt.hist(times, bins=nbins(max(times)), color='r', alpha=0.5)
plt.xlabel('Estimated time required for 2 ppn (hrs)')
plt.ylabel('Count')
plt.tight_layout()
plt.savefig('./images/pred-time-bulk.png')
#+END_SRC

[[./images/pred-mem-bulk.png]]

#+BEGIN_SRC python
from glob import glob
import matplotlib.pyplot as plt
import numpy as np

files = glob('DFT/bulk=fcc/lattice=*/config=*/OUTCAR')


mems = []
for outcar in files:

    with open(outcar) as f:
        lines = f.readlines()
        for line in lines:
            if 'memory' in line:
                mems += [float(line.split()[-2]) / 1e6]
                break

mems = np.array(mems)

def nbins(x):
    from math import ceil
    n = 1
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
plt.hist(mems, bins=nbins(max(mems)), color='r', alpha=0.5)
plt.xlabel('Memory required for 4 ppn (GB)')
plt.ylabel('Count')
plt.tight_layout()
plt.savefig('./images/pred-mem-bulk.png')
#+END_SRC

#+RESULTS:

* AMP
Section for AMP related utilities.

** Preparation tools
Generate a database from a set of DFT calculations and creates the necessary training set from it.

#+BEGIN_SRC python :results silent
import jbtools.gilgamesh as jb

# Create the database from the DFT directory
jb.write_database('DFT/bulk=fcc/lattice=3.787', db='networks/db5/data.db')
jb.write_database('DFT/bulk=fcc/lattice=3.863', db='networks/db5/data.db')
#+END_SRC

#+BEGIN_SRC python
import jbtools.neural as jbn

# Produce a trainset with 90% of the database calculations
jbn.produce_trainset('networks/db5/data.db', fraction=0.9)
#+END_SRC

#+RESULTS:

** Running AMP locally
Run AMP on the local machine ONLY. Copy the submit.sh and submit.py files from an existing networks directory to train on node 30 on Gilgamesh.

#+BEGIN_SRC python :results silent
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork

for n in [6, 8]:
    label = "./networks/db4-bulk/"

    calc = Amp(label=label + "40-{0}-{0}-1/".format(n),
               descriptor=Behler(cutoff=6.5),
               regression=NeuralNetwork(hiddenlayers=(2, n)))

    calc.train(label + "train.db",
               cores=3,
               energy_goal=0.0005,
               extend_variables=False)
#+END_SRC

** Status of network
#+BEGIN_SRC python :results raw
import os
import json

print('|Hidden layers|Iteration|Time|Cost Function|Energy RMSE|Force RMSE|')
print('|-')

for r, d, f in os.walk('networks/db4-bulk/'):
    if 'train-log.txt' in f:
        with open(os.path.join(r, 'train-log.txt'), 'r') as fi:
            v = fi.readlines()[-5].split()

    if 'trained-parameters.json' in f:
        with open(os.path.join(r, 'trained-parameters.json'), 'r') as fi:
            p = json.load(fi)
        n = p['hiddenlayers']
        print('|{0}|{1}|{2}|{3}|{4}|{5}|'.format(n, v[0], v[1], v[2], v[3], v[4]))
#+END_SRC

#+RESULTS:
| Hidden layers                  | Iteration | Time                | Cost Function | Energy RMSE | Force RMSE |
|--------------------------------+-----------+---------------------+---------------+-------------+------------|
| {u'Cu': [2, 8], u'Pd': [2, 8]} |      5146 | 2016-01-25T00:09:08 |     4.787e+00 |   2.539e-03 |  4.025e-01 |
| {u'Cu': [2, 6], u'Pd': [2, 6]} |      6159 | 2016-01-25T07:23:57 |     4.819e+00 |   2.169e-03 |  4.040e-01 |

** Adding AMP energies to database
This code is used to add the energy predictions from various NN to a particular database.

*** db3 unique configurations
#+BEGIN_SRC python :results silent
from ase.db import connect
from ase.io import read
from amp import Amp

images = read('traj/unique-config.db')

with connect('temp/db3-config.db') as db:
 
    for atoms in images:

        data = {}
        for d, l in [[2, 10], [2, 12],
                     [3, 6], [3, 7], [3, 8]]:

            key = 'db{0}-{1}'.format(d, l)
            calc = Amp('networks/db{0}/40-{1}-{1}-1/'.format(d, l))
            atoms.set_calculator(calc)
            data[key] = atoms.get_potential_energy()

        atoms.set_calculator(None)

        db.write(atoms, data=data)
#+END_SRC

*** 5 free-layers -- 2 \times 2 slab
#+BEGIN_SRC python :results silent
from ase.db import connect
from ase.io import read
from amp import Amp

images = read('traj/cfg2x2-5layer.db')

with connect('temp/cfg2x2-5layer-db3.db') as db:
    data = {}
    for atoms in images:
        for l in [6, 7]:

            key = 'db3-{0}'.format(l)
            calc = Amp('networks/db3/40-{0}-{0}-1/'.format(l))
            atoms.set_calculator(calc)
            data[key] = atoms.get_potential_energy()

        atoms.set_calculator(None)
        db.write(atoms, data=data)
#+END_SRC

*** Bulk -- 3 \times 3 \times 3 -- 10 lattice
Here we generate a temporary database of the energy unique EMT configurations and expand it to 10 different lattice constants. Also, predictions from db4 NNs are added for comparison.

#+BEGIN_SRC python :results silent
import numpy as np
from ase.db import connect
from ase.io import read
from amp import Amp
from ase import Atoms
# Pull unique bulk structures predicted from EMT
images = read('traj/unique-bulk.db')

# Create a new temporary database
with connect('temp/db5-3x3-bulk.db') as db:

    # Generate structures at 5 different lattice constants
    for lat in np.linspace(3.634, 3.939, 10):


        f = lat / 3.939

        delta = np.array([[f, 0, 0],
                          [0, f, 0],
                          [0, 0, f]])

        for i, atoms0 in enumerate(images):
            atoms = Atoms.copy(atoms0)
            cell0 = atoms.get_cell()
            atoms.set_cell(np.dot(cell0, delta), scale_atoms=True)

            keys = {'a': lat, 'config':i}

            data = {}
            for l in [6, 7]:
                key = 'NN{0}'.format(l)
                calc = Amp('networks/db5/40-{0}-{0}-1/'.format(l))
                atoms.set_calculator(calc)
                data[key] = atoms.get_potential_energy()

            atoms.set_calculator(None)

            db.write(atoms, key_value_pairs=keys, data=data)
#+END_SRC

#+RESULTS: 
: 1b8c51d7-cbed-4635-895e-b927acc9ead0

* EMT & other
** Unique structure calculator
*** 1 free-layer -- root(7) \times root(7)
This code uses ASAPs EMT calculator to calculate the energy of /all/ permutations given to it. It will then add the energy unique permutations to a trajectory file for later reference.

#+BEGIN_SRC python :results silent
from itertools import product
from ase.lattice.surface import fcc111_root
from asap3 import EMT
from ase import Atoms
from ase.db import connect
from amp.utilities import hash_image

base = fcc111_root('Cu', 7, size=(1, 1, 5), vacuum=6.0, a=3.634)
natoms = [a.index for a in base if a.tag <= 1]
metals = ['Cu', 'Pd']

with connect('traj/unique-1layer.db') as db:
    nrgs = set()
    for i, c in enumerate(product(metals, repeat=len(natoms))):
        atoms0 = Atoms.copy(base)
        for j, s in enumerate(natoms):
            atoms0[s].symbol = c[j]

        atoms = Atoms.copy(atoms0)
        atoms.set_calculator(EMT())
        nrg = round(atoms.get_potential_energy(), 3)
        atoms.set_calculator(None)

        if nrg not in nrgs:
            nrgs.add(nrg)
            db.write(atoms)
#+END_SRC

*** 5 free-layers -- 2 \times 2
#+BEGIN_SRC python
from ase.lattice.cubic import FaceCenteredCubic as fcc
from ase.lattice.surface import surface
import numpy as np
from ase.atoms import Atoms
import random
from ase.units import kB
from ase.db import connect
from ase.constraints import FixAtoms
from ase.visualize import view

atoms = fcc('Cu', latticeconstant=3.7865)

# Turn 50% of the atoms into Pd
for j in range(1, 3):
    atoms[j].symbol = 'Pd'

atoms = surface(atoms, (1, 1, 1), 5)
atoms.center(vacuum=6., axis=2)

constraint = FixAtoms(mask=[atom.position[2] < 8.5 for atom in atoms])
atoms.set_constraint(constraint)

view(atoms)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from itertools import product
from ase.lattice.surface import fcc111
from asap3 import EMT
from ase import Atoms
from ase.db import connect

base = fcc111('Cu', size=(2, 2, 5), vacuum=6.0, a=3.7865)
natoms = [a.index for a in base if a.index > 7]
metals = ['Cu', 'Pd']

for i in [1, 2, 5, 6]:
    base[i].symbol = 'Pd'

with connect('traj/cfg2x2-5layer-2fix.db') as db:
    nrgs = set()
    for i, c in enumerate(product(metals, repeat=len(natoms))):
        atoms0 = Atoms.copy(base)
        for j, s in enumerate(natoms):
            atoms0[s].symbol = c[j]

        atoms = Atoms.copy(atoms0)
        atoms.set_calculator(EMT())
        nrg = round(atoms.get_potential_energy(), 3)
        atoms.set_calculator(None)

        if nrg not in nrgs:
            nrgs.add(nrg)
            db.write(atoms)
#+END_SRC

#+RESULTS:

*** Bulk configurations

**** fcc
#+BEGIN_SRC python :results silent
from ase.lattice.cubic import FaceCenteredCubic
from itertools import product
from asap3 import EMT
from ase import Atoms
from ase.db import connect
import numpy as np

base = FaceCenteredCubic('Cu',
                         directions=[[0, 1, 1],
                                     [1, 0, 1],
                                     [1, 1, 0]],
                         size=(3, 3, 3),
                         latticeconstant=3.939)

natoms = [a.index for a in base]
metals = ['Cu', 'Pd']

with connect('traj/unique-bulk.db') as db:
    nrgs = set()
    for i, c in enumerate(product(metals, repeat=len(natoms))):

        atoms0 = Atoms.copy(base)
        for j, s in enumerate(natoms):
            atoms0[s].symbol = c[j]

        atoms = Atoms.copy(atoms0)
        atoms.set_calculator(EMT())
        nrg = round(atoms.get_potential_energy(), 3)

        atoms.set_calculator(None)

        if nrg not in nrgs:
            nrgs.add(nrg)
            db.write(atoms)
#+END_SRC

**** bcc
#+BEGIN_SRC python
from ase.lattice.cubic import BodyCenteredCubic
from ase.lattice.cubic import FaceCenteredCubic
from itertools import product
from asap3 import EMT
from ase import Atoms
from ase.db import connect
import numpy as np

fcc = FaceCenteredCubic('Cu',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant=3.7865)
VOL = fcc.get_volume() / len(fcc)

base = BodyCenteredCubic('Cu',
                         directions=[[1, 1, 1],
                                     [-1, 1, 1],
                                     [-1, -1, 1]],
                        size=(3, 3, 3),
                        latticeconstant=1.0)

v0 = base.get_volume()
cell0 = base.get_cell()

f = (VOL*len(base) / v0)**(1. / 3.)
base.set_cell(f*cell0, scale_atoms=True)

natoms = [a.index for a in base]
metals = ['Cu', 'Pd']

with connect('traj/unique-bulk-bcc-2.db') as db:
    nrgs = set()
    for i, c in enumerate(product(metals, repeat=len(natoms))):

        atoms0 = Atoms.copy(base)
        for j, s in enumerate(natoms):
            atoms0[s].symbol = c[j]

        atoms = Atoms.copy(atoms0)
        from ase.visualize import view
        atoms.set_calculator(EMT())
        nrg = round(atoms.get_potential_energy(), 3)

        atoms.set_calculator(None)

        if nrg not in nrgs:
            nrgs.add(nrg)
            db.write(atoms)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.visualize import view
from ase.io import read
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
from ase.db import connect

images = read('traj/unique-bulk-bcc.db')

# collect the volume/atom from fcc calculations
lat = np.linspace(3.634, 3.939, 5)
volumes = []
for a in lat:
    fcc = FaceCenteredCubic('Cu',
			    directions=[[0, 1, 1],
					[1, 0, 1],
					[1, 1, 0]],
			    latticeconstant=a)
    VOL = fcc.get_volume() / len(fcc)

    volumes += [VOL]

with connect('temp/all-lat-bulk-bcc.db') as db:
    for v in volumes:
	for atoms in images:
            v0 = atoms.get_volume() / len(atoms)
            cell0 = atoms.get_cell()

            f = (v / v0)**(1. / 3.)
            atoms.set_cell(f*cell0, scale_atoms=True)

            db.write(atoms)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect
from asap3 import EMT

db = connect('temp/all-lat-bulk-bcc.db')

vols = set()
for d in db.select():
    vols.add(d.volume / 27.)

vols = sorted(list(vols))

nrgs = set()
images = []

for d in db.select():
    if d.volume / 27. == vols[4]:

	atoms = db.get_atoms(d.id)
	atoms.set_calculator(EMT())
	nrg = round(atoms.get_potential_energy(), 3)
	atoms.set_calculator(None)

	if nrg not in nrgs:
	    nrgs.add(nrg)
            images += [atoms]

with connect('temp/lat5-bulk-bcc.db') as db:
    for v in vols:
	for i, atoms in enumerate(images):
            v0 = atoms.get_volume() / len(atoms)
            cell0 = atoms.get_cell()

            f = (v / v0)**(1. / 3.)
            atoms.set_cell(f*cell0, scale_atoms=True)

            db.write(atoms, key_value_pairs={'aV': float(v), 'cfg': int(i)})
#+END_SRC

#+RESULTS:

** Producing files for predictions
*** Opposite base composition
Each of the unique configurations produced above will also have an Cu based equivalent. We generate those here:

#+BEGIN_SRC python :results silent
from ase.db import connect
from ase.io import read
import numpy as np
from ase.visualize import view

images = read('traj/unique-4layer.db')

with connect('traj/unique-4layer.db') as db:
    for atoms in images:
        symbols = []
        for atom in atoms:
            if atom.symbol == 'Pd':
                symbols += ['Cu']
            else:
                symbols += ['Pd']
        atoms.set_chemical_symbols(symbols)

        db.write(atoms)
#+END_SRC

*** Lattice constant perturbations
#+BEGIN_SRC python :results silent
from ase.db import connect
from ase.io import read
import numpy as np
from amp.utilities import hash_image
from amp import Amp
import os

images = read('traj/unique-4layer.db')
factors = np.linspace(3.634, 3.939, 5)

rp = connect('temp/rep-4layer.db')

hashs = set()
with connect('temp/pred-4layer.db') as db:

    for d in db.select():
        hashs.add(d.hash)

    for x in factors:
        for atoms in images:
            cell = atoms.get_cell()
            f = x / np.linalg.norm(cell[0] / np.sqrt(7) / (0.5**0.5))

            delta = np.array([[f, 0, 0],
                              [0, f, 0],
                              [0, 0, f]])

            atoms.set_cell(np.dot(cell, delta),
                           scale_atoms=True)

            H = hash_image(atoms)
            if H not in hashs:
                hashs.add(H)

                calc = Amp('networks/db2/40-10-10-1/')
                atoms.set_calculator(calc)
                nrg10 = atoms.get_potential_energy()

                calc = Amp('networks/db2/40-12-12-1/')
                atoms.set_calculator(calc)
                nrg12 = atoms.get_potential_energy()
                atoms.set_calculator(None)

                db.write(atoms, hash=H,
                         data={'NN10': nrg10,
                               'NN12': nrg12})
            else:
                rp.write(atoms, hash=H)
#+END_SRC

* Analysis
** Database db0-bct
This database includes the DFT calculations mapping the pathway around the fcc to bcc transition. Other comparisons are also present. The pathway is compared to neural networks of multiple different frameworks.

*** BCT phase transition pathway
Figure ref:fig-db0-bct_fcc-to-bcc shows the energy barrier from fcc to bcc traveling through bct phase space.

#+caption: Neural network comparison to energy pathway of fcc to bcc transition through bct space. Shown for db0-bct networks.
#+label: fig-db0-bct_fcc-to-bcc
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/multinn-path1.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob

db = connect('data-pathway.db')

ca, nrg, img = [], [], []
for d in db.select('gga=PS'):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    ca.append(d.ca)
    nrg.append(d.total_energy / len(atoms))

plt.figure()
plt.plot(ca, nrg, 'k-', lw=4)
plt.annotate('bcc', xy=(ca[0], nrg[0]),
             xytext=(1.03, -5.248),
             arrowprops=dict(arrowstyle="->",
                             connectionstyle="arc3"),
             size=20,
            )
plt.annotate('fcc', xy=(ca[-1], nrg[-1]),
             xytext=(1.36, -5.225),
             arrowprops=dict(arrowstyle="->",
                             connectionstyle="arc3"),
             size=20,
            )

form = ['#FF0000', '#FF6600', '#FFFF33',
        '#006600', '#00FF00', '#00FFFF',
        '#0000FF', '#9933FF', '#FF0099']

for i, name in enumerate(glob('./networks/db0-bct/*trained-parameters.json')):
    n = name.split('/')[-1].split('-')[0]
    calc = BPNeural(json='{0}'.format(name))

    fit = []
    for atoms in img:
        atoms.set_calculator(calc)
        fit.append(atoms.get_potential_energy() / len(atoms))

    plt.plot(ca, fit, 'o-',
             label='{0}'.format(n),
             color=form[i])
plt.xlabel('c/a ratio')
plt.ylabel('Total energy (eV/atom)')
plt.xlim(ca[0], ca[-1])
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/multinn-path1.png')
#+END_SRC

*** All bulk structures
Figure ref:fig-db0-bct_all-bulk shows the residuals of various NN predictions for all bulk structures in db1. This includes the reaction pathway (section of low error on the end) along with various EOS generated from each of the ATAT predicted alloy structures.

#+caption: Energy differences between DFT and various NN predictions for all bulk structures in db1. Performed for networks generated from db0-bct data.
#+label: fig-db0-bct_all-bulk
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/multinn-differences.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob
import os

db = connect('networks/db1-cln/data.db')

nrg, img, ids = [], [], []
for d in db.select(['gga=PS', 'bulk=bct']):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    nrg.append(d.total_energy / len(atoms))
    ids.append(d.id)

form = ['#FF0000', '#FF6600', '#FFFF33',
        '#006600', '#00FF00', '#00FFFF',
        '#0000FF', '#9933FF', '#FF0099']

plt.figure()
plt.plot([ids[0], ids[-1]], [0, 0], 'k--', lw=2)

err = {}
for i, name in enumerate(glob('./networks/db0-bct/*trained-parameters.json')):
    n = name.split('/')[-1].split('-')[0]
    calc = BPNeural(json='{0}'.format(name))
    err[n] = []

    dif = []
    for j, atoms in enumerate(img):
        atoms.set_calculator(calc)
        e = atoms.get_potential_energy() / len(atoms)
        difference = e - nrg[j]
        if difference >= 0.1:
            err[n].append(ids[j])
        dif.append(difference)

    plt.plot(ids, dif, 'o',
             label='{0}'.format(n),
             color=form[i])
plt.xlabel('IDs')
plt.ylabel('Energy difference (eV/atom)')
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/multinn-bct.png')
#+END_SRC

** Database db1-train
*** BCT phase transition pathway
#+caption: Neural network comparison to energy pathway of fcc to bcc transition through bct space. Shown for db1-train networks.
#+label: fig-db1-train_fcc-to-bcc
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/rxn-path-db1.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob

db = connect('data-pathway.db')

ca, nrg, img = [], [], []
for d in db.select('gga=PS'):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    ca.append(d.ca)
    nrg.append(d.total_energy / len(atoms))

plt.figure()
plt.plot(ca, nrg, 'k-', lw=4)

form = ['#FF0000', '#FFFF33',
        '#006600', '#00FFFF',
        '#0000FF', '#FF0099']

for i, name in enumerate(glob('./networks/db1-50Cu/*/parameters-checkpoint.json')):

    n = name.split('/')[-2]
    calc = BPNeural(json='{0}'.format(name))

    fit = []
    for atoms in img:
        atoms.set_calculator(calc)
        fit.append(atoms.get_potential_energy() / len(atoms))

    plt.plot(ca, fit, 'o-',
             label='{0}'.format(n),
             color=form[i])

plt.xlabel('c/a ratio')
plt.ylabel('Total energy (eV/atom)')
plt.xlim(ca[0], ca[-1])
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/rxn-path-db1.png')
#+END_SRC

*** All bulk structures
#+caption: Energy differences between DFT and various NN predictions for all bulk structures in db1. Performed for networks generated from db1-train data.
#+label: fig-db1-train_all-bulk
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/all-db1.png]]

#+BEGIN_SRC python :results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from ase.io import write
from glob import glob
import os

db = connect('networks/db1-cln/data.db')

nrg, img, ids = [], [], []
for d in db.select(['gga=PS']):
    atoms = db.get_atoms(d.id)
    img.append(atoms)
    nrg.append(d.total_energy / len(atoms))
    ids.append(d.id)

form = ['#FF0000', '#FFFF33',
        '#006600', '#00FFFF',
        '#0000FF', '#FF0099']

plt.figure()
plt.plot([ids[0], ids[-1]], [0, 0], 'k--', lw=2)

err = {}
for i, name in enumerate(glob('./networks/db1-50Cu/*/parameters-checkpoint.json')):
    n = name.split('/')[-2]
    calc = BPNeural(json='{0}'.format(name))
    err[n] = []

    dif = []
    for j, atoms in enumerate(img):
        atoms.set_calculator(calc)
        e = atoms.get_potential_energy() / len(atoms)
        difference = e - nrg[j]
        if difference >= 0.1:
            err[n].append(ids[j])
        dif.append(difference)

    plt.plot(ids, dif, 'o',
             label='{0}'.format(n),
             color=form[i])
plt.xlabel('IDs')
plt.ylabel('Energy difference (eV/atom)')
plt.legend(loc='best')
plt.tight_layout()
plt.savefig('./images/all-db1.png')
#+END_SRC

*** EOS reproduction
In this section, we reproduce EOS using various NN frameworks of the db1-train database. Figure ref:fig-db1-train_EOS-19 shows an example of an EOS which failed to be fit correctly by all frameworks.

#+caption: Example of reproduced EOS from ATAT structure 19 of the bcc configuration. This structure was not accurately fit to.
#+label: fig-db1-train_EOS-19
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/EOS-19-bcc.png]]

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from glob import glob

db = connect('networks/db1-50Cu/data.db')

cfgs = []
for d in db.select():
    if d.config not in cfgs:
        cfgs.append(d.config)

db = connect('networks/db1-cln/data.db')

bulk = ['fcc', 'bcc']

for cfg in cfgs:
    for b in bulk:
        nrg, img, ids = [], [], []
        try:
            for d in db.select(['config={0}'.format(cfg), 'bulk={0}'.format(b)]):
                atoms = db.get_atoms(d.id)
                img.append(atoms)
                nrg.append(d.total_energy / len(atoms))
                ids.append(d.volume / len(atoms))

            form = ['#FF0000', '#FFFF33',
                    '#006600', '#00FFFF',
                    '#0000FF', '#FF0099']

            f, ax = plt.subplots(2, sharex=True)
            ax[1].plot([ids[0], ids[-1]], [0, 0], 'k--', lw=2)
            ax[0].plot(ids, nrg, 'o', label='DFT', color='k', mfc='none', ms=6)

            err = {}
            for i, name in enumerate(glob('./networks/db1-50Cu/*/parameters-checkpoint.json')):
                n = name.split('/')[-2]
                calc = BPNeural(json='{0}'.format(name))
                err[n] = []

                dif, E = [], []
                for j, atoms in enumerate(img):
                    atoms.set_calculator(calc)
                    e = atoms.get_potential_energy() / len(atoms)
                    E.append(e)
                    difference = e - nrg[j]
                    if difference >= 0.1:
                        err[n].append(ids[j])
                    dif.append(difference)

                ax[0].plot(ids, E, '.',
                           label='{0}'.format(n),
                           color=form[i], alpha=0.5)
                ax[1].plot(ids, dif, '.',
                           label='{0}'.format(n),
                           color=form[i], alpha=0.5)
            ax[1].set_xlabel('Volume ($\AA$/atom)')
            ax[0].set_ylabel('Potential energy (eV/atom)')
            ax[1].set_ylabel('Energy difference (eV/atom)')
            ax[0].legend(loc='best', fontsize=8)
            plt.tight_layout()
            plt.savefig('./images/EOS-{0}-{1}.png'.format(cfg, b))
        except:
            pass
#+END_SRC

** Database db2-surf
*** Residuals
#+caption: Residual errors for the db2-surf training set.
#+label: fig-db2-surf_residual
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db2-surf.png]]

#+BEGIN_SRC python :results silent
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
from ase.db import connect
from neural.bp import BPNeural
import numpy as np
from glob import glob
from scipy.stats import norm
from matplotlib import gridspec

db = connect('networks/db2-surf/data.db')

img, nrg, ids = [], [], []
for d in db.select():
    img.append(db.get_atoms(d.id))
    nrg.append(d.total_energy / len(d.symbols))
    ids.append(d.id)

calc = BPNeural(json='networks/db2-surf/l3n30i0/parameters-checkpoint.json')

fit = []
for atoms in img:
    atoms.set_calculator(calc)
    fit.append(atoms.get_potential_energy() / len(atoms))
dif = np.array(fit) - np.array(nrg)

RMSE = np.sqrt(sum(dif ** 2) / len(dif))

(mu, sigma) = norm.fit(dif)

fig = plt.figure(figsize=(8, 6)) 
gs = gridspec.GridSpec(1, 2, width_ratios=[2, 1])
ax0 = plt.subplot(gs[0])
ax0.scatter(ids, dif, marker='o', color='k', alpha=0.5)
ax0.plot([0, len(dif)-1], [0, 0], 'r--', lw=2)
ax0.text(len(dif)*0.05, max(abs(dif)), 'RMSE: {0:1.3f}'.format(RMSE), fontsize=15, va='top', ha='left')
ax0.set_xlim(0, len(dif)-1)
ax0.set_ylim(-max(abs(dif))-0.1*max(abs(dif)), max(abs(dif))+0.1*max(abs(dif)))
ax0.set_xlabel('Calculation ID')
ax0.set_ylabel('Energy residual error (eV/atom)')

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(dif, 20,
                            range=(-max(abs(dif))-0.1*max(abs(dif)),
                                   max(abs(dif))+0.1*max(abs(dif))),
                            normed=True,
                            facecolor='k',
                            alpha=0.5,
                            orientation='horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(1, max(abs(dif)), '$\mu$: {0:1.3f}'.format(mu), fontsize=15, va='top', ha='left')
ax1.text(1, max(abs(dif))*0.9, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=15, va='top', ha='left')
ax1.plot(y, bins, 'k--', lw=2)
ax1.plot([0, 35], [0, 0], 'r--', lw=2)
ax1.set_xlabel('Probability density')
ax1.set_ylim(-max(abs(dif))-0.1*max(abs(dif)), max(abs(dif))+0.1*max(abs(dif)))
ax1.set_xlim(0, 35)
ax1.set_yticklabels(())

plt.subplots_adjust(left=0.11,
                    bottom=0.09,
                    right=0.97,
                    top=0.97,
                    wspace=0.02,
                    hspace=0.2)

plt.savefig('./images/db2-surf.png')
#+END_SRC

** Database db2
*** Lattice paramteres
In this section, we analyze the difference between energies predicted for various structures between two different neural network frameworks. Each figure demonstrates this effect for a different set of structures. Each set of structures is based on a root(7) \times root(7) fcc(111) surface lattice which is 5 layers deep. The only differences between these structures is the identity of the atoms filling the lattice positions, and also the lattice constant of the unit cell. Five evenly spaced lattice constants were chosen ranging from the lattice constant of bulk fcc Cu (3.634 \AA) to bulk Pd (3.939 \AA). This lattice grids are demonstrated in Figure ref:structure-types.

#+caption: Demonstration of the lattice structures utilized in the following section. The darker the atom, the deeper the layer. Only the 
#+label: structure-types
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 800
[[./images/structure-types.png]]    

#+BEGIN_SRC python :results silent
from ase.visualize import view
from ase.lattice.surface import fcc111_root
from ase.io import write
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
import matplotlib.image as mpimg
import os

lat = np.linspace(3.634, 3.939, 5)

p = np.linspace(0.05, 0.9, 5)

fig = plt.figure(figsize=(8, 3))
ax = fig.add_subplot(111)
for i, a in enumerate(lat):
    atoms = fcc111_root('Cu', root=7,
                        size=(1, 1, 5),
                        vacuum=6.0, a=a)

    col = abs((atoms.get_tags() / 5.0) - 1.0)

    kwargs = {
        'rotation': "-75x",
        'show_unit_cell': 2,
        'colors': np.array([col, col, col]).T,
        'radii': [0.3] * len(atoms)}

    write('images/temp.png', atoms, **kwargs)

    image = mpimg.imread('./images/temp.png')
    imagebox = OffsetImage(image, zoom=0.5)

    ax.add_artist(AnnotationBbox(imagebox,
                                 xy=(0, 0),
                                 xybox=(p[i], 0.5),
                                 pad=-0.2,
                                 frameon=False,
                                 arrowprops=None)
                 )
    ax.text(p[i], -0.13, '{0:1.3f} $\AA$'.format(a),
            va='center', ha='center')
    os.unlink('./images/temp.png')

fig.patch.set_visible(False)
ax.axis('off')
plt.tight_layout()
plt.savefig('images/structure-types.png')
#+END_SRC

*** Slab configurations
For a particular lattice (3.939 \AA), all combinations of Cu and Pd atoms were created for certain numbers of layers starting from the top. This was done for: 1, 2, and 3 layers. In Figure ref:composition-types, one possible configuration for a system where only the top most layer of atoms were allowed to be either Cu or Pd. Once all such configurations were enumerated on a Pd substrate (such a substrate is demonstrated on the right of Figure ref:composition-types), each structures energy was calculated using ASAP (https://wiki.fysik.dtu.dk/asap). Finally, only structures who ASAP energies are unique are kept.

#+caption: Demonstration of the lattice structures utilized in the following section. The darker the atom, the deeper the layer.
#+label: composition-types
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/composition-types.png]]

#+BEGIN_SRC python :results silent
from ase.visualize import view
from ase.lattice.surface import fcc111_root
from ase.io import write
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
import matplotlib.image as mpimg
import os

p = np.linspace(0.2, 0.8, 2)

fig = plt.figure(figsize=(4, 3))
ax = fig.add_subplot(111)
for i, M in enumerate(['Cu', 'Pd']):
    atoms = fcc111_root(M, root=7,
                        size=(1, 1, 5),
                        vacuum=6.0,
                        a=3.787)

    C = [200/255., 129/255., 51/255.] 
    B = [0/255., 105/255., 134/255.]

    if i == 0:
        col = [C] * 31 + [B] * 4
    else:
        col = [B] * 31 + [C] * 4

    kwargs = {
        'rotation': "-75x",
        'show_unit_cell': 2,
        'colors': col,
        'radii': None}

    write('images/temp.png', atoms, **kwargs)

    image = mpimg.imread('./images/temp.png')
    imagebox = OffsetImage(image, zoom=0.6)

    ax.add_artist(AnnotationBbox(imagebox,
                                 xy=(0, 0),
                                 xybox=(p[i], 0.5),
                                 pad=-0.2,
                                 frameon=False,
                                 arrowprops=None))
    os.unlink('./images/temp.png')

fig.patch.set_visible(False)
ax.axis('off')
plt.tight_layout()
plt.savefig('images/composition-types.png')
#+END_SRC

*** NN framework differences
For a single layer of configurations then, there are $2^{7}$ (128) possible configurations of atoms of the top most layer. Only 8 of these configurations are predicted to be energy unique by ASAP. Each of those configurations is energy unique for a Pd substrate, so we end up with twice as many unique configurations if we consider a Cu substrate as well. The result is 8 \times 2 (16) energy unique configurations on Cu and Pd substrate, and 16 \times 5 (80) total configurations with lattice constant ranging from 3.634 - 3.939 \AA.

From the two neural network trained, the difference between the energies predicted by the two systems can then be taken and used to determine the dependability of the fit for a wide range of different configurations.

#+caption: NN predicted energy differences for unique energy configurations of a root(7) \times root(7) slab. 1 layer is allowed to change its chemical composition.
#+label: fig-1layer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db0-1layer.png]]

#+caption: NN predicted energy differences for unique energy configurations of a root(7) \times root(7) slab. 2 layers are allowed to change their chemical composition.
#+label: fig-2layer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db0-2layer.png]]

#+caption: NN predicted energy differences for unique energy configurations of a root(7) \times root(7) slab. 3 layers are allowed to change their chemical composition.
#+label: fig-3layer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db0-3layer.png]]

#+caption: NN predicted energy differences for unique energy configurations of a root(7) \times root(7) slab. 4 layers are allowed to change their chemical composition.
#+label: fig-4layer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db0-4layer.png]]

To determine which structures AMP considers to be unique, we use the hashing method it utilizes to assign a simple hash to each atoms object. If we combine all of the unique hashes from the unique configurations shown above, Figure ref:fig-alayer-db0 is produced. We observe that the ASAP-EMT calculator eliminates a large number of unique configurations when the data set becomes quite large. Regardless, we observe that the results are well predicted in most cases.

#+caption: NN predicted energy differences for all unique energy configurations shown above which have a unique hash.
#+label: fig-alayer-db0
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db1-alayer.png]]

#+BEGIN_SRC python :results silent
from ase.db import connect
from amp import Amp
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/pred-config.db')

E = []
for d in db.select():
    E += [abs(d.data.NN10 / d.natoms - d.data.NN12 / d.natoms)]
E = np.array(E)

def nbins(x):
    from math import log10, floor, ceil
    p = -int(floor(log10(x)) - 2)
    w = ceil(x*10**p) / ceil(x*10**p)*10**-p
    m = ceil(x*10**p)
    return np.arange(0, m*w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.xlim(0, nbins(max(E)).max())
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/db0-alayer.png')
#+END_SRC

** Database db3
*** Residuals of db2 configurations
#+caption: Predicted energy differences between db3 frameworks for all unique energy configurations.
#+label: fig-alayer-db3
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db3-alayer.png]]

#+BEGIN_SRC python ;results silent
from ase.db import connect
from amp import Amp
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/db3-config.db')

E = []
for d in db.select():
    E += [abs(d.data['db3-6'] / d.natoms - d.data['db3-7'] / d.natoms)]
E = np.array(E)

def nbins(x):
    from math import log10, floor, ceil
    w = ceil(x*10**3) / ceil(x*10**3)*10**-3
    m = ceil(x*10**3)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.xlim(0, 0.111)
plt.ylim(0, 15000)
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/db3-alayer.png')
#+END_SRC

*** 5 free-layer -- 2 \times 2 slab
In Figure ref:fig-db3-2x2-5layer we demonstrate that every unique configuration predicted by ASAP-EMT is for a 2\times2 fcc(111) slab is well predicted by the db3 NNs as well. This demonstrates that we can accurately reproduce the energies of any simpler configuration of atoms. Interestingly, this also demonstrates the NNs ability to extrapolate to configurations which differ in the 5th layer as well, at least for small, relatively simple configurations.

#+caption: db3 NN predicted differences in energy for all 2 \times 2 unique energy configurations of a 5 layer fcc(111) slab.
#+label: fig-db3-2x2-5layer
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/cfg2x2-5layer-db3.png]]

#+BEGIN_SRC python ;results silent
from ase.db import connect
from amp import Amp
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/cfg2x2-5layer-db3.db')

E = []
for d in db.select():
    E += [abs(d.data['db3-6'] / d.natoms - d.data['db3-7'] / d.natoms)]
E = np.array(E)

def nbins(x):
    from math import log10, floor, ceil
    w = ceil(x*10**3) / ceil(x*10**3)*10**-3
    m = ceil(x*10**3)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/cfg2x2-5layer-db3.png')
#+END_SRC

** Database db4
This database includes all calculations from db3, plus additional calculations of bulk structures of a 3 \times 3 \times 3 primitive fcc unit cell. Only the bulk configurations predicted to be energy unique by EMT are included and only at lattice constants of 3.634 and 3.939 \AA.

*** Bulk configurations in db4
#+caption: Energy differences between db4 NN frameworks for energy unique bulk configurations at 10 lattice constants.
#+label: fig-db4_bulk_10lat
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db4_bulk.png]]

#+BEGIN_SRC python :results silent
from ase.io import read
from amp import Amp
import numpy as np
import matplotlib.pyplot as plt

images = read('networks/db4-bulk/data.db')

dE = []
for atoms in images:
    calc = Amp('networks/db4/40-8-8-1/')
    atoms.set_calculator(calc)
    E8 = atoms.get_potential_energy()

    calc = Amp('networks/db4/40-10-10-1/')
    atoms.set_calculator(calc)
    E10 = atoms.get_potential_energy()

    dE += [abs(E8 / len(atoms) - E10 / len(atoms))]
dE = np.array(dE)

def nbins(x):
    from math import log10, floor, ceil
    n = 4
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(dE, bins=nbins(max(dE)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(dE)))
plt.tight_layout()
plt.savefig('./images/db4_bulk.png')
#+END_SRC

*** Bulk configurations at 5 lattice constants
#+caption: Energy differences between db4 NN frameworks for energy unique bulk configurations at 10 lattice constants.
#+label: fig-db4_bulk_10lat
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db4_bulk_10lat.png]]

#+BEGIN_SRC python
from ase.db import connect
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/bulk-3x3.db')

E = []
for d in db.select():
    E += [abs(d.data['NN8'] / d.natoms - d.data['NN10'] / d.natoms)]
E = np.array(E)

def nbins(x):
    from math import log10, floor, ceil
    n = 2
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
print n
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/db4_bulk_10lat.png')
#+END_SRC

#+RESULTS:
: [ 4931.  1037.   556.   124.   124.   248.   628.   526.     6.]

** Database db5
Calculations for the next iteration of the bulk-only database.

*** Review of trained networks
#+BEGIN_SRC python
import os
from glob import glob
import shutil
import numpy as np

files = glob('networks/db5/40-*-*-1/train-log.txt')

for fil in files:
    fit = fil.split('/')[-2]

    with open(fil, 'r') as f:
        lines = f.readlines()

    print(fit, lines[-5])
#+END_SRC

#+RESULTS:
: ('40-7-7-1', '19839        2016-03-14T19:51:57  1.219e-02    7.086e-04\n')
: ('40-6-6-1', ' 9215        2016-03-13T18:36:16  1.321e-02    7.376e-04\n')

*** Fits to database data
[[./images/db5_bulk.png]]

#+BEGIN_SRC python :results silent
from ase.io import read
from amp import Amp
from ase.db import connect

db0 = connect('networks/db5-bulk/data.db')

with connect('temp/db5-bulk.db') as db:
    for d in db0.select():

        atoms = db0.get_atoms(d.id)

        calc = Amp('networks/db5/40-6-6-1/')
        atoms.set_calculator(calc)
        E6 = atoms.get_potential_energy()

        calc = Amp('networks/db5/40-7-7-1/')
        atoms.set_calculator(calc)
        E7 = atoms.get_potential_energy()

        atoms.set_calculator(None)
        db.write(atoms, key_value_pairs={'NN6': E6, 'NN7': E7})
#+END_SRC

#+BEGIN_SRC python :results silent
from ase.io import read
from amp import Amp
from ase.db import connect
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/db5-bulk.db')

dE = []
for d in db.select():
    dE += [(d.NN6 - d.NN7) / len(d.symbols)]
dE = np.array(dE)

def nbins(x):
    from math import log10, floor, ceil
    n = 4
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(dE, bins=nbins(max(dE)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(dE)))
plt.tight_layout()
plt.savefig('./images/db5_bulk.png')
#+END_SRC

*** for multi-lattice constants
#+caption: Energy differences between db5 NN frameworks for energy unique bulk configurations at 5 lattice constants.
#+label: fig-db5_bulk_5lat
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db5_bulk_5lat.png]]


#+BEGIN_SRC python
from ase.db import connect
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/db5-3x3-bulk.db')

E, lat = [], []
for d in db.select():
    E += [abs(d.data['NN6'] / d.natoms - d.data['NN7'] / d.natoms)]
    lat += [d.a]
E = np.array(E)
lat = np.array(lat)

ind = E > 0.007
print sum(ind)
print sorted(list(set(lat) ^ set(lat[ind])))

def nbins(x):
    from math import log10, floor, ceil
    n = 3
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/db5_bulk_5lat.png')
#+END_SRC

#+RESULTS:
: 2225
: [3.6339999999999999, 3.9051111111111112, 3.9390000000000001]

** Database db6
Calculations for the next iteration of the bulk-only database.

*** Review of trained networks
#+BEGIN_SRC python
import os
from glob import glob
import shutil
import numpy as np

files = glob('networks/db6/40-*-*-1/train-log.txt')

for fil in files:
    fit = fil.split('/')[-2]

    with open(fil, 'r') as f:
        lines = f.readlines()

    print(fit, lines[-5])
#+END_SRC

#+RESULTS:
: ('40-6-6-1', ' 7743        2016-04-13T17:47:42  1.153e-01    2.106e-03\n')
: ('40-7-7-1', ' 7826        2016-04-13T17:47:45  1.105e-01    2.061e-03\n')
: ('40-8-8-1', ' 6074        2016-04-13T13:11:11  1.142e-01    2.095e-03\n')
: ('40-9-9-1', ' 7628        2016-04-13T17:47:47  1.161e-01    2.113e-03\n')

*** Fits to database data

#+BEGIN_SRC python :results silent
from ase.io import read
from amp import Amp
from ase.db import connect

db0 = connect('networks/db6/data.db')

with connect('temp/db6.db') as db:
    for d in db0.select():

        keys = d.key_value_pairs
        atoms = db0.get_atoms(d.id)

        calc = Amp('networks/db6/40-7-7-1/')
        atoms.set_calculator(calc)
        nnE = atoms.get_potential_energy()

        calc = Amp('networks/db6/40-8-8-1/')
        atoms.set_calculator(calc)
        nndE = atoms.get_potential_energy() - nnE

        atoms.set_calculator(None)
        keys.update({'nnE': nnE, 'nndE': nndE, 'nrg': d.energy})
        db.write(atoms, key_value_pairs=keys)
#+END_SRC

#+RESULTS: 


[[./images/db6_bulk.png]]

#+BEGIN_SRC python
from ase.io import read
from amp import Amp
from ase.db import connect
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/db6.db')

dE_train, dE_valid = [], []
for d in db.select():
    if d.train_set:
        dE_train += [(d.nnE - d.energy) / d.natoms]
    else:
        dE_valid += [(d.nnE - d.energy) / d.natoms]

def nbins(x):
    from math import log10, floor, ceil
    n = 4
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

fig, ax = plt.subplots(figsize=(6, 4))

print dE_train, dE_valid

# ax.hist(dE_train, bins=nbins(max(dE_train)),
#         color='r', alpha=0.3, normed=True)

# ax.hist(dE_valid, bins=nbins(max(dE_valid)),
#         color='b', alpha=0.3, normed=True)

# ax.set_xlabel('Predicted energy difference (eV/atom)')
# ax.set_ylabel('Probability')
# x0, x1 = ax.get_xlim()
# y0, y1 = ax.get_ylim()

# rmse_train = np.sqrt(sum(np.array(dE_train)**2))
# rmse_valid = np.sqrt(sum(np.array(dE_valid)**2))

# ax.text(x1 - x1/8., y1 - y1/10., '{:1.3f}'.format(rmse_train), color='r')
# ax.text(x1 - x1/8., y1 - y1/5., '{:1.3f}'.format(rmse_valid), color='b')
# plt.tight_layout()
# plt.savefig('./images/db6_bulk.png')
#+END_SRC

#+RESULTS:

*** for multi-lattice constants
#+caption: Energy differences between db6 NN frameworks for energy unique bulk configurations at 5 lattice constants.
#+label: fig-db6_bulk_5lat
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/db6_bulk_5lat.png]]


#+BEGIN_SRC python
from ase.db import connect
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/db6-3x3-bulk.db')

E, lat = [], []
for d in db.select():
    E += [abs(d.data['NN6'] / d.natoms - d.data['NN7'] / d.natoms)]
    lat += [d.a]
E = np.array(E)
lat = np.array(lat)

ind = E > 0.007
print sum(ind)
print sorted(list(set(lat) ^ set(lat[ind])))

def nbins(x):
    from math import log10, floor, ceil
    n = 3
    w = ceil(x*10**n) / ceil(x*10**n)*10**-n
    m = ceil(x*10**n)
    return np.arange(0, (m*w)+w, w)

plt.figure(figsize=(6, 4))
n, bins, patches = plt.hist(E, bins=nbins(max(E)))
plt.xlabel('Predicted energy difference (eV/atom)')
plt.ylabel('Probability')
plt.title('{0} total calculations'.format(len(E)))
plt.tight_layout()
plt.savefig('./images/db6_bulk_5lat.png')
#+END_SRC

#+RESULTS:
: 2225
: [3.6339999999999999, 3.9051111111111112, 3.9390000000000001]


* Scratch Pad
** Making temp file for db4 NN predictions
Create a temporary database which will contain the NN calculations for all of the db4 data.

#+BEGIN_SRC python :results silent
from ase.db import connect
from amp import Amp

db = connect('temp/db4.db')

with connect('temp/db4b.db') as dbm:
    for d in db.select():
        atoms = db.get_atoms(d.id)

        calc = Amp('networks/db4-bulk/40-6-6-1/')
        atoms.set_calculator(calc)
        E8 = atoms.get_potential_energy()

        calc = Amp('networks/db4-bulk/40-8-8-1/')
        atoms.set_calculator(calc)
        E10 = atoms.get_potential_energy()

        data = d.data
        data.update({'NN6b': E8, 'NN8b': E10})
        
        dbm.write(d,
                  key_value_pairs=d.key_value_pairs,
                  data=data)
#+END_SRC

** Statistical analysis

#+caption: Statisitcal analysis of the db4 data. 3 Standard deviations of the data are shown for the residual errors of two frameworks and the difference between the predictions made by those frameworks. The actual outliers (~A), predicted outliers (~B), and outliers that are correctly predicted (~A & ~B) are shown in the lower left for \pm 3 \sigma.
#+label: fig-pred-corr
#+attr_latex: :width 5in :placement [H]
#+attr_org: :width 500
[[./images/prediction-correlation.png]]

#+BEGIN_SRC python :results silent
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
from matplotlib.path import Path
import matplotlib.patches as patches

db = connect('temp/db4.db')

Qe, n8, n10 = [], [], []
for d in db.select('train_set'):
    n8 += [d.data.NN8 / d.natoms]
    n10 += [d.data.NN10 / d.natoms]
    Qe += [d.energy / d.natoms]

Qe = np.array(Qe)
n8 = np.array(n8)
n10 = np.array(n10)

# Calculate the differences between 
dQ8 = n8 - Qe
dQ10 = n10 - Qe
dn = n10 - n8

x = np.linspace(-0.012, 0.012)

# I'm looking to solve the least squares regression of the
# function y = mx, we do this here by setting b = 0.
A = np.vstack([dn, np.zeros(len(dn))]).T
f8 = np.poly1d(np.linalg.lstsq(A, dQ8)[0])

A = np.vstack([dn, np.zeros(len(dn))]).T
f10 = np.poly1d(np.linalg.lstsq(A, dQ10)[0])

# Now we solve for the Pearson product-moment correlation coefficients
cov8 = np.corrcoef(dn, dQ8)[0][1]
cov10 = np.corrcoef(dn, dQ10)[0][1]

# Calculate the RMSE of the residuals
rmse = [np.sqrt((dQ8**2).mean()),
        np.sqrt((dQ10**2).mean())]

# Standard deviation of the framework difference
std = np.std(dn)

# here we sample a region around some tolerance to see the number of points which
# fall within it

# A certain number of standard devaitions
tol = 3
err = std * int(tol)

verts = [(-0.012, -err),
         (0.012, -err),
         (0.012, err),
         (-0.012, err),
         (0., 0.)]
codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]
path = Path(verts, codes)

Nc8 = path.contains_points(zip(dn, dQ8))
Ni8 = float(sum(Nc8)) / len(Nc8)

Nc10 = path.contains_points(zip(dn, dQ10))
Ni10 = float(sum(Nc10)) / len(Nc10)

# Now sample the same error range in the x-coordinate for overlap
verts2 = [(-err, -0.012),
          (err, -0.012),
          (err, 0.012),
          (-err, 0.012),
          (0., 0.)]
path2 = Path(verts2, codes)

xNc8 = path2.contains_points(zip(dn, dQ8))
xNi8 = float(sum(xNc8)) / len(xNc8)

xNc10 = path2.contains_points(zip(dn, dQ10))
xNi10 = float(sum(xNc10)) / len(xNc10)

fig, ax1 = plt.subplots()
plt.text(-0.0065, 0.0095, 'Correlation\ncoefficients',
         ha='right', fontsize=14)
plt.text(-0.0075, 0.0085, '{:1.3f}'.format(cov8),
         color='b', ha='right', fontsize=14)
plt.text(-0.0075, 0.0075, '{:1.3f}'.format(cov10),
         color='r', ha='right', fontsize=14)

plt.text(0, 0.0095, 'RMSE', ha='center', fontsize=14)
plt.text(0, 0.0085, '{0:1.2e}'.format(rmse[0]), color='b', ha='center', fontsize=14)
plt.text(0, 0.0075, '{0:1.2e}'.format(rmse[1]), color='r', ha='center', fontsize=14)

patch = patches.PathPatch(path, facecolor='m', edgecolor='m', alpha=0.3)
ax1.add_patch(patch)

patch2 = patches.PathPatch(path2, facecolor='c', edgecolor='c', alpha=0.3)
ax1.add_patch(patch2)

plt.plot([-0.012, 0.012], [-0.012, 0.012], 'k--', lw=2)
ax1.plot(dn, dQ8, 'bo', alpha=0.5)
ax1.plot(x, f8(x), 'b--', lw=2)

ax2 = ax1.twinx()
ax2.plot(dn, dQ10, 'ro', alpha=0.5)
ax2.plot(x, f10(x), 'r--', lw=2)

plt.text(-0.01, err - 0.0005, '$\pm$ {} $\sigma$'.format(int(tol)),
         va='top', ha='center', fontsize=14)
plt.text(-0.01, err - 0.0015, '{:1.1%}'.format(Ni8), color='r',
         va='top', ha='center', fontsize=14)
plt.text(-0.01, err - 0.0025, '{:1.1%}'.format(Ni10), color='b',
         va='top', ha='center', fontsize=14)

plt.text(err - 0.0015, -0.008, '$\pm$ {} $\sigma$'.format(int(tol)),
         va='top', ha='center', fontsize=14)
plt.text(err - 0.0015, -0.009, '{:1.1%}'.format(xNi8), color='r',
         va='top', ha='center', fontsize=14)
plt.text(err - 0.0015, -0.010, '{:1.1%}'.format(xNi10), color='b',
         va='top', ha='center', fontsize=14)

plt.text(0.0035, -0.0075, 'Outliers:', fontsize=14)
plt.text(0.0035, -0.0085, '~A', color='m', fontsize=14)
plt.text(0.0057, -0.0085, '~B', color='c', fontsize=14)
plt.text(0.0079, -0.0085, '~A & ~B', fontsize=14)
plt.text(0.0035, -0.0095, '{:<8} {:<8} {:<8}'.format(sum(~Nc8), sum(~xNc8), sum(~Nc8 * ~xNc8)),
         color='b', fontsize=14)
plt.text(0.0035, -0.0105, '{:<8} {:<8} {:<8}'.format(sum(~Nc10), sum(~xNc10), sum(~Nc10 * ~xNc10)),
         color='r', fontsize=14)

ax1.tick_params(axis='y', colors='b')
ax2.tick_params(axis='y', colors='r')

ax1.set_ylabel('40-8-8-1 residual error (eV/atom)', color='b', fontsize=14)
ax2.set_ylabel('40-10-10-1 residual error (eV/atom)', color='r', fontsize=14)

ax1.set_ylim(-0.012, 0.012)
ax2.set_ylim(-0.012, 0.012)

ax1.set_xlabel('Framework difference (eV/atom)')
plt.xlim(-0.012, 0.012)
plt.tight_layout()
plt.savefig('./images/prediction-correlation.png')
#+END_SRC

#+caption: Relation of correctly predicted outliers to standard deviations of calculations. This is a representation of the cost to benefit of restarting a set of calculations.
#+label: fig-cost-benif
#+attr_latex: :width 5in :placement [H]
#+attr_org: :width 500
[[./images/cost-benefit.png]]

#+BEGIN_SRC python :results silent
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
from matplotlib.path import Path
import matplotlib.patches as patches

db = connect('temp/db4.db')

Qe, n8, n10 = [], [], []
for d in db.select('train_set'):
    n8 += [d.data.NN8 / d.natoms]
    n10 += [d.data.NN10 / d.natoms]
    Qe += [d.energy / d.natoms]

Qe = np.array(Qe)
n8 = np.array(n8)
n10 = np.array(n10)

# Calculate the differences between 
dQ8 = n8 - Qe
dQ10 = n10 - Qe
dn = n10 - n8

codes = [Path.MOVETO,
         Path.LINETO,
         Path.LINETO,
         Path.LINETO,
         Path.CLOSEPOLY]

fig, ax1 = plt.subplots()

x = np.linspace(0, 4.0, 81)

for E, c, label in [[dQ8, 'b', '40-8-8-1'], [dQ10, 'r', '40-10-10-1']]:
    
    y = []
    cost = []
    for tol in x:
        err = np.std(dn) * tol

        vertx = [(-err, -0.012),
                 (err, -0.012),
                 (err, 0.012),
                 (-err, 0.012),
                 (0., 0.)]
        verty = [(-0.012, -err),
                 (0.012, -err),
                 (0.012, err),
                 (-0.012, err),
                 (0., 0.)]

        pathx = Path(vertx, codes)
        px = pathx.contains_points(zip(dn, E))

        pathy = Path(verty, codes)
        py = pathy.contains_points(zip(dn, E))

        pred = sum(~px)
        true = sum(~py)
        pos = sum(~px * ~py)
        ROS = pos / float(true)

        cost += [pred]
        y += [ROS]


    cost = np.array(cost) / float(cost[0])
    ax1.plot(cost, y, '{}-'.format(c), label=label)

ax2 = ax1.twiny()

ax2.plot(x, np.zeros(len(x)))
ax2.invert_xaxis()
ax2.set_xlabel('Standard deviations')

plt.legend(loc='best')

ax1.plot([0, 1], [0, 1], 'k--')
ax1.set_xlabel('Cost fraction')
ax1.set_ylabel('Fraction of positive outliers')
plt.tight_layout()
plt.savefig('./images/cost-benefit.png')
#+END_SRC

** monte carlo simulation
#+BEGIN_SRC python
import os
import numpy as np

cmd = ''
for T in [700, 800, 900]:
    for A in np.linspace(6, 102, 17)[::2]:
	script = """#!/usr/bin/env python
import numpy as np
from ase.atoms import Atoms
import random
from ase.units import kB
from ase.db import connect

def main(atoms, dbname, T, steps):

    db = connect(dbname)

    # Setting up variables for Cannonical MC
    symbols = atoms.get_chemical_symbols()
    chem_bins = {{sym: [] for sym in set(symbols)}}

    for i, s in enumerate(symbols):
	chem_bins[s] += [i]

    # Calculate the initial energy and store it
    nrg = atoms.get_potential_energy()

    # dummy = Atoms.copy(atoms)
    # db.write(dummy, nrg=nrg)

    # Perform MC steps
    attempt, success = 0, 0
    while success < steps:

        # First, choose two chemicals to swap
        sym1, sym2 = random.sample(chem_bins.keys(), 2)
        random.shuffle(chem_bins[sym1])
        ind1 = chem_bins[sym1][-1]

        random.shuffle(chem_bins[sym2])
        ind2 = chem_bins[sym2][-1]

        # Create new atoms object to test
        new_atoms = Atoms.copy(atoms)
        new_atoms.set_calculator(atoms.get_calculator())

        # Update the atoms object
        new_atoms[ind1].symbol, new_atoms[ind2].symbol = sym2, sym1

        # Calculate the energy of the new system
        new_nrg = new_atoms.get_potential_energy()

        # Stores energy in continuously growing list
        # potentially memory intensive, but faster than writing to disk
        if new_nrg < nrg:
            atoms = new_atoms
            nrg = new_nrg
	    chem_bins[sym2][-1] = ind1
	    chem_bins[sym1][-1] = ind2

            dummy = Atoms.copy(atoms)
            db.write(dummy, nrg=nrg)
            success += 1

        elif np.exp(-(new_nrg - nrg) / (kB * T)) > np.random.rand():
            atoms = new_atoms
            nrg = new_nrg
	    chem_bins[sym2][-1] = ind1
	    chem_bins[sym1][-1] = ind2

            dummy = Atoms.copy(atoms)
            db.write(dummy, nrg=nrg)
            success += 1

        attempt += 1

    return success/attempt

from amp import Amp

# Select last configuration
db = connect('/home-research/jboes/research/cluster-expansion/MC/T{1}-{0}.db')
cnt = db.count()
atoms = db.get_atoms('id={{}}'.format(int(cnt)))

atoms.set_calculator(Amp('/home-research/jboes/research/cluster-expansion/networks/db6/40-7-7-1/'))

main(atoms, '/home-research/jboes/research/cluster-expansion/MC/T{1}-{0}.db', T={1}, steps=int(15000 - cnt))
""".format(int(A), int(T))

	name = 'MC/run-T{1}-{0}.py'.format(int(A), int(T))
	cmd += 'bpsh 30 -m {} & '.format(name.replace('MC', '.'))

	with open(name, 'w') as f:
	    f.write(script)
	os.chmod(name, 0755)

print(cmd)
#+END_SRC

#+RESULTS:
: bpsh 30 -m ./run-T700-6.py & bpsh 30 -m ./run-T700-18.py & bpsh 30 -m ./run-T700-30.py & bpsh 30 -m ./run-T700-42.py & bpsh 30 -m ./run-T700-54.py & bpsh 30 -m ./run-T700-66.py & bpsh 30 -m ./run-T700-78.py & bpsh 30 -m ./run-T700-90.py & bpsh 30 -m ./run-T700-102.py

*** Stagging code
To be run to make sure the scripted code performs as required.
**** Starting from highly ordered system
#+BEGIN_SRC python
from ase.lattice.cubic import FaceCenteredCubic as fcc
from amp import Amp

atoms = fcc('Cu', size=(3, 3, 3),
	    latticeconstant=(3.939-3.634)*({0}/108.) + 3.634)

for i in range(int({0})):
    atoms[i].symbol = 'Pd'
#+END_SRC

**** Starting from last configuration
#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

# Select last configuration in list
db = connect('/home-research/jboes/research/cluster-expansion/MC/T800-54.db')
cnt = db.count()
atoms = db.get_atoms('id={}'.format(cnt))
#+END_SRC

#+RESULTS:
: 4571

**** Starting from lowest energy configuration
#+BEGIN_SRC python
import numpy as np
from ase.db import connect

# Select the lowest energy configuration
db = connect('/home-research/jboes/research/cluster-expansion/MC/108-54.db')
E, ID = [], []
for d in db.select():
    E += [d.nrg]
    ID += [d.id]
E = np.array(E)
ID = np.array(ID)

i = list(E).index(min(E))
atoms = db.get_atoms(ID[i])
#+END_SRC

**** Starting from new thick-slab configurations
#+BEGIN_SRC python
atoms = fcc111('Cu', size=(10, 10, 15), vacuum=6.0,
               a=(3.939 - 3.634)*{0}/100. + 3.634)
atoms.set_pbc([True, True, False])

random.seed(255)
for n in random.sample(range(len(atoms)),
                       int(1500*{0}/100.)):
    atoms[n].symbol = 'Pd'
#+END_SRC

*** Slab MC
#+BEGIN_SRC python
import os

cmd = ''
for comp in [10, 20, 30, 40, 50, 60, 70, 80, 90]:

    script = """#!/usr/bin/env python
import numpy as np
from ase.atoms import Atoms
import random
from ase.units import kB
from ase.db import connect
from ase.lattice.surface import fcc111
from amp import Amp

def main(atoms, dbname, T, steps):

    db = connect(dbname)

    # Setting up variables for Cannonical MC
    symbols = atoms.get_chemical_symbols()
    chem_bins = {{sym: [] for sym in set(symbols)}}

    for i, s in enumerate(symbols):
	chem_bins[s] += [i]

    # Calculate the initial energy and store it
    nrg = atoms.get_potential_energy()

    dummy = Atoms.copy(atoms)
    db.write(dummy, nrg=nrg)

    # Perform MC steps
    attempt, success = 0, 0
    while success < steps:

        # First, choose two chemicals to swap
        sym1, sym2 = random.sample(chem_bins.keys(), 2)
        random.shuffle(chem_bins[sym1])
        ind1 = chem_bins[sym1][-1]

        random.shuffle(chem_bins[sym2])
        ind2 = chem_bins[sym2][-1]

        # Create new atoms object to test
        new_atoms = Atoms.copy(atoms)
        new_atoms.set_calculator(atoms.get_calculator())

        # Update the atoms object
        new_atoms[ind1].symbol, new_atoms[ind2].symbol = sym2, sym1

        # Calculate the energy of the new system
        new_nrg = new_atoms.get_potential_energy()

        # Stores energy in continuously growing list
        # potentially memory intensive, but faster than writing to disk
        if new_nrg < nrg:
            atoms = new_atoms
            nrg = new_nrg
	    chem_bins[sym2][-1] = ind1
	    chem_bins[sym1][-1] = ind2

            dummy = Atoms.copy(atoms)
            db.write(dummy, nrg=nrg)
            success += 1

        elif np.exp(-(new_nrg - nrg) / (kB * T)) > np.random.rand():
            atoms = new_atoms
            nrg = new_nrg
	    chem_bins[sym2][-1] = ind1
	    chem_bins[sym1][-1] = ind2

            dummy = Atoms.copy(atoms)
            db.write(dummy, nrg=nrg)
            success += 1

        attempt += 1

    return success/attempt

# Select last configuration in list
db = connect('/home-research/jboes/research/cluster-expansion/MC/SLAB-T800-Pd{0}.db')
cnt = db.count()
atoms = db.get_atoms('id={{}}'.format(cnt))

atoms.set_calculator(Amp('/home-research/jboes/research/cluster-expansion/networks/db6/40-7-7-1/'))

main(atoms, '/home-research/jboes/research/cluster-expansion/MC/SLAB-T800-Pd{0}.db', T=800, steps=int(10000 - cnt))
""".format(int(comp))

    name = 'MC/run-SLAB-T800-Pd{}.py'.format(int(comp))
    cmd += 'bpsh 30 -m {} & '.format(name.replace('MC', '.'))

    with open(name, 'w') as f:
	f.write(script)
    os.chmod(name, 0755)

print(cmd)
#+END_SRC

#+RESULTS:
: bpsh 30 -m ./run-SLAB-T800-Pd10.py & bpsh 30 -m ./run-SLAB-T800-Pd20.py & bpsh 30 -m ./run-SLAB-T800-Pd30.py & bpsh 30 -m ./run-SLAB-T800-Pd40.py & bpsh 30 -m ./run-SLAB-T800-Pd50.py & bpsh 30 -m ./run-SLAB-T800-Pd60.py & bpsh 30 -m ./run-SLAB-T800-Pd70.py & bpsh 30 -m ./run-SLAB-T800-Pd80.py & bpsh 30 -m ./run-SLAB-T800-Pd90.py & 

#+BEGIN_SRC python
import os
import numpy as np
from ase.db import connect
from glob import glob

for wd in glob('MC/SLAB-T800-Pd*.db'):
    print(wd, connect(wd).count())
#+END_SRC

#+RESULTS:
: ('MC/SLAB-T800-Pd20.db', 44)
: ('MC/SLAB-T800-Pd70.db', 93)
: ('MC/SLAB-T800-Pd10.db', 71)
: ('MC/SLAB-T800-Pd60.db', 89)
: ('MC/SLAB-T800-Pd80.db', 52)
: ('MC/SLAB-T800-Pd50.db', 69)
: ('MC/SLAB-T800-Pd30.db', 44)
: ('MC/SLAB-T800-Pd90.db', 68)
: ('MC/SLAB-T800-Pd40.db', 45)

*** Temperature Ground state hull
[[./images/gs-hull-temp.png]]

#+BEGIN_SRC python :results silent
import numpy as np
from ase.db import connect
import matplotlib.pyplot as plt
from ase.visualize import view
from amp import Amp
from ase.lattice.cubic import FaceCenteredCubic as fcc
from scipy.optimize import curve_fit

fig, ax = plt.subplots()

# Select the lowest energy configuration
temps = [100, 800]
x = np.linspace(0, 1, 100)

ref = {}
for A, a in [['Cu', 3.634], ['Pd', 3.939]]:
    atoms = fcc(A,
                directions=[[0, 1, 1],
                            [1, 0, 1],
                            [1, 1, 0]],
    latticeconstant=a)

    atoms.set_calculator(Amp('networks/db5/40-7-7-1/trained-parameters.json'))
    ref[A] = atoms.get_potential_energy()

def fit(x, p0, p1, p2):
    return p0*x**4 + p1*x**3 + p2*x**2 - (p0 + p1 + p2)*x

for T, c in [['/', 'r'], ['/lowT-', 'b']]:

    C, avg, comp, std, Emin = [], [0.0], [0.0], [0.0], []
    for A in np.linspace(6, 102, 17):

	db = connect('MC{}108-{}.db'.format(T, int(A)))

	E, ID = [], []
	for d in db.select():
            syms = d.symbols
	    E += [(d.nrg - ref['Cu'] * syms.count('Cu') - ref['Pd'] * syms.count('Pd')) / d.natoms]
	    ID += [d.id]
	E, ID = np.array(E), np.array(ID)

    	MIN = list(E).index(min(E))
    	MAX = list(E).index(max(E))
    	atoms = db.get_atoms(ID[MIN])

        avg += [np.mean(E)]
        std += [np.std(E)]
        comp += [A / 108.0]
        C += [len(E)]
        Emin += [E[MIN]]

    popt, pcov = curve_fit(fit, comp, avg)

    comp = np.array(comp + [1.])
    avg = np.array(avg + [0.])
    std = np.array(std + [0.])

    plt.scatter(comp, avg, color=c)
    ax.fill_between(comp, avg + std, avg - std, facecolor=c, alpha=0.5)

for i, cnt in enumerate(C):
    plt.scatter(comp[i+1], Emin[i], color='g', marker='^')
    plt.text(comp[i+1] + 0.01, avg[i+1], cnt, va='center', ha='left')

ax.xaxis.set_ticks(np.linspace(0., 1., 5))
ax.yaxis.set_ticks(np.linspace(0.0, -0.1, 11))
ax.grid(True)

plt.legend(['800 K', r'$\pm$ 1$\sigma$', '100 K', r'$\pm$ 1$\sigma$'], loc=9)
plt.xlim(0, 1)
plt.xlabel('Cu$_{1-x}$Pd$_{x}$ composition (x)')
plt.ylabel('Heat of formation (eV/atom)')
plt.ylim(-0.1, 0)
plt.tight_layout()
plt.savefig('./images/gs-hull-temp.png')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect
from ase.visualize import view
from jasp import *
from glob import glob
from jbtools.utils import get_composition
from amp import Amp
from ase.lattice.cubic import FaceCenteredCubic as fcc
JASPRC['restart_unconverged'] = False

# db = connect('MC/lowT-108-24.db')
# atoms = db.get_atoms('id=4')

def aPd(x):
    return (3.939 - 3.634) * x + 3.634

ref = {}
for A, a in [['Cu', 3.634], ['Pd', 3.939]]:
    atoms = fcc(A,
                directions=[[0, 1, 1],
                            [1, 0, 1],
                            [1, 1, 0]],
    latticeconstant=a)

    atoms.set_calculator(Amp('networks/db5/40-7-7-1/trained-parameters.json'))
    ref[A] = atoms.get_potential_energy()


wds = glob('DFT/bulk=fcc/config=*/strain=xyz/factor=1.0/xc=PBE/gga=PS/')

for wd in wds:
    try:
	with jasp(wd) as calc:
	    atoms = calc.get_atoms()
	atoms.set_calculator(Amp('networks/db5/40-7-7-1/trained-parameters.json'))

	x = get_composition(atoms, 'Pd')
	cell = atoms.get_cell()
        vol = atoms.get_volume()

	f = aPd(x) / (4 * vol / len(atoms))**(1/3.)

	delta = np.array([[f, 0, 0],
			  [0, f, 0],
			  [0, 0, f]])

	atoms.set_cell(np.dot(cell, delta), scale_atoms=True)

        sym = atoms.get_chemical_symbols()
	nrg = atoms.get_potential_energy()

        d = (nrg - sym.count('Cu')*ref['Cu'] - sym.count('Pd')*ref['Pd']) / len(atoms)

        if d < -0.085:
	    print x, d
    except(VaspNotFinished):
        pass
#+END_SRC

#+RESULTS:
: 0.5 -0.0939482131107
: 0.5 -0.0884387641227
: 0.333333333333 -0.0897940519288
: 0.4 -0.088162003458
: 0.4 -0.0899312765147
: 0.375 -0.0859626700218

*** Boltzmann distribution 
[[./images/boltzmann.png]]

#+BEGIN_SRC python :results silent
import matplotlib.pyplot as plt
from ase.units import kB
import numpy as np
from matplotlib.widgets import Slider, Button, RadioButtons

fig, ax = plt.subplots()
plt.subplots_adjust(bottom=0.2)
dE = np.arange(0, 0.5, 0.001)
T0 = 273.15
E0 = 0

def P(dE, T):
    return np.exp(-dE / (kB * T))

line, = plt.plot(dE, P(dE, T0), 'r-', lw=2)
plt.axis([0, 0.5, 0, 1])

marker, = plt.plot([E0], [P(E0, T0)], 'ro', ms=5)

axT = plt.axes([0.15, 0.05, 0.72, 0.03])

# Slider object
sT = Slider(axT, 'Temp (K)', 0, 1000, valinit=T0)

def update(val):
    temp = sT.val
    line.set_ydata(P(dE, temp))
    fig.canvas.draw_idle()
sT.on_changed(update)

def onmove(event):
    x = event.xdata
    temp = sT.val

    ax.set_title('dE: {0:1.3f}\nProbability: {1:1.3f}'.format(x, P(x, temp)))
    marker.set_xdata(x)
    marker.set_ydata(P(x, temp))

    ax.figure.canvas.draw()

mv = fig.canvas.mpl_connect('motion_notify_event', onmove)

ax.set_xlabel('$\Delta$E (eV)')
ax.set_ylabel('Probability')
plt.savefig('./images/boltzmann.png')
plt.show()
#+END_SRC

** BCT via EMT

#+caption: EMT predicted equation of states for the fcc and bcc configurations.
#+label: fig-emt-eos
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/EMT-EOS.png]]

#+name: EMT-minimum-lattice-constants
#+BEGIN_SRC python
from ase.lattice.tetragonal import CenteredTetragonal as bct
import numpy as np
from asap3 import EMT
import matplotlib.pyplot as plt

A = np.linspace(2.4, 3.2, 1000)
CA = {'fcc':np.sqrt(2), 'bcc':1.0}

plt.figure()
nrg = {}
for name, ca in CA.iteritems():

    nrg[name] = []

    for a in A:
        atoms = bct('Cu', latticeconstant={'a': a, 'c/a': ca})
        atoms[1].symbol = 'Pd'

        atoms.set_calculator(EMT())
        nrg[name] += [atoms.get_potential_energy()]

Emin = [min(l) for l in nrg.values()]
dEmin = (max(Emin) - min(Emin))

Amin = [A[Es.index(min(Es))] for Es in nrg.values()]
print(Amin)


plt.plot(A, nrg['fcc'], 'g-')
plt.text(Amin[0], Emin[0], 'fcc', ha='center', va='top', color='g', size=20)
plt.plot(A, nrg['bcc'], 'b-')
plt.text(Amin[1], Emin[1], 'bcc', ha='center', va='top', color='b', size=20)
plt.xlim(2.55, 3.05)
plt.ylim(-0.08, -0.02)
plt.xlabel('bcc lattice constant, a ($\AA$)')
plt.ylabel('Potential energy (eV)')
plt.tight_layout()
plt.savefig('./images/EMT-EOS.png')
#+END_SRC

#+caption: 3D Minimum energy pathway of transition through bct geometry space as predicted by EMT.
#+label: fig-3d-cupd-min-emt
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/3D-EMT-pathway.png]]

#+caption: 2D Minimum energy pathway of transition through bct geometry space as predicted by EMT.
#+label: fig-2d-cupd-min-emt
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/2D-EMT-pathway.png]]

#+RESULTS: EMT-minimum-lattice-constants

#+BEGIN_SRC python :results silent :var eos=EMT-minimum-lattice-constants
from ase.lattice.tetragonal import CenteredTetragonal as bct
import numpy as np
from asap3 import EMT
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d
from matplotlib import cm

aref = [float(eos) for eos in eos[1:-2].split(',')]

# Create a list of sample points
ca0 = np.linspace(0.9, 1.5, 98)
ca0 = np.append(ca0, [1.0, np.sqrt(2)])
a0 = np.linspace(2.5, 3.1, 98)
a0 = np.append(a0, [aref[0], aref[1]])

a0 = np.unique(a0)
ca0 = np.unique(ca0)

X, Y = np.meshgrid(a0, ca0)

xifcc = list(X[0]).index(aref[0])
yifcc = list(Y.T[0]).index(np.sqrt(2))

xibcc = list(X[0]).index(aref[1])
yibcc = list(Y.T[0]).index(1.0)

Z = np.zeros(X.shape)

for i, a in enumerate(a0):

    for j, ca in enumerate(ca0):

        # Generate structure based on sample points
        atoms = bct('Cu', latticeconstant={'a': a, 'c/a': ca})
        atoms[1].symbol = 'Pd'

        atoms.set_calculator(EMT())
        Z[j][i] += [atoms.get_potential_energy()]

eminZ, cminZ, aminZ = [], [], []
for i, c in enumerate(ca0[yibcc:yifcc+1]):
    data = Z[i+yibcc, :]
    ind = list(data).index(min(data))

    eminZ.append(min(data))
    cminZ.append(c)
    aminZ.append(a0[ind])

delta = (max(eminZ) - min(eminZ))
rng = [min(eminZ), max(eminZ) + delta]

Z[Z > rng[1]] = np.nan

fig = plt.figure(figsize=(8, 6))
ax = fig.gca(projection='3d')
CM = cm.autumn
cset = ax.contourf(X, Y, Z, zdir='z', offset=rng[0] - delta, cmap=CM, vmin=rng[0], vmax=rng[1])

ax.plot_surface(X, Y, Z,
                rstride=1,
                cstride=1,
                cmap=CM,
                linewidth=0,
                vmin=rng[0],
                vmax=rng[1])

ax.scatter(aminZ[1:-1], cminZ[1:-1], eminZ[1:-1], c='k')

ax.plot([aref[0], aref[0]], [np.sqrt(2), np.sqrt(2)], [rng[0] - delta, eminZ[-1]], 'go-', zorder=99)
ax.text(aref[0], np.sqrt(2), eminZ[-1]+0.01, 'fcc', color='g', zorder=99, size='large')

ax.plot([aref[1], aref[1]], [1.0, 1.0], [rng[0] - delta, eminZ[0]], 'bo-', zorder=99)
ax.text(aref[1], 1.0, eminZ[0]+0.01, 'bcc', color='b', zorder=99, size='large')

ax.set_xlabel('a')
ax.set_xlim(2.4, 3.2)
ax.set_ylabel('c/a')
ax.set_ylim(0.8, 1.6)
ax.set_zlabel('Total energy (eV)')
ax.set_zlim(rng[0] - delta, rng[1])
plt.tight_layout()
plt.savefig('./images/3D-EMT-pathway.png')

plt.figure()
plt.plot(cminZ, eminZ, 'k-')
plt.xlim(min(cminZ), max(cminZ))

plt.annotate('bcc', xy=(cminZ[0], eminZ[0]),
             xytext=(cminZ[0] + .02, eminZ[0] - .005),
             size=20, ha='left', arrowprops=dict(arrowstyle='->'))

plt.annotate('fcc', xy=(cminZ[-1], eminZ[-1]),
             xytext=(cminZ[-1] - .02, eminZ[-1] + .005),
             size=20, ha='right', arrowprops=dict(arrowstyle='->'))

plt.xlabel('c/a ratio')
plt.ylabel('Total energy (eV)')

plt.savefig('./images/2D-EMT-pathway.png')
#+END_SRC

** MD simulations on various compositions

[[./images/calc-time.png]]

#+BEGIN_SRC python
from timeit import timeit
import matplotlib.pyplot as plt
import numpy as np

t = []
n = np.array(range(1, 8))
natoms = 27*n**3

for i in n:
    script = '''from amp import Amp
from ase.visualize import view
from ase.db import connect

db = connect('temp/bulk-3x3.db')
atoms = db.get_atoms(['a=3.634', 'config=1000'])

calc = Amp('networks/db5/40-7-7-1/')

atoms *= ({0}, {0}, {0})
atoms.set_calculator(calc)
atoms.get_potential_energy()
'''.format(i)
    t += [float(timeit(script, number=1)) / 60.]

fit = np.poly1d(np.polyfit(natoms, t, 2))
print(fit)

x = np.linspace(natoms[0], natoms[-1])

plt.figure()
plt.plot(natoms, t, 'bo')
plt.plot(x, fit(x), 'b-')
plt.xlabel('number of atoms')
plt.ylabel('Calculation time (min)')
plt.tight_layout()
plt.savefig('images/calc-time.png')
#+END_SRC

#+RESULTS:
:            2
: 1.858e-08 x + 0.0001521 x + 0.09639

Calculating the energies of various structures at their natural lattice constant.

#+BEGIN_SRC python
from ase.db import connect
from jbtools.utils import get_composition
from amp import Amp
from ase.lattice.cubic import FaceCenteredCubic as fcc
import numpy as np

db0 = connect('temp/bulk-3x3.db')

def aPd(x):
    return (3.939 - 3.634) * x + 3.634

with connect('temp/vegard-3x3.db') as db:
    for d in db0.select(['a=3.939']):

	atoms = db0.get_atoms(d.id)
	c = get_composition(atoms, 'Pd')

        f = aPd(c) / 3.939

        delta = np.array([[f, 0, 0],
                          [0, f, 0],
                          [0, 0, f]])

        cell = atoms.get_cell()
        atoms.set_cell(np.dot(cell, delta), scale_atoms=True)

        keys = {'a': aPd(c), 'config': int(d.config)}

	data = {}
	for l in [6, 7]:
	    key = 'NN{}'.format(l)
	    calc = Amp('networks/db5/40-{0}-{0}-1/'.format(l))
	    atoms.set_calculator(calc)
	    data[key] = atoms.get_potential_energy()

	atoms.set_calculator(None)

	db.write(atoms, key_value_pairs=keys, data=data)
#+END_SRC

#+RESULTS:

[[./images/vegard-error-bulk.png]]

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from ase.visualize import view
from matplotlib._png import read_png
from ase.io import write
from matplotlib.offsetbox import TextArea, DrawingArea, OffsetImage, \
    AnnotationBbox
from matplotlib.widgets import Slider

db = connect('temp/vegard-3x3.db')

data = {}
ID, LAT, ERR = [], [], []
for d in db.select():

    ERR += [(d.data.NN6 - d.data.NN7) / d.natoms]
    ID += [d.id]
    LAT += [d.a]

    if d.a not in data.keys():

        data[d.a] = np.array([d.id,
                      d.data.NN6,
                      d.data.NN7,
                      (d.data.NN6 - d.data.NN7) / d.natoms])
    else:
        data[d.a] = np.vstack([data[d.a], np.array([d.id,
                       d.data.NN6,
                       d.data.NN7,
                       (d.data.NN6 - d.data.NN7) / d.natoms])])


mins = []
fig = plt.figure(figsize=(6, 4))
ax = fig.add_subplot(111)
ax.plot([3.634, 3.939], [0, 0], 'k--', lw=2)

ax.set_title('click on a point')
l, = ax.plot(LAT, ERR, 'bo', picker=5)

for lat, v in data.iteritems():
    error = v.T[-1]
    if isinstance(error, float):
        error = np.array([error])

    # find the minimum energy structure
    try:
        mc1 = int(list(v.T[1]).index(v.T[1].min()))
        mc2 = int(list(v.T[2]).index(v.T[2].min()))
        mins += [int(v.T[0][mc2])]
    except(TypeError):
        mc1, mc2 = 0, 0
        mins += [int(v.T[0])]

    # ax.plot(np.zeros(error.shape) + lat, error, 'bo')
    ax.plot(lat, error[mc1], 'ro')
    ax.plot(lat, error[mc2], 'go')

def onpick(event):
    ind = event.ind

    ax.set_title('Atom index {}'.format(ID[ind]))
    atoms = db.get_atoms(ID[ind])

    write('./images/temp-atoms.png', db.get_atoms(ID[ind]))
    arr_lena = read_png('./images/temp-atoms.png')
    imagebox = OffsetImage(arr_lena, zoom=0.35)
    ab = AnnotationBbox(imagebox, [3.85, 0.0055], frameon=False)

    ax.add_artist(ab)

    ax.figure.canvas.draw()  # this line is critical to change the linewidth
    plt.savefig('./images/vegard-error-bulk.png')

    if event.mouseevent.button == 3:
        view(atoms)


fig.canvas.mpl_connect('pick_event', onpick)

ax.set_xlim(3.634, 3.939)
ax.set_xlabel('fcc lattice constant ($\AA$)')
ax.set_ylabel('Difference in neural networks (eV/atom)')
plt.tight_layout()
# plt.savefig('./images/vegard-error-bulk.png')
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results silent

MES = [1, 2, 23, 389, 432, 576, 815, 816, 918, 1173, 1174, 1175, 1179, 1303, 1390, 1497, 1544, 1573, 1584, 1604, 1605, 1616, 1621, 1631, 1633, 1634, 1635, 1636]

for n in MES:

    script = '''#!/usr/bin/env python
# from ase.db import connect
from amp import Amp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units

images = Trajectory("/home-research/jboes/research/cluster-expansion/script/out-{0}.traj", "r")
atoms = images[-1]

# db = connect("/home-research/jboes/research/cluster-expansion/temp/vegard-3x3.db")
# atoms = db.get_atoms({0})

atoms.set_calculator(Amp("/home-research/jboes/research/cluster-expansion/networks/db5/40-7-7-1/"))

T = 500
dyn = Langevin(atoms, 5 * units.fs, T * units.kB, 0.002)

def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy()
    ekin = a.get_kinetic_energy()

# Record the energies in the trajectory file
dyn.attach(printenergy, interval=1)

# We also want to save the positions of all atoms after every 100th time step.
traj = Trajectory("/home-research/jboes/research/cluster-expansion/script/out-{0}.traj", "a", atoms)
dyn.attach(traj.write, interval=1)

# Now run the dynamics
dyn.run(5000)
'''.format(n)

    with open('script/run-{}.py'.format(n), 'w') as f:
        f.write(script)
#+END_SRC

#+BEGIN_SRC python
MES = [1, 2, 23, 389, 432, 576, 815, 816, 918, 1173, 1174, 1175, 1179, 1303, 1390, 1497, 1544, 1573, 1584, 1604, 1605, 1616, 1621, 1631, 1633, 1634, 1635, 1636]

str_list = []
for n in MES:
    str_list += ['bpsh 30 -m ./run-{}.py &'.format(n)]

print ' '.join(str_list)
#+END_SRC

#+RESULTS:
: bpsh 30 -m ./run-1.py & bpsh 30 -m ./run-2.py & bpsh 30 -m ./run-23.py & bpsh 30 -m ./run-389.py & bpsh 30 -m ./run-432.py & bpsh 30 -m ./run-576.py & bpsh 30 -m ./run-815.py & bpsh 30 -m ./run-816.py & bpsh 30 -m ./run-918.py & bpsh 30 -m ./run-1173.py & bpsh 30 -m ./run-1174.py & bpsh 30 -m ./run-1175.py & bpsh 30 -m ./run-1179.py & bpsh 30 -m ./run-1303.py & bpsh 30 -m ./run-1390.py & bpsh 30 -m ./run-1497.py & bpsh 30 -m ./run-1544.py & bpsh 30 -m ./run-1573.py & bpsh 30 -m ./run-1584.py & bpsh 30 -m ./run-1604.py & bpsh 30 -m ./run-1605.py & bpsh 30 -m ./run-1616.py & bpsh 30 -m ./run-1621.py & bpsh 30 -m ./run-1631.py & bpsh 30 -m ./run-1633.py & bpsh 30 -m ./run-1634.py & bpsh 30 -m ./run-1635.py & bpsh 30 -m ./run-1636.py &

** Analysis of the MD simulations

#+BEGIN_SRC python :results raw
from ase.visualize import view
from glob import glob
from ase.io.trajectory import Trajectory
import matplotlib.pyplot as plt
import numpy as np

files = glob('script/out-*.traj')

files = [files[0]]

for f in files:
    traj = Trajectory(f)
    name = f.split('/')[-1].split('.')[0]

    pE, kE, c = [], [], []
    for i, atoms in enumerate(traj):
        c += [i]
        pE += [atoms.get_potential_energy()]
        kE += [atoms.get_kinetic_energy()]

    pE = np.array(pE) - pE[0]
    kE = np.array(kE) - kE[0]

    ind = [kE < 5.0] or [pE < 5.0]

    pE = pE[ind]
    kE = kE[ind]
    c = np.array(c)[ind]

    def onpick(event):
	ind = event.ind
	atoms = traj[ind]
	view(atoms)

	# write('./images/temp-atoms.png', db.get_atoms(ID[ind]))
	# arr_lena = read_png('./images/temp-atoms.png')
	# imagebox = OffsetImage(arr_lena, zoom=0.3)
	# ab = AnnotationBbox(imagebox, [3.85, 0.0055], frameon=False)
	# ax.add_artist(ab)

	ax.figure.canvas.draw()  # this line is critical to change the linewidth
	plt.savefig('./images/{}.png'.format(name))

    fig = plt.figure(figsize=(6, 4))
    ax = fig.add_subplot(111)
    ax.plot(c, pE, 'bo-', label='potential', picker=5)
    ax.plot(c, kE, 'r-', label='kinetic')
    ax.set_xlabel('Step')
    ax.set_ylabel('Energy (eV/atom)')
    ax.legend(loc='best')
    plt.tight_layout()
    fig.canvas.mpl_connect('pick_event', onpick)

    #if np.array(ind).all():
    #    print('{} still running'.format(name))
    #else:
    #    print('{} failure step: {}'.format(name, np.array(ind).sum()))
    #print('[[./images/{}.png]]'.format(name))

plt.show()
#+END_SRC

#+RESULTS:

* Database manipulations
I need to merge recent calculations from the cluster expansion into the existing database for the next iteration for bulk calculations. In this section I will add some additional manipulations to the existing database.

** Merging db5 and cluster expansion into db6
#+BEGIN_SRC python :results silent
import numpy as np
from ase.db import connect
import os
import shutil

if not os.path.exists('./networks/db6/'):
    os.mkdir('./networks/db6/')

db0 = connect('./CuPd_fcc/atat_atoms.db')
db1 = connect('./networks/db5/data.db')

with connect('./networks/db6/data.db') as db:
    for d in db0.select():
	atoms = db0.get_atoms(d.id)

	# Manipulation of kvp
	keys = {'bulk': 'fcc'}
	keys.update({'atat': int(d.atat),
		     'lattice': float('{:1.3f}'.format(d.a))})

	db.write(atoms, key_value_pairs=keys)

    for d in db1.select():
	atoms = db1.get_atoms(d.id)

	# Manipulation of kvp
	keys = d.key_value_pairs
        del keys['train_set']

	db.write(atoms, key_value_pairs=keys)
#+END_SRC

#+BEGIN_SRC python
from ase.db import connect
import random
import numpy as np

def produce_trainset(database, fraction=0.9, seed=256):
    """Produce a train.db database for training 
    """

    db = connect(database)

    n = db.count()
    n_train = int(round(n * fraction))
    n_ids =  np.array(range(n)) + 1

    # This will sudo-randomly select 10% of the calculations
    # Which is useful for reproducing our results.
    random.seed(seed)
    train_samples = random.sample(n_ids, n_train)
    valid_samples = set(n_ids) - set(train_samples)

    db.update(list(train_samples), train_set=True)
    db.update(list(valid_samples), train_set=False)

    parent = '/'.join(database.split('/')[:-1])

    db0 = connect(parent + '/train.db')

    for d in db.select(['train_set=True']):
        db0.write(d, key_value_pairs=d.key_value_pairs)

# Produce a trainset with 90% of the database calculations
produce_trainset('networks/db6/data.db', fraction=0.9)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import numpy as np
from ase.db import connect
import os
import shutil

for n in range(6, 10):
    script = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork

calc = Amp(label="./",
           descriptor=Behler(cutoff=6.5),
           regression=NeuralNetwork(hiddenlayers=(2, {0})))

calc.train("../train.db",
           cores=12,
           energy_goal=0.0005,
           force_goal=None,
           extend_variables=False)
'''.format(n)

    if not os.path.exists('./networks/db6/40-{0}-{0}-1/'.format(n)):
        os.mkdir('./networks/db6/40-{0}-{0}-1/'.format(n))

    with open('./networks/db6/40-{0}-{0}-1/script.py'.format(n), 'w') as f:
	f.write(script)
    os.chmod('./networks/db6/40-{0}-{0}-1/script.py'.format(n), 0755)

    with open('./networks/db6/40-{0}-{0}-1/script.sh'.format(n), 'w') as f:
	f.write('bpsh 30 -m ./script.py')
    os.chmod('./networks/db6/40-{0}-{0}-1/script.sh'.format(n), 0755)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect
from glob import glob
import matplotlib.pyplot as plt

files = glob('MC/T*-18.db')

for f in files:
    db = connect(f)

    E = []
    for d in db.select():
	E += [d.nrg]

    T = f.split('-')[0].lstrip('MC/T')
    plt.plot(range(len(E)), E, label=T)

plt.legend(loc='best')
plt.show()
#+END_SRC

#+RESULTS:

* db6 Analysis
** Ground state hull at finite temperature
#+caption: Ground state hull at 700, 800, and 900 K predicted from Neural Networks.
[[./images/gs-hull-3temp.png]]


#+BEGIN_SRC python :results silent
import numpy as np
from ase.db import connect
import matplotlib.pyplot as plt
from ase.visualize import view
from amp import Amp
from ase.lattice.cubic import FaceCenteredCubic as fcc
from scipy.optimize import curve_fit

calc = Amp('networks/db6/40-7-7-1/trained-parameters.json')

c = ['b', 'm', 'r']

ref = {}
for A, a in [['Cu', 3.634], ['Pd', 3.939]]:
    atoms = fcc(A,
                directions=[[0, 1, 1],
                            [1, 0, 1],
                            [1, 1, 0]],
    latticeconstant=a)

    atoms.set_calculator(calc)
    ref[A] = atoms.get_potential_energy()

fig, ax = plt.subplots(figsize=(6, 4))
for i, T in enumerate([700, 800, 900]):

    comp, avg, std = [0.], [0], [0]
    for A in np.linspace(6, 102, 17)[::2]:

	db = connect('MC/T{}-{}.db'.format(T, int(A)))

	E = []
	for d in db.select():
            nCu = d.symbols.count('Cu')
            nPd = d.symbols.count('Pd')
	    E += [(d.nrg - ref['Cu'] * nCu - ref['Pd'] * nPd) / d.natoms]
	E = np.array(E)

        avg += [np.mean(E)]
        std += [np.std(E)]
        comp += [A/108.]

    avg = np.array(avg + [0])
    std = np.array(std + [0])
    comp = np.array(comp + [1.])

    def Margules(x, A, B, C, D):
	R = 8.31446   # J/mol/K
	temp = T      # K
	return (A + B*(x - (1 - x)) + C*(x - (1 - x))**2. + D*(x - (1 - x))**3.)*(1 - x)*x*R*temp

    from scipy.optimize import curve_fit
    x = np.linspace(0, 1, 100)
    p, _ = curve_fit(Margules, comp, avg)

    print T, p

    plt.plot(x, Margules(x, *p), color=c[i])
    plt.scatter(comp, avg, label=str(T) + ' K', color=c[i])
    ax.fill_between(comp, avg + std, avg - std, alpha=0.5, color=c[i])

plt.legend(loc='best')
plt.xlim(0, 1)
plt.xlabel('Cu$_{1-x}$Pd$_{x}$ composition (x)')
plt.ylabel('Heat of formation (eV/atom)')
plt.ylim(-0.12, 0)
plt.tight_layout()
plt.savefig('./images/gs-hull-3temp.png')
#+END_SRC

** Analysis of ATAT enumerated structures for ground state hull
#+caption: ATAT calculations for ground state hull calculated with DFT and NN. Errors included below in red.
#+label: fig-db6-cluster-expansion
[[./images/db6-cluster-expansion.png]]

The most poorly fit structure is included below in Figure ref:fig-poor-fit.

#+caption: Structure with the greatest error shown in Figure ref:fig-db6-cluster-expansion above.
#+label: fig-poor-fit
[[./images/atat-poorfit.png]]

#+BEGIN_SRC python :results silent
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np

db = connect('temp/db6.db')

ECu = db.get(['Cu=1', 'Pd=0'])
EPd = db.get(['Cu=0', 'Pd=1'])

C, Qe, Ne = [], [], []
for d in db.select(['atat']):
    nPd = d.symbols.count('Pd')
    nCu = d.symbols.count('Cu')

    C += [float(nPd) / (nPd + nCu)]
    Qe += [(d.nrg - nPd*EPd.nrg - nCu*ECu.nrg) / d.natoms]
    Ne += [(d.nnE - nPd*EPd.nnE - nCu*ECu.nnE) / d.natoms]

Qe = np.array(Qe)
Ne = np.array(Ne)

# View the most poorly fit structure
from ase.visualize import view
Err = abs(Ne - Qe)
i = list(Err).index(max(Err))
from ase.io import write
write('./images/atat-poorfit.png', db.get_atoms(i), show_unit_cell=2)

fig, ax = plt.subplots(2, sharex=True, figsize=(6, 4))
ax[0].scatter(C, Qe, color='k')
ax[0].scatter(C, Ne, color='b')
ax[1].scatter(C, Ne - Qe, color='r')
ax[0].set_xlim(0, 1)
ax[0].set_ylim(-0.12, 0.12)
ax[1].set_ylim(-0.15, 0.05)
ax[1].set_yticks(ax[1].get_yticks()[:-1])
ax[1].set_xlabel('Composition Cu$_{1-x}$Pd$_{x}$, ($x$)')
ax[0].set_ylabel('Heat of formation\n(eV/atom)')
ax[1].set_ylabel('Error\n(eV/atom)')
plt.tight_layout(h_pad=0.0)
plt.savefig('./images/db6-cluster-expansion.png')
#+END_SRC

** Error analysis for data included in the fit
#+caption: Neural network residual error to DFT (red) and alternate neural network (blue).
#+label: fig-db6-error
[[./images/db6-error.png]]

The first \approx 2000 calculations are included from the ATAT enumerated structures. These structures have "sharp" unit cells which have historically been difficult for Neural networks to fit to.

#+BEGIN_SRC python :results silent
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np

db = connect('temp/db6.db')

ECu = db.get(['Cu=1', 'Pd=0'])
EPd = db.get(['Cu=0', 'Pd=1'])

ID, C, dE, nndE = [], [], [], []
for d in db.select([]):
    nPd = d.symbols.count('Pd')
    nCu = d.symbols.count('Cu')

    ID += [d.id]
    C += [float(nPd) / (nPd + nCu)]
    dE += [(d.nnE - d.nrg) / d.natoms]
    nndE += [d.nndE / d.natoms]

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(6, 4))
ax[0].scatter(ID, dE, color='r')
ax[1].scatter(ID, nndE, color='b')

ax[0].set_xlim(0, max(ID))
ax[1].set_xlim(0, max(ID))
ax[0].set_xticks(ax[0].get_xticks()[1:])
ax[1].set_xticks(ax[1].get_xticks()[1:])

fig.autofmt_xdate()

ax[0].set_xlabel('Composition Cu$_{1-x}$Pd$_{x}$, ($x$)')
ax[1].set_xlabel('Composition Cu$_{1-x}$Pd$_{x}$, ($x$)')
ax[0].set_ylabel('Error (eV/atom)')
plt.tight_layout(w_pad=-0.1)
plt.savefig('./images/db6-error.png')
#+END_SRC

** Lowest energy configurations for ground state hull

[[./images/temp.png]]

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np

db = connect('temp/db6.db')

ECu = db.get(['Cu=1', 'Pd=0']).nrg
EPd = db.get(['Cu=0', 'Pd=1']).nrg

C, E = [], []
for d in db.select(['atat']):
    nPd = d.symbols.count('Pd')
    nCu = d.symbols.count('Cu')
    C += [float(nPd) / (nPd + nCu)]
    E += [(d.nrg - nPd*EPd - nCu*ECu) / d.natoms]
E = np.array(E)

d = {c:[] for c in sorted(set(C))}
for c, e in zip(C, E):
    d[c] += [e]

md = []
for c in sorted(d.keys()):
    md += [[c, min(d[c])]]
md = np.array(md)

gs = [0]
while gs[-1] != 32:
    slopes = []
    for c, e in md[gs[-1]+1:]:
	x = [md[gs[-1]][0], c]
	y = [md[gs[-1]][1], e]
        
	slopes += [np.polyfit(x, y, 1)[0]]
    gs += [gs[-1] + 1 + slopes.index(min(slopes))]

def Margules(x, A, B, C, D):
    R = 8.31446   # J/mol/K
    temp = 1.      # K
    return (A + B*(x - (1 - x)) + C*(x - (1 - x))**2. + D*(x - (1 - x))**3.)*(1 - x)*x*R*temp

from scipy.optimize import curve_fit
x = np.linspace(0, 1, 100)
p, _ = curve_fit(Margules, md.T[0], md.T[1])

fig, ax = plt.subplots(figsize=(6, 4))
ax.scatter(md.T[0], md.T[1], color='b')
ax.plot(x, Margules(x, *p), color='b')
ax.scatter(md[gs].T[0], md[gs].T[1], color='r')
lfits = []
for i, j in enumerate(md[gs].T[0][:-1]):
    fit = np.poly1d(np.polyfit(md[gs].T[0][i:i+2],
                               md[gs].T[1][i:i+2], 1))
    lfits += [fit]
    xtemp = np.linspace(md[gs].T[0][i], md[gs].T[0][i+1])
    ax.plot(xtemp, fit(xtemp), 'r-')
ax.set_xlim(0, 1)
ax.set_ylim(-0.12, 0)
ax.set_xlabel('Composition Cu$_{1-x}$Pd$_{x}$, ($x$)')
ax.set_ylabel('Heat of formation\n(eV/atom)')
plt.tight_layout()
plt.savefig('./images/temp.png')
#+END_SRC

#+RESULTS:

** MC simulations
*** Constructing the atoms objects
#+BEGIN_SRC python
from ase.lattice.cubic import FaceCenteredCubic as fcc
from ase.lattice.surface import surface
from ase.visualize import view
import numpy as np

for i, a in enumerate(np.linspace(3.634, 3.939, 5)[1:-1]):

    atoms = fcc('Cu', latticeconstant=a)
    for j in range(1, i+2):
	atoms[j].symbol = 'Pd'
    atoms = surface(atoms, (1, 1, 1), 5)
    atoms.center(vacuum=6., axis=2)
    atoms.set_pbc([1, 1, 0])

    index = [atom.index for atom in atoms if atom.position[2] < 10.]
    if M != None:
	for i in index:
	    atoms[i].symbol = M

    atoms *= (5, 5, 1)

    view(atoms)
#+END_SRC

*** Running MC on various 5 layer slabs
#+BEGIN_SRC python
import os
import numpy as np

cmd = ''
for M in ['Cu', 'Pd', 'None']:
    for i, a in enumerate(np.linspace(3.634, 3.939, 5)[1:-1]):
	script = """#!/usr/bin/env python
from ase.lattice.cubic import FaceCenteredCubic as fcc
from ase.lattice.surface import surface
import numpy as np
from ase.atoms import Atoms
import random
from ase.units import kB
from ase.db import connect

def main(atoms, dbname, T, steps):

    db = connect(dbname)

    # Setting up variables for Cannonical MC
    symbols = atoms.get_chemical_symbols()
    chem_bins = {{sym: [] for sym in set(symbols)}}

    for i, s in enumerate(symbols):
        if atoms[i].position[2] > 10.:
	    chem_bins[s] += [i]

    # Calculate the initial energy and store it
    nrg = atoms.get_potential_energy()

    # dummy = Atoms.copy(atoms)
    # db.write(dummy, nrg=nrg)

    # Perform MC steps
    attempt, success = 0, 0
    while success < steps:

        # First, choose two chemicals to swap
        sym1, sym2 = random.sample(chem_bins.keys(), 2)
        random.shuffle(chem_bins[sym1])
        ind1 = chem_bins[sym1][-1]

        random.shuffle(chem_bins[sym2])
        ind2 = chem_bins[sym2][-1]

        # Create new atoms object to test
        new_atoms = Atoms.copy(atoms)
        new_atoms.set_calculator(atoms.get_calculator())

        # Update the atoms object
        new_atoms[ind1].symbol, new_atoms[ind2].symbol = sym2, sym1

        # Calculate the energy of the new system
        new_nrg = new_atoms.get_potential_energy()

        # Stores energy in continuously growing list
        # potentially memory intensive, but faster than writing to disk
        if new_nrg < nrg:
            atoms = new_atoms
            nrg = new_nrg
	    chem_bins[sym2][-1] = ind1
	    chem_bins[sym1][-1] = ind2

            dummy = Atoms.copy(atoms)
            db.write(dummy, nrg=nrg)
            success += 1

        elif np.exp(-(new_nrg - nrg) / (kB * T)) > np.random.rand():
            atoms = new_atoms
            nrg = new_nrg
	    chem_bins[sym2][-1] = ind1
	    chem_bins[sym1][-1] = ind2

            dummy = Atoms.copy(atoms)
            db.write(dummy, nrg=nrg)
            success += 1

        attempt += 1

    return success/attempt

from amp import Amp

atoms = fcc('Cu', latticeconstant={1})
for j in range(1, {0}+2):
    atoms[j].symbol = 'Pd'
atoms = surface(atoms, (1, 1, 1), 5)
atoms.center(vacuum=6., axis=2)
atoms.set_pbc([1, 1, 0])

index = [atom.index for atom in atoms if atom.position[2] < 10.]
if '{2}' != 'None':
    for i in index:
	atoms[i].symbol = '{2}'

atoms *= (5, 5, 1)

atoms.set_calculator(Amp('/home-research/jboes/research/cluster-expansion/networks/db6/40-7-7-1/'))

main(atoms, '/home-research/jboes/research/cluster-expansion/MC-slab/T800-c{0}-b{2}.db', T=800, steps=4999)
""".format(int(i), float(a), M)

	name = 'MC-slab/run-T800-c{}-b{}.py'.format(int(i), M)
	cmd += 'bpsh 30 -m {} & '.format(name.replace('MC-slab', '.'))

	with open(name, 'w') as f:
	    f.write(script)
	os.chmod(name, 0755)

print(cmd)
#+END_SRC

#+RESULTS:
: bpsh 30 -m ./run-T800-c0-bCu.py & bpsh 30 -m ./run-T800-c1-bCu.py & bpsh 30 -m ./run-T800-c2-bCu.py & bpsh 30 -m ./run-T800-c0-bPd.py & bpsh 30 -m ./run-T800-c1-bPd.py & bpsh 30 -m ./run-T800-c2-bPd.py & bpsh 30 -m ./run-T800-c0-bNone.py & bpsh 30 -m ./run-T800-c1-bNone.py & bpsh 30 -m ./run-T800-c2-bNone.py & 

*** Analyzing surface compositions
**** Canonical 5 layer slab compositions
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
from ase.visualize import view
import matplotlib.pyplot as plt
from amp import Amp

calc = Amp('networks/db6/40-8-8-1/')

for i, a in enumerate(np.linspace(3.634, 3.939, 5)[1:-1]):
    
    for M in ['Cu', 'Pd', 'None']:
        fig, ax = plt.subplots(figsize=(4.5, 3))

	name = 'MC-slab/T800-c{}-b{}.db'.format(int(i), M)
	db = connect(name)

        C, c1, c2, c3 = [], [], [], []
        for d in db.select():
            
            pos, syms = d.positions, d.symbols
            l1 = [s for s, p in zip(syms, pos) if p[2] > 14]
            l2 = [s for s, p in zip(syms, pos) if 14 > p[2] > 12]
            l3 = [s for s, p in zip(syms, pos) if 12 > p[2] > 10]

            c1 += [l1.count('Pd') / 100.]
            c2 += [l2.count('Pd') / 100.]
            c3 += [l3.count('Pd') / 100.]
            C += [d.id]

        ax.plot(C, np.ones(len(C))*c1[0], 'k--')
        ax.plot(C, c1, 'r-', label='layer 1')
        ax.plot(C, c2, 'r--', label='layer 2')
        ax.plot(C, c3, 'r:', label='layer 3')
        ax.set_ylim(0, 1)
        ax.set_xlabel('Step')
        ax.set_ylabel(r'Composition\nCu$_{1-x}$Pd$_{x}$')
        ax.set_title('{} {}'.format(int(i), M))
        ax.legend(loc='best')
        plt.tight_layout()
        plt.savefig('./images/T800-c{}-b{}.png'.format(int(i), M))
        print('[[./images/T800-c{}-b{}.png]]'.format(int(i), M))
#+END_SRC

#+RESULTS:
: [[./images/T800-c0-bCu.png]]
: [[./images/T800-c0-bPd.png]]
: [[./images/T800-c0-bNone.png]]
: [[./images/T800-c1-bCu.png]]
: [[./images/T800-c1-bPd.png]]
: [[./images/T800-c1-bNone.png]]
: [[./images/T800-c2-bCu.png]]
: [[./images/T800-c2-bPd.png]]
: [[./images/T800-c2-bNone.png]]

**** Canonical 20 layer slab compositions
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
from ase.visualize import view
import matplotlib.pyplot as plt

for a in np.linspace(0, 100, 11)[1:-1]:
    fig, ax = plt.subplots(figsize=(4.5, 3))

    name = 'MC/SLAB-T800-Pd{}.db'.format(int(a))
    db = connect(name)

    C, c1, c2, c3 = [], [], [], []
    for d in db.select():
        pos, syms = d.positions, d.symbols
        l1 = [s for s, p in zip(syms, pos) if p[2] > 35.5]
        l2 = [s for s, p in zip(syms, pos) if 35.5 > p[2] > 33.1]
        l3 = [s for s, p in zip(syms, pos) if 33.1 > p[2] > 31]

        c1 += [l1.count('Pd') / 100.]
        c2 += [l2.count('Pd') / 100.]
        c3 += [l3.count('Pd') / 100.]
  
        C += [d.id]

    ax.plot(C, np.ones(len(C))*c1[0], 'k--')
    ax.plot(C, c1, 'r-', label='layer 1')
    ax.plot(C, c2, 'r--', label='layer 2')
    ax.plot(C, c3, 'r:', label='layer 3')
    ax.set_ylim(0, 1)
    ax.set_xlabel('Step')
    ax.set_ylabel(r'Composition\nCu$_{1-x}$Pd$_{x}$')
    plt.legend(loc='best')
    plt.tight_layout()
    plt.savefig('./images/T800-Pd{}.png'.format(int(a)))
    print('[[./images/T800-Pd{}.png]]'.format(int(a)))
#+END_SRC

#+RESULTS:
: [[./images/T800-Pd10.png]]
: [[./images/T800-Pd20.png]]
: [[./images/T800-Pd30.png]]
: [[./images/T800-Pd40.png]]
: [[./images/T800-Pd50.png]]
: [[./images/T800-Pd60.png]]
: [[./images/T800-Pd70.png]]
: [[./images/T800-Pd80.png]]
: [[./images/T800-Pd90.png]]

*** Analyzing surface energies
**** Canonical 5 layer slab compositions
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
from glob import glob
from amp import Amp
from ase.io import read

calc = Amp('networks/db6/40-8-8-1/')

db = connect('MC-slab/master.db')

for name in glob('MC-slab/T800-c*'):

    if name == 'MC-slab/T800-c2-bCu.db':
        continue

    db0 = connect(name)
    images = read(name, ':')
    basis = name[:-3].split('b')[-1]

    for i, atoms in enumerate(images):
    	keys = db0.get(i+1).key_value_pairs

    	atoms.set_calculator(calc)
    	nrg2 = atoms.get_potential_energy()

    	keys.update({'dE': float(nrg2 - keys['nrg']),
    		     'basis': basis})
    	atoms.set_calculator(None)
    	db.write(atoms, key_value_pairs=keys)
#+END_SRC

#+RESULTS:

** Smaller MC simulations for DFT compassion
#+BEGIN_SRC python
script = """#!/usr/bin/env python
from ase.lattice.cubic import FaceCenteredCubic as fcc
from ase.lattice.surface import surface
import numpy as np
from ase.atoms import Atoms
import random
from ase.units import kB
from ase.db import connect
from ase.constraints import FixAtoms


def main(atoms, dbname, T=800, steps=2499):

    db = connect(dbname)

    # Setting up variables for Cannonical MC
    symbols = atoms.get_chemical_symbols()
    chem_bins = {sym: [] for sym in set(symbols)}

    for i, s in enumerate(symbols):
        if atoms[i].position[2] > 8.5:
	    chem_bins[s] += [i]

    # Calculate the initial energy and store it
    nrg = atoms.get_potential_energy()

    dummy = Atoms.copy(atoms)
    db.write(dummy, nrg=nrg)

    # Perform MC steps
    attempt, success = 0, 0
    while success < steps:

        # First, choose two chemicals to swap
        sym1, sym2 = random.sample(chem_bins.keys(), 2)
        random.shuffle(chem_bins[sym1])
        ind1 = chem_bins[sym1][-1]

        random.shuffle(chem_bins[sym2])
        ind2 = chem_bins[sym2][-1]

        # Create new atoms object to test
        new_atoms = Atoms.copy(atoms)
        new_atoms.set_calculator(atoms.get_calculator())

        # Update the atoms object
        new_atoms[ind1].symbol, new_atoms[ind2].symbol = sym2, sym1

        # Calculate the energy of the new system
        new_nrg = new_atoms.get_potential_energy()

        # Stores energy in continuously growing list
        # potentially memory intensive, but faster than writing to disk
        if new_nrg < nrg:
            atoms = new_atoms
            nrg = new_nrg
	    chem_bins[sym2][-1] = ind1
	    chem_bins[sym1][-1] = ind2

            dummy = Atoms.copy(atoms)
            db.write(dummy, nrg=nrg)
            success += 1

        elif np.exp(-(new_nrg - nrg) / (kB * T)) > np.random.rand():
            atoms = new_atoms
            nrg = new_nrg
	    chem_bins[sym2][-1] = ind1
	    chem_bins[sym1][-1] = ind2

            dummy = Atoms.copy(atoms)
            db.write(dummy, nrg=nrg)
            success += 1

        attempt += 1

    return success/attempt

from amp import Amp

atoms = fcc('Cu', latticeconstant=3.7865)

# Turn 50% of the atoms into Pd
for j in range(1, 3):
    atoms[j].symbol = 'Pd'

atoms = surface(atoms, (1, 1, 1), 5)
atoms.center(vacuum=6., axis=2)

constraint = FixAtoms(mask=[atom.position[2] < 8.5 for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp('/home-research/jboes/research/cluster-expansion/networks/db6/40-7-7-1/'))

main(atoms, '/home-research/jboes/research/cluster-expansion/MC-slab/T800-Pd50.db')
"""

import os

name = 'MC-slab/run-T800-Pd50.py'
cmd = 'bpsh 30 -m {}'.format(name.replace('MC-slab', '.'))
print(cmd)

with open(name, 'w') as f:
    f.write(script)
os.chmod(name, 0755)
#+END_SRC

#+RESULTS: 
: bpsh 30 -m ./run-T800-Pd50.py

** Semi-Grand Canonical
TODO: This is unfinished, but will likely not lead anywhere useful.

#+BEGIN_SRC python
import numpy as np
from scipy.misc import derivative

temp = [700, 800, 900]
param = [[ -5.54064554e-05, 2.30584670e-05, 1.64597839e-05, -3.05319937e-05],
     [ -4.77314268e-05, 1.87985490e-05, 1.41441041e-05, -2.51913865e-05],
     [ -4.19286108e-05, 1.57230196e-05, 1.24622374e-05, -2.11836272e-05]]

def Margules(x, A, B, C, D, T):
    R = 8.31446   # J/mol/K
    return (A + B*(x - (1 - x)) + C*(x - (1 - x))**2. + D*(x - (1 - x))**3.)*(1 - x)*x*R*T

for P in param:
    for T in temp:
#+END_SRC
  
#+BEGIN_SRC python
from amp import Amp
from ase.lattice.cubic import FaceCenteredCubic as fcc
from ase.lattice.surface import surface
from ase.visualize import view

atoms = fcc('Cu', latticeconstant=3.7865)

# Turn 50% of the atoms into Pd
for j in range(1, 3):
    atoms[j].symbol = 'Pd'

atoms = surface(atoms, (1, 1, 1), 5)
atoms.center(vacuum=6., axis=2)
atoms *= (5, 5, 1)

view(atoms)

# atoms.set_calculator(Amp('/home-research/jboes/research/cluster-expansion/networks/db6/40-7-7-1/'))

# main(atoms, '/home-research/jboes/research/cluster-expansion/MC-slab/T800-Pd50.db')

import os
import numpy as np

cmd = ''
for M in ['Cu', 'Pd', 'None']:
    for i, a in enumerate(np.linspace(3.634, 3.939, 5)[1:-1]):
	script = """#!/usr/bin/env python
from ase.lattice.cubic import FaceCenteredCubic as fcc
from ase.lattice.surface import surface
import numpy as np
from ase.atoms import Atoms
import random
from ase.units import kB
from ase.db import connect

def main(atoms, dbname, T, steps):

    db = connect(dbname)

    # Setting up variables for Cannonical MC
    symbols = atoms.get_chemical_symbols()
    chem_bins = {{sym: [] for sym in set(symbols)}}

    for i, s in enumerate(symbols):
        if atoms[i].position[2] > 10.:
	    chem_bins[s] += [i]

    # Calculate the initial energy and store it
    nrg = atoms.get_potential_energy()

    # dummy = Atoms.copy(atoms)
    # db.write(dummy, nrg=nrg)

    # Perform MC steps
    attempt, success = 0, 0
    while success < steps:

        # First, choose two chemicals to swap
        sym1, sym2 = random.sample(chem_bins.keys(), 2)
        random.shuffle(chem_bins[sym1])
        ind1 = chem_bins[sym1][-1]

        random.shuffle(chem_bins[sym2])
        ind2 = chem_bins[sym2][-1]

        # Create new atoms object to test
        new_atoms = Atoms.copy(atoms)
        new_atoms.set_calculator(atoms.get_calculator())

        # Update the atoms object
        new_atoms[ind1].symbol, new_atoms[ind2].symbol = sym2, sym1

        # Calculate the energy of the new system
        new_nrg = new_atoms.get_potential_energy()

        # Stores energy in continuously growing list
        # potentially memory intensive, but faster than writing to disk
        if new_nrg < nrg:
            atoms = new_atoms
            nrg = new_nrg
	    chem_bins[sym2][-1] = ind1
	    chem_bins[sym1][-1] = ind2

            dummy = Atoms.copy(atoms)
            db.write(dummy, nrg=nrg)
            success += 1

        elif np.exp(-(new_nrg - nrg) / (kB * T)) > np.random.rand():
            atoms = new_atoms
            nrg = new_nrg
	    chem_bins[sym2][-1] = ind1
	    chem_bins[sym1][-1] = ind2

            dummy = Atoms.copy(atoms)
            db.write(dummy, nrg=nrg)
            success += 1

        attempt += 1

    return success/attempt

from amp import Amp

atoms = fcc('Cu', latticeconstant={1})
for j in range(1, {0}+2):
    atoms[j].symbol = 'Pd'
atoms = surface(atoms, (1, 1, 1), 5)
atoms.center(vacuum=6., axis=2)
atoms.set_pbc([1, 1, 0])

index = [atom.index for atom in atoms if atom.position[2] < 10.]
if '{2}' != 'None':
    for i in index:
	atoms[i].symbol = '{2}'

atoms *= (5, 5, 1)

atoms.set_calculator(Amp('/home-research/jboes/research/cluster-expansion/networks/db6/40-7-7-1/'))

main(atoms, '/home-research/jboes/research/cluster-expansion/MC-slab/T800-c{0}-b{2}.db', T=800, steps=4999)
""".format(int(i), float(a), M)

	name = 'MC-slab/run-T800-c{}-b{}.py'.format(int(i), M)
	cmd += 'bpsh 30 -m {} & '.format(name.replace('MC-slab', '.'))

	with open(name, 'w') as f:
	    f.write(script)
	os.chmod(name, 0755)

print(cmd)
#+END_SRC

#+RESULTS:


* Relaxation dependence
** various compositions
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from jasp import *
from ase.constraints import FixAtoms
from jbtools.gilgamesh import compile_trajectory, makedb
from ase.io.trajectory import Trajectory
JASPRC['queue.ppn'] = 8
JASPRC['queue.walltime'] = '24:00:00'



def get_composition(atoms, basis=None):
    ''' Acquire the chemical composition of an atoms object

    Returns: a dictionary of atoms and their compositions
    dictionary sorted by atomic number
    '''

    symbols = atoms.get_chemical_symbols()
    count = len(symbols)

    # Collect the symbol and count of each atom type
    S = OrderedDict()

    for symbol in symbols:

        if symbol in S.keys():
            S[symbol] += 1.0
        else:
            S[symbol] = 1.0

    # Convert to composition
    for key, val in S.iteritems():
        S[key] = val / count

    if basis:
        if basis in S.keys():
            return S[basis]
        else:
            return 0.0
    else:
        return S

db = connect('traj/cfg2x2-5layer-2fix.db')

for d in db.select():

    atoms = db.get_atoms(d.id)

    constraint = FixAtoms(mask=[atom.position[2] < 8.5 for atom in atoms])
    atoms.set_constraint(constraint)

    wd = 'DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg={}'.format(d.id)

    with jasp(wd,
    	      xc='PBE',
    	      encut=400,
    	      kpts=(7, 7, 1),
    	      ibrion=2,
    	      isif=2,
    	      nsw=40,
    	      ediff=1e-5,
    	      atoms=atoms) as calc:

	calc.get_required_memory()
	atoms = calc.get_atoms()
        nrg = atoms.get_potential_energy()

	compile_trajectory(calc)
	traj = Trajectory('out.traj')
	n = len(traj)

	for i, atoms in enumerate(traj):

	    makedb(calc,
		   atoms=atoms,
		   dbname='~/research/cluster-expansion/temp/cfg2x2-5layer-2fix.db',
		   keys={'traj': int(n-i-1), 'comp': float(get_composition(atoms, 'Pd'))})
#+END_SRC

#+RESULTS:
#+begin_example
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=56
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=83
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=96
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=126
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=217
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=239
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=242
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=246
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=247
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=249
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=253
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=263
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=265
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=267
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=268
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=273
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=275
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=331
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=354
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=355
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=356
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=357
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=358
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=359
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=360
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=361
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=362
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=363
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=364
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=365
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=366
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=367
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=368
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=369
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=370
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=371
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=372
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=373
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=374
VaspSubmitted: DFT/surf=fcc/host=CuPd/lattice=3.787/type=cfg2x2-5layer-2fix/cfg=375
#+end_example

** 50/50 composition
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from jasp import *
from ase.constraints import FixAtoms
from jbtools.gilgamesh import compile_trajectory, makedb
from ase.io.trajectory import Trajectory
JASPRC['queue.ppn'] = 8
JASPRC['queue.walltime'] = '24:00:00'

db = connect('MC-slab/T800-Pd50.db')

def get_composition(atoms, basis=None):
    ''' Acquire the chemical composition of an atoms object

    Returns: a dictionary of atoms and their compositions
    dictionary sorted by atomic number
    '''

    symbols = atoms.get_chemical_symbols()
    count = len(symbols)

    # Collect the symbol and count of each atom type
    S = OrderedDict()

    for symbol in symbols:

        if symbol in S.keys():
            S[symbol] += 1.0
        else:
            S[symbol] = 1.0

    # Convert to composition
    for key, val in S.iteritems():
        S[key] = val / count

    if basis:
        if basis in S.keys():
            return S[basis]
        else:
            return 0.0
    else:
        return S

for d in db.select():
    if not d.id % 5:

	atoms = db.get_atoms(d.id)

	constraint = FixAtoms(mask=[atom.position[2] < 8.5 for atom in atoms])
	atoms.set_constraint(constraint)

	wd = 'DFT/surf=fcc/host=CuPd/lattice=3.787/type=T800-Pd50/cfg={}'.format(d.id)

	with jasp(wd,
		  xc='PBE',
		  encut=400,
		  kpts=(7, 7, 1),
		  ibrion=2,
		  isif=2,
		  nsw=40,
		  ediff=1e-5,
		  atoms=atoms) as calc:

	    calc.get_required_memory()
	    atoms = calc.get_atoms()
	    nrg = atoms.get_potential_energy()

	    compile_trajectory(calc)
	    traj = Trajectory('out.traj')
	    n = len(traj)

	    for i, atoms in enumerate(traj):

		makedb(calc,
		       atoms=atoms,
		       dbname='~/research/cluster-expansion/temp/T800-Pd50.db',
		       keys={'traj': int(n-i-1), 'comp': float(get_composition(atoms, 'Pd'))})
#+END_SRC

#+RESULTS:

[[./images/temp.png]]

[[./images/temp-static.png]]

[[./images/temp-relax.png]]

[[./images/temp-diff.png]]


#+BEGIN_SRC python
from ase.db import connect
import numpy as np
from ase.visualize import view

db = connect('temp/T800-Pd50.db')
db0 = connect('MC-slab/T800-Pd50.db')

cfgs = {}
nnsE = []
for d in db.select():

    if d.cfg not in cfgs.keys():
        cfgs[d.cfg] = 0
        nn = db0.get(d.cfg)
        nnsE += [nn.nrg / nn.natoms]

    if d.traj > cfgs[d.cfg]:
        cfgs[d.cfg] = d.traj

# This does not change
sym = [1 if x == 'Pd' else -1 for x in d.symbols]

sE, rE, dE = [], [], []
l1, l2, l3 = [], [], []
for k, v in cfgs.iteritems():
    d = db.get(['cfg={}'.format(k), 'traj={}'.format(int(v))])
    sE += [d.energy / d.natoms]

    d = db.get(['cfg={}'.format(k), 'traj=0'])
    rE += [d.energy / d.natoms]

    dE += [rE[-1] - sE[-1]]

    l1 += [sum([sym[i] for i, p in enumerate(d.positions.T[2]) if p > 14.]) / 4.]
    l2 += [sum([sym[i] for i, p in enumerate(d.positions.T[2]) if 14. > p > 12.]) / 4.]
    l3 += [sum([sym[i] for i, p in enumerate(d.positions.T[2]) if 12. > p > 10.]) / 4.]

dE = np.array(dE)
rE = np.array(rE)[dE < -0.0001]
sE = np.array(sE)[dE < -0.0001]
nnsE = np.array(nnsE)[dE < -0.0001]
CFGS = np.array(cfgs.keys())[dE < -0.0001]

l1 = np.array(l1)[dE < -0.0001]
l2 = np.array(l2)[dE < -0.0001]
l3 = np.array(l3)[dE < -0.0001]
dE = dE[dE < -0.001]

labels = ['Cu', 'Pd']

import matplotlib.pyplot as plt
fig, ax = plt.subplots(1, 4, sharey=True, sharex=True, figsize=(8, 4))
ax[0].scatter(l1, dE)
ax[1].scatter(l2, dE)
ax[2].scatter(l3, dE)
ax[3].scatter((l1 - l2) / 2., dE)
ax[0].set_xlim(-1, 1)

ax[0].set_ylim(-0.015, 0.)
ax[0].set_xlabel('Composition of\nlayer 1')
ax[1].set_xlabel('Composition of\nlayer 2')
ax[2].set_xlabel('Composition of\nlayer 3')
ax[3].set_xlabel('Ratio of\nlayers 1 and 2')
ax[0].set_ylabel('Energy differences (eV/atom)')
plt.xticks([-1, 1], labels)
plt.margins(0.1)
plt.tight_layout(w_pad=0.)
plt.savefig('./images/temp-diff.png')

fig, ax = plt.subplots(1, 4, sharey=True, sharex=True, figsize=(8, 4))
ax[0].scatter(l1, sE)
ax[1].scatter(l2, sE)
ax[2].scatter(l3, sE)
ax[3].scatter((l1 - l2) / 2., sE)
ax[0].set_xlim(-1, 1)
ax[0].set_ylim(-4.39, -4.34)
ax[0].set_xlabel('Composition of\nlayer 1')
ax[1].set_xlabel('Composition of\nlayer 2')
ax[2].set_xlabel('Composition of\nlayer 3')
ax[3].set_xlabel('Ratio of\nlayers 1 and 2')
ax[0].set_ylabel('Static energy (eV/atom)')
plt.xticks([-1, 1], labels)
plt.tight_layout(w_pad=0.)
plt.savefig('./images/temp-static.png')

fig, ax = plt.subplots(1, 4, sharey=True, sharex=True, figsize=(8, 4))
ax[0].scatter(l1, rE)
ax[1].scatter(l2, rE)
ax[2].scatter(l3, rE)
ax[3].scatter((l1 - l2) / 2., rE)
ax[0].set_xlim(-1, 1)
ax[0].set_ylim(-4.39, -4.34)
ax[0].set_xlabel('Composition of\nlayer 1')
ax[1].set_xlabel('Composition of\nlayer 2')
ax[2].set_xlabel('Composition of\nlayer 3')
ax[3].set_xlabel('Ratio of\nlayers 1 and 2')
ax[0].set_ylabel('Relaxed energy (eV/atom)')
plt.xticks([-1, 1], labels)
plt.tight_layout(w_pad=0.)
plt.savefig('./images/temp-relax.png')

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(5, 5))
ax[0].plot(CFGS, sE, 'ro')
ax[0].plot(CFGS, rE, 'bo')
ax[1].plot(CFGS, dE, 'ko')

ax[1].set_xlabel('MC step')
ax[0].set_ylabel('Energy (eV/atom)')
ax[1].set_ylabel('Energy differences\n(eV/atom)')

plt.tight_layout()
plt.savefig('./images/temp.png')

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(CFGS, nnsE - sE, 'ko')
ax.plot([0, max(CFGS)], [0, 0], 'k--')
ax.set_xlabel('MC step')
ax.set_ylabel('NN prediction error\n(eV/atom)')
plt.tight_layout()
plt.savefig('./images/temp-error.png')
#+END_SRC

#+RESULTS:

[[./images/temp-error.png]]


NEED TO ENUMERATE

[70 2145 2150 2180  135  260 2325  295  300 2425 1200 1255 1365 1375 1485 1560 1625 1650 1880]

#+BEGIN_SRC python
from itertools import product
from ase.lattice.surface import fcc111
from asap3 import EMT
from ase import Atoms
from ase.db import connect
from amp.utilities import hash_image
import numpy as np
from ase.constraints import FixAtoms

a = np.linspace(3.634, 3.939, 3)

base = fcc111('Cu', size=(3, 3, 5), vacuum=6.0, a=a[1])
natoms = [a.index for a in base if a.tag <= 2]
metals = ['Cu', 'Pd']

for n in range(18):
    if n % 2:
        base[n].symbol = 'Pd'



with connect('traj/unique-9atoms-2layer.db') as db:
    nrgs = set()
    for i, c in enumerate(product(metals, repeat=len(natoms))):
        atoms0 = Atoms.copy(base)
        for j, s in enumerate(natoms):
            atoms0[s].symbol = c[j]

        atoms = Atoms.copy(atoms0)
        atoms.set_calculator(EMT())
        nrg = round(atoms.get_potential_energy(), 3)
        atoms.set_calculator(None)

        constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
        atoms.set_constraint(constraint)

        if nrg not in nrgs:
            nrgs.add(nrg)
            db.write(atoms)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from jasp import *
from ase.io import read
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 8

for i, atoms in enumerate(ase.io.read('traj/unique-9atoms-2layer.db', ':')):
    wd = 'DFT/surf=fcc/host=CuPd/lattice=3.787/type=unique-9atom-2layer/cfg={}'.format(i)

    with jasp(wd,
	      xc='PBE',
	      encut=400,
	      kpts=(4, 4, 1),
	      ibrion=2,
	      isif=2,
	      nsw=50,
	      atoms=atoms) as calc:

	calc.get_required_memory()
	calc.calculate()
#+END_SRC

TODO:
- evidence of NN accuracy
-- via DFT
-- via second NN
- Think on how to determine accuracy of fully relaxed calculations

- Next we would like to try an MC where the atoms are allowed to be changed from Cu to Pd.

- This requires the chemical potentials from the bulk at the desired bulk composition.

- I am unsure of the best method for calculating the chemical potential.

-- My idea is to use the fitted Marguels equation of the bulk MC to predict chemical potential at the temperature of the surface MC. Is this a valid approach?

* Presentation work
** Determine time requirements on calculations with full relaxation
#+BEGIN_SRC python
from timeit import timeit
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import numpy as np

t, rt = [], []
n = np.array(range(1, 8))
natoms = 27 * n**3

for i in n:
    script = '''from amp import Amp
from ase.db import connect

db = connect('temp/bulk-3x3.db')
atoms = db.get_atoms(['a=3.634', 'config=1000'])

calc = Amp('networks/db5/40-7-7-1/')

atoms *= ({0}, {0}, {0})
atoms.set_calculator(calc)
atoms.get_potential_energy()
'''.format(i)
    t += [float(timeit(script, number=1)) / 60.]

    rscript = '''from amp import Amp
from ase.optimize import BFGS
from ase.db import connect

db = connect('temp/bulk-3x3.db')
atoms = db.get_atoms(['a=3.634', 'config=1000'])

calc = Amp('networks/db5/40-7-7-1/')

atoms *= ({0}, {0}, {0})
atoms.set_calculator(calc)
dyn = BFGS(atoms)
dyn.run(fmax=0.02)
atoms.get_potential_energy()
'''.format(i)
    rt += [float(timeit(rscript, number=1)) / 60.]

fit = np.poly1d(np.polyfit(natoms, t, 2))
rfit = np.poly1d(np.polyfit(natoms, rt, 2))
print(fit)
print(rfit)

x = np.linspace(natoms[0], natoms[-1])

plt.figure()
plt.plot(natoms, t, 'bo')
plt.plot(x, fit(x), 'b-')

plt.plot(natoms, rt, 'ro')
plt.plot(x, rfit(x), 'r-')

blue_patch = mpatches.Patch(color='blue', label='Single calculation time')
red_patch = mpatches.Patch(color='red', label='Full relaxation calculation time')

plt.legend(handles=[blue_patch, red_patch])

plt.xlabel('number of atoms')
plt.ylabel('Calculation time (min)')
plt.tight_layout()
plt.savefig('images/amp-calc-time-bulk.png')
#+END_SRC

#+RESULTS:
:            2
: 1.858e-08 x + 0.0001521 x + 0.09639

[[./images/amp-calc-time-bulk.png]]

** Analysis of ATAT CuPd
Needed to restart the calculations for 

#+BEGIN_SRC python
from ase.db import connect
from jasp import *
from glob import glob
JASPRC['queue.ppn'] = 8

db = connect('DFT/ion_relax/data.db')

if os.path.exists('DFT/ion_relax/data.db'):
    os.unlink('DFT/ion_relax/data.db')

for wd in glob('DFT/ion_relax/*/'):

    ready = False
    try:
	with jasp(wd) as calc:
	    atoms = calc.get_atoms()
	    nrg = atoms.get_potential_energy()
	    ready = True
    except(ValueError, AttributeError):
	pass

    if ready:
	db.write(atoms, key_value_pairs={'cfg': int(wd.split('/')[-2])})
#+END_SRC

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp
import numpy as np

calc = Amp('networks/db6/40-7-7-1/')

db = connect('DFT/ion_relax/data.db')

DFT, NN = [], []
for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc)
    energy = atoms.get_potential_energy()
    db.update(d.id, nnrg=float(energy))
#+END_SRC

** Evidence of NN accuracy using second NN
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
from ase.visualize import view
import matplotlib.pyplot as plt

db = connect('MC-slab/master.db')

E, dE, ID = [], [], []
for d in db.select('id<2401'):
    dE += [d.dE / d.natoms]
    ID += [d.id]
    E += [d.nrg / d.natoms]
dE = np.array(dE)
E = np.array(E) - E[0]

plt.figure(figsize=(6, 4))
plt.plot(ID, dE, 'k-', label='Difference')
plt.plot(ID, E, 'b-', label='NN1 predicitons')
plt.plot(ID, dE + E, 'r-', label='NN2 predicitons')
plt.xlabel('MC step')
plt.ylabel('Energy (eV/atom)')
plt.legend(loc=1, fontsize=10)
plt.tight_layout()
plt.savefig('./images/MC-energy-diff-NN.png')
#+END_SRC

#+RESULTS:

[[./images/MC-energy-diff-NN.png]]

** Evidence of NN accuracy using DFT
#+BEGIN_SRC python
from ase.db import connect
from ase.visualize import view
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np

calc = Amp('networks/db6/40-7-7-1/')

db = connect('temp/cfg2x2-5layer-2fix.db')

DFT, NN = [], []
for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc)
    energy = atoms.get_potential_energy()
    db.update(d.id, nrg=float(energy))
#+END_SRC

** Relaxation energies for Cu and Pd structures
#+BEGIN_SRC python
from ase.db import connect
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

db = connect('temp/cfg2x2-5layer-2fix.db')

E = []
for d in db.select('comp=0.2'):
    E += [d.energy / d.natoms]

E = np.array(E) - E[0]

E2 = []
for d in db.select('cfg=396'):
    E2 += [d.energy/ d.natoms]

E2 = np.array(E2) - E2[0]

plt.figure(figsize=(6, 4))
plt.plot(range(len(E)), E, '-', color='orange', label='Relaxation of mostly Cu slab')
plt.plot(range(len(E2)), E2, 'b-', label='Relaxation of mostly Pd slab')
plt.xlabel('Relaxation step')
plt.ylabel('Energy (eV/atom)')
plt.legend(loc='best', fontsize=10)
plt.tight_layout()
plt.savefig('./images/DFT-2x2-relaxations.png')
#+END_SRC

#+RESULTS:

[[./images/DFT-2x2-relaxations.png]]

* Predictions in bulk CuPd
The majority of work previous to this point has shown that there is /likely/ no way to correctly predict top layer segregation behavior with the GGA-PBE functional.

In an attempt to salvage some of the NN, we will return to fitting to the bulk bcc to fcc phase transition to produce a first principles phase diagram.

This section is meant to be *dynamic*, i.e. the code will be continuously updated as new fits become available.

** Fit to BCT transition pathway from FCC to BCC
#+caption: BCT pathway from FCC to BCC unit cell. Labels other than DFT indicate various NN frameworks used for the fit.
#+label: fig-bct-path
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/bct-path.png]]

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.db import connect
from glob import glob

db = connect('data-pathway.db')

col = ['k', 'b', 'g', 'm', 'r']
framework = [6, 7, 8, 9]
E = []

ca, images = [], []
for d in db.select('gga=None'):
    atoms = db.get_atoms(d.id)

    ca += [d.ca]
    nrg = [d.total_energy / d.natoms]

    for n in framework:
        calc = Amp('./networks/db6/40-{0}-{0}-1'.format(n))
        atoms.set_calculator(calc)
        nrg += [atoms.get_potential_energy() / d.natoms]

    E += [nrg]

E = np.array(E).T

fig, ax = plt.subplots(figsize=(6, 4))
for i, y in enumerate(E):
    ax.plot(ca, y, color=col[i])

ax.set_xlabel('c/a ratio')
ax.set_ylabel('Potential energy (eV/atom)')
ax.set_xlim(ca[0], ca[-1])

ax.annotate('bcc', xy=(ca[0], E[0][0]),
            xytext=(ca[0]+0.05, E[0][0]-0.01),
            arrowprops=dict(arrowstyle="->",
                            connectionstyle="arc3"),
            size=20,
        )
ax.annotate('fcc', xy=(ca[-1], E[0][-1]),
            xytext=(ca[-1]-0.1, E[0][-1]+0.001),
            arrowprops=dict(arrowstyle="->",
                            connectionstyle="arc3"),
            size=20,
        )

ax.legend(labels=['DFT'] + framework, loc='best')
plt.tight_layout()
plt.savefig('./images/bct-path.png')
#+END_SRC

#+RESULTS:

** 3D BCT space around FCC and BCC phase transition
#+caption: 3D Minimum energy pathway of fcc to bcc transition through bct geometry space.
#+label: fig-bct-surface
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/bct-surface.png]]

*** Creating the data for 3D map of BCT space
First, we take the /a/ parameters from the converged PBE calculations. The /ca/ parameter is defined as 1.0 and sqrt(2) for bcc and fcc, respectively. Then, we take these points and generate a mesh around them. Too visualize the region around the fcc and bcc phase, we also expand the mesh to include 1/4th of the difference between the /a/ and /ca/ parameters on either side.

#+BEGIN_SRC python
from ase.lattice.tetragonal import CenteredTetragonal as bct
import numpy as np
from jasp import *
from jbtools.gilgamesh import makedb
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.mem'] = '1GB'

# Configuration '3' for fcc
with jasp('DFT/bulk=fcc/config=3/xc=PBE/gga=None') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

# This is the 'a' parameter from the calculation
afcc = np.linalg.norm(cell[0])

# Configuration '3' for bcc i.e. B2
with jasp('DFT/bulk=bcc/config=3/xc=PBE/gga=None') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

# This is the 'a' parameter from the calculation
abcc = np.linalg.norm(cell[0])

da = abcc - afcc
a0 = np.linspace(afcc - da/4., abcc + da/4., 31)

dca = np.sqrt(2) - 1
ca0 = np.linspace(1 - dca/4., np.sqrt(2) + dca/4., 31)

for a in a0:
    for ca in ca0:

        # Generate structure based on sample points
        atoms = bct('Cu', latticeconstant={'a': a, 'c/a': ca})
        atoms[1].symbol = 'Pd'

        wd = 'DFT/bulk=bct/config=3/pathway=False/a={}/ca={}'.format(a, ca)

        with jasp(wd,
                  xc='PBE',
                  encut=400,
                  kpts=(12, 12, 12),
                  nsw=0,
                  ediff=1e-6,
                  atoms=atoms) as calc:
            try:
                calc.calculate()
                makedb(calc,
                       dbname='/home-research/jboes/research/cluster-expansion/temp/bct.db')
            except(VaspQueued, VaspSubmitted):
                pass
#+END_SRC

*** BCT phase space
#+BEGIN_SRC python
from ase.db import connect
from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt
from matplotlib import cm
import numpy as np
from ase.lattice.tetragonal import CenteredTetragonal as bct
from jasp import *
from jbtools.gilgamesh import makedb
JASPRC['queue.walltime'] = '24:00:00'
JASPRC['queue.ppn'] = 4

db = connect('temp/bct.db')

A, C = [], []
for d in db.select('pathway=False'):
    A += [d.a]
    C += [d.ca]

A = np.unique(A)
C = np.unique(C)

X, Y = np.meshgrid(A, C)

Z = np.zeros(X.shape)
for i, a in enumerate(A):
    for j, c in enumerate(C):
	Z[j][i] = db.get(['a={}'.format(a),
			  'ca={}'.format(c)]).energy


mZ = []
for i, c in enumerate(C[5:-5]):
    data = Z[i+5, :]
    j = data.tolist().index(min(data))
    mZ += [[A[j], c, min(data)]]

mZ = np.array(mZ).T

# Trim energies above this threshhold
rng = [-9.2, -9.0]
drng = (rng[1] - rng[0]) / 4.
Z[Z > rng[1]] = np.nan

fig = plt.figure(figsize=(8, 6))
ax = fig.gca(projection='3d')

cset = ax.contourf(X, Y, Z,
                   zdir='z',
                   offset=rng[0] - drng,
                   cmap=cm.autumn,
                   vmin=rng[0],
                   vmax=rng[1])

ax.plot_surface(X, Y, Z,
                rstride=1,
                cstride=1,
                cmap=cm.autumn,
                linewidth=0,
                vmin=rng[0] - drng,
                vmax=rng[1] + drng)

ax.scatter(mZ[0][1:-1], mZ[1][1:-1], mZ[2][1:-1], c='k')

ax.plot([A[5], A[5]], [C[-5], C[-5]], [rng[0]-drng, mZ[2][-1]], 'go-', zorder=99)
ax.text(A[5], C[-5], mZ[2][-1]+drng, 'fcc', color='g', zorder=99, size='large')

ax.plot([A[-5], A[-5]], [C[5], C[5]], [rng[0]-drng, mZ[2][0]], 'bo-', zorder=99)
ax.text(A[-5], C[5], mZ[2][0]+drng, 'bcc', color='b', zorder=99, size='large')

ax.set_xlabel('a')
ax.set_xlim(min(A), max(A))
ax.set_ylabel('c/a')
ax.set_ylim(min(C), max(C))
ax.set_zlabel('Potential energy (eV)')
ax.set_zlim(rng[0]-drng, rng[1]+drng)
plt.tight_layout()
plt.savefig('./images/bct-phase.png')

for i, ca in enumerate(mZ[1]):

    atoms = bct('Cu', latticeconstant={'a': mZ[0][i], 'c/a': ca})
    atoms[1].symbol = 'Pd'

    wd = 'DFT/bulk=bct/config=3/pathway=True/ca={}'.format(ca)

    with jasp(wd,
              xc='PBE',
              encut=400,
              kpts=(12, 12, 12),
              nsw=10,
              ibrion=2,
              isif=7,
              ediff=1e-6,
              atoms=atoms) as calc:
        try:
            calc.get_required_memory()
            atoms = calc.get_atoms()
            nrg = atoms.get_potential_energy()
	    makedb(calc,
		   dbname='/home-research/jboes/research/cluster-expansion/temp/bct.db')
        except(VaspQueued, VaspSubmitted):
            pass
#+END_SRC

#+RESULTS:

[[./images/bct-phase.png]]


*** Relaxed pathway data
In order to create a higher resolution image of the minimum energy pathways through BCT space, we now relax the lowest energy /ca/ configurations in _volume only_.

* Alternative PP for predicting segregation
PBE is known to incorrectly predict the dilute limit segregation behavior, and this is carried over to the non-dilute limit as well.

Here we explore other pseudo-potentials predictions of dilute limit segregation for CuPd.

These studies are performed using the new vasp.py, which is different enough from jasp that these calculations should probably be kept separate.

** Bulk calculations
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.cubic import FaceCenteredCubic as fcc
from ase.visualize import view
VASPRC['queue.ppn'] = 16
VASPRC['queue.mem'] = '2GB'

#hy = ['hf', 'hse03', 'hse06', 'pbe0', 'b3lyp']
#xcs = [xc for xc in Vasp.xc_defaults.keys() if xc not in hy]
xcs = ['hse06']
elements = ['Cu', 'Pd']

calcs = []
for e1 in elements:

    atoms = fcc(e1,
		directions=[[0, 1, 1],
			    [1, 0, 1],
			    [1, 1, 0]],
		size=(3, 3, 3))

    for xc in xcs:
       for e2 in elements:
            atoms[0].symbol = e2

            wd = 'DFT/type=dilute-limit/bulk={}@{}/xc={}'.format(e2, e1, xc)
            calc = Vasp(wd,
                        xc=xc,
                        kpts=[3, 3, 3],
                        encut=400,
                        ibrion=2,
                        ediff=1e-6,
                        isif=3,
                        nsw=30,
                        atoms=atoms)

            atoms = calc.get_atoms()
            nrg = atoms.get_potential_energy()
            print('{:<12}: {}@{} {:>8}'.format(xc, e2, e1, nrg))
#+END_SRC

#+RESULTS:
: /home-research/jboes/research/cluster-expansion/DFT/type=dilute-limit/bulk=Cu@Cu/xc=hse06 submitted: 1400319.gilgamesh.cheme.cmu.edu
: hse06       : Cu@Cu     None
: /home-research/jboes/research/cluster-expansion/DFT/type=dilute-limit/bulk=Pd@Cu/xc=hse06 submitted: 1400320.gilgamesh.cheme.cmu.edu
: hse06       : Pd@Cu     None
: /home-research/jboes/research/cluster-expansion/DFT/type=dilute-limit/bulk=Cu@Pd/xc=hse06 submitted: 1400321.gilgamesh.cheme.cmu.edu
: hse06       : Cu@Pd     None
: /home-research/jboes/research/cluster-expansion/DFT/type=dilute-limit/bulk=Pd@Pd/xc=hse06 submitted: 1400322.gilgamesh.cheme.cmu.edu
: hse06       : Pd@Pd     None

** Surf calculations
#+BEGIN_SRC python
from vasp.vasprc import VASPRC
from vasp import Vasp
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms
VASPRC['queue.ppn'] = 12
VASPRC['queue.walltime'] = '24:00:00'

hy = ['hf', 'hse03', 'hse06', 'pbe0', 'b3lyp', 'am05', 'optb88-vdw', 'm06l']
xcs = [xc for xc in Vasp.xc_defaults.keys() if xc not in hy]
elements = ['Cu', 'Pd']

calcs = []
for e1 in elements:
    for xc in xcs:

        # Determine bulk lattice constant
        calc = Vasp('DFT/type=dilute-limit/bulk={0}@{0}/xc={1}'.format(e1, xc))
        bulk = calc.get_atoms()
        a = (4 * bulk.get_volume() / len(bulk))**(1 / 3.)

        # Create surface image
        atoms = fcc111(e1, size=(3, 3, 5), vacuum=6.0, a=a)
        constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
        atoms.set_constraint(constraint)

        # Introduce impurities
        for e2 in elements:
            atoms[40].symbol = e2

            try:
                wds = 'DFT/type=dilute-limit/surf={}@{}/xc={}'.format(e2, e1, xc)
                calc = Vasp(wds,
                            xc=xc,
                            kpts=[3, 3, 1],
                            encut=400,
                            ibrion=2,
                            isif=2,
                            nsw=60,
                            atoms=atoms)
                calc.set_memory()
                atoms = calc.get_atoms()
                nrg = atoms.get_potential_energy()
                print('{:<12}: {}@{} {:>8}'.format(xc, e2, e1, nrg))
            except(RuntimeError):
                print(calc.directory)
#+END_SRC

** Calculations
E = dE^{Surf} - dE^{Bulk}
dE^{X} = E^{X}_{impurity} - E^{X}_{clean}

#+BEGIN_SRC python :results raw
from ase.db import connect
from vasp import Vasp
from ase.visualize import view
from jbtools.utils import get_composition

hy = ['hf', 'hse03', 'hse06', 'pbe0', 'b3lyp', 'am05', 'optb88-vdw', 'm06l']
xcs = [xc for xc in Vasp.xc_defaults.keys() if xc not in hy]
elements = ['Pd', 'Cu']

images = []
E = {}
for xc in xcs:
    E[xc] = []
    for e2 in elements:
        dE = []
        for s in ['surf', 'bulk']:

	    for e1 in elements:
                wd = 'DFT/type=dilute-limit/{}={}@{}/xc={}'.format(s, e1, e2, xc)

                calc = Vasp(wd)
                if e1 == e2:
                    cl = calc.potential_energy
                    atoms = calc.get_atoms()
                else:
                    im = calc.potential_energy
                    atoms = calc.get_atoms()

                comp = get_composition(atoms, basis='Pd')

            dE += [im - cl]
        E[xc] += [dE[0] - dE[1]]
print('|xc|Cu@Pd|Pd@Cu|')
print('|-')
for k, v in E.iteritems():
    ECu, EPd = v
    print('|{}|{:.3f}|{:.3f}|'.format(k, ECu, EPd))
#+END_SRC

#+RESULTS:
| xc          | Cu@Pd |  Pd@Cu |
|-------------+-------+--------|
| pbe         | 0.075 | -0.227 |
| lda         | 0.071 | -0.302 |
| revpbe      | 0.079 | -0.202 |
| optpbe-vdw  | 0.037 | -0.167 |
| tpss        | 0.070 | -0.346 |
| optb86b-vdw | 0.032 | -0.199 |
| rpbe        | 0.082 | -0.199 |
| revtpss     | 0.086 | -0.387 |
| vdw-df2     | 0.029 | -0.097 |
| pbesol      | 0.069 | -0.263 |
| beef-vdw    | 0.032 | -0.163 |

* Constructing a db for bulk calculations ONLY
** Assemble all calculations into one database
This pull all of the bulk calculations into a single master database.

The ATAT calculations are giving me trouble and need to be pruned.

This will takes some time, so we construct a database without them for now.

#+BEGIN_SRC python
from ase.db import connect
from jasp.utils import vasp_p
from glob import iglob
from jasp import *
from jbtools.gilgamesh import makedb, compile_trajectory
from ase.io.trajectory import Trajectory
import sys
import os
JASPRC['queue.ppn'] = 8

db = '~/research/cluster-expansion/database/db0-bulk.db'

if os.path.exists(db):
    os.unlink(db)

cwd = os.getcwd()

for f in iglob('DFT/bulk=*/'):
    print(f)
    for r, d, f in os.walk(f):
        if 'OUTCAR' in f and 'XDATCAR' in f and 'error' not in f:
            print r
            try:
                with jasp(r) as calc:

                    compile_trajectory(calc)
                    traj = Trajectory('out.traj')
                    n = len(traj)

                    for i, atoms in enumerate(traj):
                        makedb(calc,
                               atoms=atoms,
                               dbname=db,
                               keys={'traj': int(n-i-1)})
            except:
                print(sys.exc_info()[0], r)
                os.chdir(cwd)
#+END_SRC

** Convert a percentage to train_set
10% of calculations need to be converted to training set calculations to predict overfitting.

#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

ids = []
with connect('database/db0-bulk.db') as db:
    for d in db.select():
	if 'ATAT' not in d.key_value_pairs.keys():
	    ids += [d.id]

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
n_train = int(round(len(ids) * 0.9))
train_samples = random.sample(ids, n_train)
valid_samples = set(ids) - set(train_samples)

with connect('networks/db0-bulk/data.db') as db0:
    for i in train_samples:
        d = db.get(i)
        keys = d.key_value_pairs
        keys.update({'train_set': True})
        db0.write(d, key_value_pairs=keys)

    for i in valid_samples:
        d = db.get(i)
        keys = d.key_value_pairs
        keys.update({'train_set': False})
        db0.write(d, key_value_pairs=keys)
#+END_SRC

The update feature seems to end in an error at the moment. Currently, it is easier to use the code above to write and entirely new database than it is to use the update feature.

DEPRECATED:
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

os.chdir('networks/db0-bulk/')
with connect('data.db') as db:
    n = db.count()
    n_train = int(round(n * 0.9))
    ids =  np.array(range(n)) + 1

    # This will sudo-randomly select 10% of the calculations
    # Which is useful for reproducing our results.
    random.seed(256)
    train_samples = random.sample(ids, n_train)
    valid_samples = set(ids) - set(train_samples)

    db.update(ids=train_samples, train_set=True)
    db.update(ids=valid_samples, train_set=False)
#+END_SRC

** Training the NN
This code initialize training of the NN for various

#+BEGIN_SRC python
from ase.db import connect
import os
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork

os.chdir('networks/db0-bulk/')
with connect('data.db') as db:
    images = []
    for d in db.select('train_set=True'):
	atoms = db.get_atoms(d.id)
	del atoms.constraints
	images += [atoms]

os.chdir('40-8-8-1')

print('Begin training')
# calc = Amp(label="./",
#            dblabel="../",
#            descriptor=Behler(cutoff=7.0),
#            regression=NeuralNetwork(hiddenlayers=(2, 7)))

calc = Amp(load='./initial-parameters.json',
           label='./',
           dblabel='../')

calc.train(images,
           data_format='db',
           cores=4,
           energy_goal=0.001,
           force_goal=None,
           extend_variables=False)
#+END_SRC

** Adding NN energies to database
Again, it is simpler to create a new database than it is to update the existing database.

#+BEGIN_SRC python
from amp import Amp
from ase.db import connect

calc = Amp('networks/db0-bulk/40-8-8-1/checkpoint-parameters.json')
calc2 = Amp('networks/db0-bulk/40-7-7-1/checkpoint-parameters.json')

db = connect('networks/db0-bulk/data.db')
with connect('temp/db0-bulk.db') as db0:
    for d in db.select():
        atoms = db.get_atoms(d.id)

	atoms.set_calculator(calc)
	nrg = atoms.get_potential_energy()

	atoms.set_calculator(calc2)
	dE = atoms.get_potential_energy() - nrg

        keys = d.key_value_pairs
        keys.update({'nnE': nrg, 'nndE': dE})

	db0.write(d, key_value_pairs=keys)
#+END_SRC

#+RESULTS: 

** Analysis of the results

[[./images/db0-bulk-rmse.png]]

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from ase.visualize import view

db = connect('temp/db0-bulk.db')

ID, dE = [], []
for d in db.select():
    dE += [abs(d.nnE - d.energy) / d.natoms]
    ID += [d.id]

th = 0.01
dE = np.array(dE)
ID = np.array(ID)
outliers = ID[dE > th]
print(outliers)
RMSE = np.sqrt(sum(dE**2.) / len(dE))

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(range(len(dE)), dE, 'bo')
ax.plot(ID[dE > th], dE[dE > th], 'ro', ms=5)
ax.set_xlim([0, len(dE)])
x0, x1 = ax.get_xlim()
y0, y1 = ax.get_ylim()
ax.text((x1-x0)*0.8 + x0, (y1-y0)*0.8 + y0,
        'RMSE: {:.2e}'.format(RMSE), ha='right')
ax.set_xlabel('Calculation ID')
ax.set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./images/db0-bulk-rmse.png')
#+END_SRC

#+RESULTS:
: [ 1899 11855]


* Surface calculations
#+BEGIN_SRC python
from itertools import product
from ase.lattice.surface import fcc111
from asap3 import EMT
from ase import Atoms
from ase.db import connect
from ase.visualize import view

atoms = fcc111('Cu', size=(2, 2, 5), vacuum=6.0, a=3.7865)
natoms = [a.index for a in atoms if a.index > 11]
metals = ['Cu', 'Pd']

for i in [1, 2, 5, 6, 8, 11, 12, 15]:
    atoms[i].symbol = 'Pd'

nrgs = set()
with connect('traj/unique-2x2-2layer.db') as db:
    for i, c in enumerate(product(metals, repeat=len(natoms))):
	atoms0 = Atoms.copy(atoms)
	for j, s in enumerate(natoms):
	    atoms0[s].symbol = c[j]

	atoms = Atoms.copy(atoms0)
	atoms.set_calculator(EMT())
	nrg = round(atoms.get_potential_energy(), 6)
	atoms.set_calculator(None)

	if nrg not in nrgs:
	    nrgs.add(nrg)
	    db.write(atoms)
#+END_SRC

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from jasp import *
from ase.constraints import FixAtoms
from jbtools.gilgamesh import compile_trajectory, makedb
from ase.io.trajectory import Trajectory
from jbtools.utils import get_composition
from ase.visualize import view
JASPRC['queue.ppn'] = 8
JASPRC['queue.walltime'] = '24:00:00'

db = connect('traj/unique-2x2-2layer.db')
for d in db.select():

    atoms = db.get_atoms(d.id)

    constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
    atoms.set_constraint(constraint)

    wd = 'DFT/surf=fcc/host=CuPd/lattice=3.787/type=unique-2x2-2layer/cfg={}'.format(d.id)

    with jasp(wd,
    	      xc='PBE',
    	      encut=400,
    	      kpts=(6, 6, 1),
    	      ibrion=2,
    	      isif=2,
    	      nsw=40,
    	      ediff=1e-5,
    	      atoms=atoms) as calc:

    	# calc.get_required_memory()
    	atoms = calc.get_atoms()
        # nrg = atoms.get_potential_energy()

    	compile_trajectory(calc)
    	traj = Trajectory('out.traj')
    	n = len(traj)

    	for i, atoms in enumerate(traj):

    	    makedb(calc,
    		   atoms=atoms,
    		   dbname='~/research/cluster-expansion/temp/unique-2x2-2layer.db',
    		   keys={'traj': int(n-i-1), 'comp': float(get_composition(atoms, 'Pd'))})
#+END_SRC

#+RESULTS:
: VaspNotFinished: DFT/surf=fcc/host=CuPd/lattice=3.787/type=unique-2x2-2layer/cfg=77

#+BEGIN_SRC python
from ase.db import connect
import numpy as np
import matplotlib.pyplot as plt

db = connect('temp/unique-2x2-2layer.db')

EPd = -140.8705 / 27.
ECu = -100.7039 / 27.

C, N, c1, c2, cfgs = [], [], [], [], {}
for d in db.select():

    nPd = d.comp * d.natoms
    nCu = 20 - nPd
    nrg = d.energy - EPd*nPd - ECu*nCu

    if d.cfg not in cfgs.keys():
        cfgs[d.cfg] = [[d.traj, nrg]]

	pos, syms = d.positions, d.symbols
	l1 = [s for s, p in zip(syms, pos) if p[2] > 14]
	l2 = [s for s, p in zip(syms, pos) if 14 > p[2] > 12]

	c1 += [l1.count('Pd') / 4.]
	c2 += [l2.count('Pd') / 4.]
	N += [d.id]
        C += [d.comp]

    else:
        cfgs[d.cfg] += [[d.traj, nrg]]

tf, ti = [], []
for k, v in cfgs.iteritems():
    tf += [np.array(v).T[1][-1]]
    ti += [np.array(v).T[1][0]]

ti = np.array(ti)
tf = np.array(tf)
td = tf - ti

fig, ax = plt.subplots(3, 3, sharex=True, figsize=(5, 6))
# Plotting the data
ax[0, 0].plot(c1, ti, 'bo')
ax[0, 1].plot(c2, ti, 'bo')
ax[0, 2].plot(C, ti, 'bo')
ax[0, 0].text(0.1, 3.7, 'Initial', color='blue')

ax[1, 0].plot(c1, tf, 'ro')
ax[1, 1].plot(c2, tf, 'ro')
ax[1, 2].plot(C, tf, 'ro')
ax[1, 0].text(0.1, 3.7, 'Relaxed', color='red')

ax[2, 0].plot(c1, td, 'ko')
ax[2, 1].plot(c2, td, 'ko')
ax[2, 2].plot(C, td, 'ko')
ax[2, 0].text(0.1, -0.55, 'Diff')

# Plotting the data
for i in range(3):
    ax[i, 1].yaxis.set_ticklabels([])
    ax[i, 2].yaxis.set_ticklabels([])

# Labels for axis
ax[0, 0].set_ylabel('$\Delta$H (eV/atom)')
ax[1, 0].set_ylabel('$\Delta$H (eV/atom)')
ax[2, 0].set_ylabel('$\Delta$$\Delta$H (eV/atom)')
ax[2, 0].set_xlabel('Layer 1\ncomposition')
ax[2, 1].set_xlabel('Layer 2\ncomposition')
ax[2, 2].set_xlabel('Overall\ncomposition')

# Limits on the data
ax[0, 0].set_ylim(1.8, 4)
ax[0, 1].set_ylim(1.8, 4)
ax[0, 2].set_ylim(1.8, 4)

ax[1, 0].set_ylim(1.8, 4)
ax[1, 1].set_ylim(1.8, 4)
ax[1, 2].set_ylim(1.8, 4)

ax[2, 0].set_ylim(-0.6, 0)
ax[2, 1].set_ylim(-0.6, 0)
ax[2, 2].set_ylim(-0.6, 0)

plt.xticks([0, 0.5, 1], ['Cu', 0.5, 'Pd'])
plt.tight_layout(w_pad=0, h_pad=0)
plt.savefig('./images/Cu50Pd50-segregation-2x2slab.png')
#+END_SRC

#+RESULTS:

[[./images/Cu50Pd50-segregation-2x2slab.png]]
