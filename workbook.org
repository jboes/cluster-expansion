* ATAT
** Setting up calculations
*** Initializing the files
#+BEGIN_SRC python :results silent
import numpy as np
from subprocess import call

# This code is used to get a better starting point for lattice constant
lattice = np.array([3.631, 3.712, 3.792, 3.872, 3.953])
rad = 1 / (2*np.sqrt(2)) * lattice
scale = rad[2] / rad[-1]

call(["makelat", "-s={0}".format(scale), "Cu,Pd", "fcc,bcc"])

script = '''[INCAR]
ENCUT = 400
NSW = 50
IBRION = 2
ISIF = 7
KPPRA = 2500
EDIFF = 1e-6
GGA = PS
USEPOT = PAWPBE
'''

with open('vasp.wrap', 'w') as f:
    f.write(script)
#+END_SRC

*** Binary alloy calculations
*** fcc
#+BEGIN_SRC python :results silent
from os import system, chdir
from os.path import exists
from time import sleep

N = 10

chdir('./CuPd_fcc')
system('maps -t=0.25 &')
for n in range(N):
    open('ready', 'w').close()
    while exists('ready'):
        sleep(0.1)
open('stop', 'w').close()
#+END_SRC

#+BEGIN_SRC python :results silent
from subprocess import call
from os import chdir

chdir('./CuPd_fcc')
call(["foreachfile", "wait", "run_atat_vasp.py"])
#+END_SRC

*** bcc
#+BEGIN_SRC python :results silent
from os import system, chdir
from os.path import exists
from time import sleep

N = 10

chdir('./CuPd_bcc')
system('maps -t=0.25 &')
for n in range(N):
    open('ready', 'w').close()
    while exists('ready'):
        sleep(0.1)
open('stop', 'w').close()
#+END_SRC

#+BEGIN_SRC python :results silent
from subprocess import call
from os import chdir

chdir('./CuPd_bcc')
call(["foreachfile", "wait", "run_atat_vasp.py"])
#+END_SRC

** Checking cluster expansion progress
*** CuPd fcc
#+BEGIN_SRC python
from subprocess import call

call(["atatstatus.py", "CuPd_fcc"])
#+END_SRC

#+RESULTS:
#+begin_example
Fit not up to date
    0:   energy = -4.0214
    1:   energy = -5.8350
    2:   energy = -10.0318
    3:   energy = -10.0449
    4:   energy = -13.9792
    5:   energy = -15.7919
    6:   energy = -14.1422
    7:   energy = -15.8687
    8:   energy = -14.0352
    9:   energy = -15.8523
   10:   energy = -17.9918
   11:   energy = -19.7291
   12:   energy = -21.6136
   13:   energy = -18.1387
   14:   energy = -20.0568
   15:   energy = -21.7531
   16:   energy = -18.1619
   17:   energy = -21.7823
   18:   energy = -18.2653
   19:   energy = -20.1122
   20:   energy = -21.7827
   21:   energy = -18.1469
   22:   energy = -19.9558
   23:   energy = -21.7161
   24:   energy = -18.0163
   25:   energy = -19.8097
   26:   energy = -21.6629
   27:   energy = -18.3046
   28:   energy = -21.8114
   37:   energy = -24.1672
   39:   energy = -25.8991
   40:   energy = -27.5631
   41:   energy = -22.2577
   42:   energy = -24.2132
   44:   energy = -27.5951
   46:   energy = -24.1920
   47:   energy = -23.8940
   49:   energy = -25.7091
   50:   energy = -27.5124
   53:   energy = -23.6418
   54:   energy = -25.8268
   56:   energy = -27.4268
   63:   energy = -31.7197
   70:   energy = -31.7452
   74:   energy = -28.3136
   77:   energy = -30.0401
   78:   energy = -31.7967
   84:   energy = -30.0419
   95:   energy = -31.7234
   98:   energy = -28.2037
  102:   energy = -31.8128
  104:   energy = -33.4273
  119:   energy = -31.7661
  140:   energy = -34.1757
  142:   energy = -35.9704
  174:   energy = -37.5647
  230:   energy = -34.0250
  234:   energy = -35.7792
  274:   energy = -39.8346
  276:   energy = -39.8679
  438:   energy = -38.3428
  446:   energy = -39.9947
  502:   energy = -38.3249
  505:   energy = -41.9561
  545:   energy = -38.2419
  548:   energy = -40.1003
  552:   energy = -39.9547
  955:   energy = -46.0056
 9808:   energy = -39.2919
 9992:   energy = -61.9444
#+end_example
    
*** CuPd bcc
#+BEGIN_SRC python
from subprocess import call

call(["atatstatus.py", "CuPd_bcc"])
#+END_SRC

#+RESULTS:
#+begin_example
Fit not up to date
    0:   energy = -3.9769
    1:   energy = -5.7884
    2:   energy = -9.8877
    3:   energy = -10.0998
    4:   energy = -7.7146
    5:   energy = -8.4585
    6:   energy = -14.1047
    7:   energy = -15.7319
    8:   energy = -13.9517
    9:   energy = -15.6574
   10:   energy = -17.7374
   11:   energy = -19.4663
   12:   energy = -21.3528
   13:   energy = -18.0715
   14:   energy = -19.6778
   15:   energy = -21.5013
   16:   energy = -18.0797
   17:   energy = -19.9108
   18:   energy = -21.5214
   19:   energy = -18.1146
   20:   energy = -21.5709
   21:   energy = -17.9217
   22:   energy = -19.7344
   23:   energy = -21.4618
   24:   energy = -17.9091
   25:   energy = -21.5236
   26:   energy = -18.1295
   27:   energy = -19.7810
   28:   energy = -21.4997
   29:   energy = -13.0591
   31:   energy = -16.3437
   34:   energy = -12.7813
   35:   energy = -22.0440
   36:   energy = -24.2140
   37:   energy = -23.5896
   38:   energy = -25.8306
   39:   energy = -25.4102
   40:   energy = -27.3142
   41:   energy = -22.0452
   45:   energy = -21.8694
   46:   energy = -23.8320
   47:   energy = -23.6712
   48:   energy = -25.5460
   49:   energy = -25.4622
   50:   energy = -27.2273
   51:   energy = -22.0702
   53:   energy = -23.8848
   54:   energy = -25.7058
   55:   energy = -25.5577
   56:   energy = -27.2860
   60:   energy = -29.8335
   81:   energy = -26.0306
   90:   energy = -28.2950
   93:   energy = -29.6533
   95:   energy = -31.5346
  105:   energy = -25.6394
  112:   energy = -32.9307
  116:   energy = -29.2618
  130:   energy = -28.0172
  134:   energy = -31.3237
  441:   energy = -39.7619
  479:   energy = -38.4438
  494:   energy = -38.4328
  581:   energy = -38.4466
  603:   energy = -38.4733
  618:   energy = -38.4510
 1098:   energy = -40.2134
 1273:   energy = -41.9288
 1721:   energy = -48.5707
 2237:   energy = -48.5666
#+end_example
   

* DFT
** CuPd fcc and bcc '3' configuration
#+BEGIN_SRC python :results silent
from jasp import *
from ase.io import read
JASPRC['queue.walltime'] = '24:00:00'

# Run for fcc and bcc
for lbl in ['fcc', 'bcc']:

    # Get the CuPd structure for fcc and bcc from ATAT
    # Configuration '3'
    atoms = read('CuPd_{0}/3/CONTCAR'.format(lbl))

    # Will run these calculations on PBEsol and PBE
    for gga in ['PS', 'None']:

        with jasp('DFT/bulk={0}/config=3/xc=PBE/gga={1}'.format(lbl, gga),
                  xc='PBE',
                  gga='{0}'.format(gga),
                  encut=400,
                  kpts=(12, 12, 12),
                  nsw=10,
                  ibrion=2,
                  isif=7,
                  ediff=1e-8,
                  atoms=atoms) as calc:
            try:
                calc.calculate()
            except(VaspQueued, VaspSubmitted):
                pass
#+END_SRC

** fcc to fcc transition through bct geometry
*** data generation
#+BEGIN_SRC python
from ase.lattice.tetragonal import CenteredTetragonal as bct
import numpy as np
from ase.visualize import view
from jbutil import makedb
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

# Configuration '3' for fcc
with jasp('DFT/bulk=fcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

# This is the 'a' parameter from the calculation
afcc = np.linalg.norm(cell[0])

# Configuration '3' for bcc i.e. B2
with jasp('DFT/bulk=bcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

# This is the 'a' parameter from the calculation
abcc = np.linalg.norm(cell[0])


print '     fcc', '           bcc'
print 'a:   {0:1.3f}  {1:1.3f}'.format(afcc, abcc)
print 'c/a: {0:1.3f}  {1:1.3f}'.format(np.sqrt(2), 1.0)

# Create a list of sample points
ca0 = np.linspace(0.9, 1.5, 31)
ca0 = np.append(ca0, [np.sqrt(2)])
a0 = np.linspace(2.5, 3.1, 31)
a0 = np.append(a0, [afcc, abcc])

for a in a0:

    for ca in ca0:

        # Generate structure based on sample points
        atoms = bct('Cu', latticeconstant={'a': a, 'c/a': ca})
        atoms[1].symbol = 'Pd'

        wd = 'DFT/bulk=bct/config=3/a={0}/ca={1}/xc=PBE/gga=PS'.format(a, ca)

        with jasp(wd,
                  xc='PBE',
                  gga='PS',
                  encut=400,
                  kpts=(12, 12, 12),
                  ibrion=-1,
                  ediff=1e-8,
                  atoms=atoms) as calc:
            try:
                calc.calculate()
            except(VaspQueued, VaspSubmitted):
                print wd, 'Queued'
#+END_SRC

#+RESULTS:
#+begin_example
     fcc           bcc
a:   2.64179025643 2.96063403586
c/a: 1.41421356237 1.0
[ 0.9    0.92   0.94   0.96   0.98   1.     1.02   1.04   1.06   1.08   1.1
  1.12   1.14   1.16   1.18   1.2    1.22   1.24   1.26   1.28   1.3    1.32
  1.34   1.36   1.38   1.4    1.42   1.44   1.46   1.48   1.5    1.414]
[ 2.5    2.52   2.54   2.56   2.58   2.6    2.62   2.64   2.66   2.68   2.7
  2.72   2.74   2.76   2.78   2.8    2.82   2.84   2.86   2.88   2.9    2.92
  2.94   2.96   2.98   3.     3.02   3.04   3.06   3.08   3.1    2.642
  2.961]
#+end_example

*** data visualization
#+caption: 3D Minimum energy pathway of fcc to bcc transition through bct geometry space
#+label: fig-3d-cupd-min
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/3D-bcc-pathway.png]]

#+BEGIN_SRC python
from ase.lattice.tetragonal import CenteredTetragonal as bct
from ase.db import connect
from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt
from matplotlib import cm
from jasp import *
from jbutil import makedb
JASPRC['queue.walltime'] = '24:00:00'

# Retrive the data
db = connect('data.db')
A, C = [], []
E = {}
for d in db.select([]):

    if d.a not in E.keys():
        E[d.a] = {}
    if d.ca not in E[d.a].keys():
        E[d.a][d.ca] = d.total_energy

    A.append(d.a)
    C.append(d.ca)

with jasp('DFT/bulk=fcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

    efcc = atoms.get_potential_energy()
    afcc = np.linalg.norm(cell[0])

with jasp('DFT/bulk=bcc/config=3/xc=PBE/gga=PS') as calc:
    atoms = calc.get_atoms()
    cell = atoms.get_cell()

    ebcc = atoms.get_potential_energy()
    abcc = np.linalg.norm(cell[0])

uA = np.unique(A)
uC = np.unique(C)
X, Y = np.meshgrid(uA, uC)
Z = np.zeros(X.shape)

for i, a in enumerate(uA):
    for j, c in enumerate(uC):
        Z[j][i] = E[a][c]

fccZ, bccZ = [], []
eminZ = []
cminZ = []
aminZ = []

for i, c in enumerate(uC[5:-5]):
    data = Z[i+5, :]
    ind = data.tolist().index(min(data))

    eminZ.append(min(data))
    cminZ.append(c)
    aminZ.append(uA[ind])


rng = [ebcc, -10.2]

Z[Z > rng[1]] = np.nan

fig = plt.figure(figsize=(8, 6))
ax = fig.gca(projection='3d')
CM = cm.autumn

cset = ax.contourf(X, Y, Z, zdir='z', offset=-10.8, cmap=CM, vmin=rng[0], vmax=rng[1])

ax.plot_surface(X, Y, Z,
                rstride=1,
                cstride=1,
                cmap=CM,
                linewidth=0,
                vmin=rng[0],
                vmax=rng[1])


ax.scatter(aminZ[1:-1], cminZ[1:-1], eminZ[1:-1], c='k')

ax.plot([afcc, afcc], [np.sqrt(2), np.sqrt(2)], [-10.8, eminZ[-1]], 'go-', zorder=99)
ax.text(afcc, np.sqrt(2), eminZ[-1]+0.01, 'fcc', color='g', zorder=99, size='large')

ax.plot([abcc, abcc], [1.0, 1.0], [-10.8, eminZ[0]], 'bo-', zorder=99)
ax.text(abcc, 1.0, eminZ[0]+0.01, 'bcc', color='b', zorder=99, size='large')

ax.set_xlabel('a')
ax.set_xlim(2.4, 3.2)
ax.set_ylabel('c/a')
ax.set_ylim(0.8, 1.6)
ax.set_zlabel('Total energy (eV)')
ax.set_zlim(-10.8, rng[1])
plt.tight_layout()
plt.savefig('images/3D-bcc-pathway.png')

for gga in ['PS', 'None']:

    for i, ca in enumerate(cminZ):

        atoms = bct('Cu', latticeconstant={'a': aminZ[i], 'c/a': ca})
        atoms[1].symbol = 'Pd'

        wd = 'DFT/bulk=bct/config=3/pathway=True/ca={0}/xc=PBE/gga={1}'.format(ca, gga)

        with jasp(wd,
                  xc='PBE',
                  gga='{0}'.format(gga),
                  encut=400,
                  kpts=(12, 12, 12),
                  nsw=20,
                  ibrion=2,
                  isif=7,
                  ediff=1e-9,
                  atoms=atoms) as calc:
            try:
                calc.calculate()

            except(VaspQueued, VaspSubmitted):
                print wd, 'Queued'
#+END_SRC

#+caption: 2D Minimum energy pathway of fcc to bcc transition through bct geometry space
#+label: fig-2d-cupd-min
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/diffusion-path.png]]

#+BEGIN_SRC python :results silent
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np

# Retrive the data
db = connect('data-pathway.db')

C, E = [], []
for d in db.select(['gga=PS']):
    C.append(d.ca)
    E.append(d.total_energy)


E = np.array(E) - E[0]

plt.figure()
plt.plot(C, E, 'ko-', ms=4)

plt.scatter(C[0], E[0], s=30, c='b', zorder=99)
plt.text(C[0]-0.003, E[0]+0.001, 'bcc', color='b', ha='left', size='large')

plt.scatter(C[-1], E[-1], s=30, c='g', zorder=99)
plt.text(C[-1]+0.003, E[-1]+0.001, 'fcc', color='g', ha='right', size='large')

plt.xlabel('c/a')
plt.ylabel('Energy relative to bcc phase (eV)')
plt.xlim(0.995, np.sqrt(2)+0.005)
plt.ylim(-0.001, E[-1]+0.003)
plt.tight_layout()
plt.savefig('images/diffusion-path.png')
#+END_SRC

* Ground states
** ground state figure
#+caption: Ground state hull of CuPd for fcc and bcc phases
#+label: fig-cupd-gs
#+attr_latex: :width 4in :placement [H]
#+attr_org: :width 400
[[./images/groundstate.png]]

#+BEGIN_SRC python : results silent
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

config = ['fcc', 'bcc']
color = ['b', 'r']

plt.figure()
plt.plot([0.0, 1.0], [0, 0], 'k--')

for i, cfg in enumerate(config):

    with open('CuPd_{0}/gs.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        GS, EGS, CGS = [], [], []

        for line in lines:
            # Composition, DFT energy, Fit energy, Configuration
            x, y, z, c = line.split()

            CGS.append(x)
            EGS.append(y)
            GS.append(c)

    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        C, E = [], []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            x, y, z, e, w, c = line.split()

            C.append(x)
            E.append(y)

    plt.scatter(C, E, c='k', s=15)
    plt.plot(CGS, EGS, c='{0}'.format(color[i]), marker='o', label='{0}'.format(cfg))
    for j, gs in enumerate(GS[1:-1]):
        plt.text(CGS[1:-1][j], float(EGS[1:-1][j])-0.004,
                 '{0}'.format(gs),
                 color='{0}'.format(color[i]),
                 va='top', ha='center',
                 zorder=99)

plt.legend(loc='best')
plt.xlim(0, 1)
plt.xlabel('Composition (Pd)')
plt.ylabel('Heat of formation (eV/atom)')
plt.ylim(-0.15, 0.01)
plt.tight_layout()
plt.savefig('./images/groundstate.png')
#+END_SRC

** EOS for all structures
#+BEGIN_SRC python
import numpy as np
from jasp import *
JASPRC['queue.walltime'] = '24:00:00'

# For fcc and bcc configurations
for cfg in ['fcc', 'bcc']:

    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        # Begin a list of configurations
        C = []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            x, y, z, e, w, c = line.split()

            # We only need the configuration
            C.append(c)

    # Fraction of equilibrium lattice constant to be calculated.
    frac_eos = np.append(np.linspace(0.85, 1.15, 61), np.linspace(1.2, 2.0, 17))

    # This array represents all types of deformations we want to calculate.
    # The nominclature being used is as follows:
    # [ x , a , c ]
    # [ a , y , b ]
    # [ c , b , z ]
    # where a, b, and c are the xy, yz, and zx tensors, respectively.
    deformations = [['xyz', frac_eos]]

    for j, c in enumerate(C):

        for dfm in deformations:

            for frac in dfm[1]:

                # This code retrieves the optimized volume and atom positions from the ISIF=3 calculation.
                with jasp('CuPd_{0}/{1}'.format(cfg, c)) as calc:
                    atoms = calc.get_atoms()
                    cell0 = atoms.get_cell()
                    k1, k2, k3 = calc.input_params['kpts']

                dis = {}
                for vector in ['x', 'y', 'z', 'a', 'b', 'c']:
                    dis[vector] = 1.0

                    if vector in dfm[0]:
                        dis[vector] = frac

                delta = np.array([[dis['x']      , 0.5 * (dis['a'] - 1), 0.5 * (dis['c'] - 1)],
                                  [0.5 * (dis['a'] - 1), dis['y']      , 0.5 * (dis['b'] - 1)],
                                  [0.5 * (dis['c'] - 1), 0.5 * (dis['b'] - 1), dis['z']      ]])

                # This line adjusts the cell volume by the fraction specified above. 
                # The atoms are scaled accordingly inside the new unit cell.
                atoms.set_cell(np.dot(cell0, delta), scale_atoms=True)
                wd = 'DFT/bulk={0}/config={1}/strain={2}/factor={3}/xc=PBE/gga=PS'.format(cfg, c, dfm[0], frac)

                try:
                    with jasp(wd,
                              xc='PBE',
                              gga='PS',
                              kpts=(k1, k2, k3),
                              encut=400,
                              ibrion=-1,
                              ediff=1e-8,
                              atoms=atoms) as calc:
                        try:
                            calc.calculate()
                        except(VaspSubmitted, VaspQueued):
                            print wd, 'Queued'
                except(VaspNotFinished):
                    print wd, 'VaspNotFinished'
#+END_SRC


* Analysis tools
** database generation
#+BEGIN_SRC python
from jasp import *
import os
from ase.io.trajectory import Trajectory
from jbutil import makedb

for r, d, f in os.walk('cluster-expansion/DFT/bulk=bct/config=3/pathway=False'):
    if f:
        try:
            with jasp(r) as calc:
                try:
                    if not os.path.exists('out.traj'):
                        xd = xdat2traj('out.traj', calc=calc)
                        xd.convert()

                    traj = Trajectory('out.traj')
                    atoms = traj[-1]

                    makedb(calc,
                           atoms=atoms,
                           dbname='~/research/cluster-expansion/networks/db0-bct/data.db')

                except(VaspQueued, VaspSubmitted):
                    print 'In Queue', r
                except(ValueError):
                    print 'ValueError', r
                except(IndexError):
                    print 'IndexError', r
        except(VaspNotFinished):
            print 'VaspNotFinished', r
#+END_SRC

#+RESULTS:
: VaspNotFinished DFT/bulk=fcc/config=505/strain=xyz/factor=1.85/xc=PBE/gga=PS
: VaspNotFinished DFT/bulk=fcc/config=505/strain=xyz/factor=1.9/xc=PBE/gga=PS
: VaspNotFinished DFT/bulk=fcc/config=505/strain=xyz/factor=2.0/xc=PBE/gga=PS
: VaspNotFinished DFT/bulk=fcc/config=28/strain=xyz/factor=1.85/xc=PBE/gga=PS
: IndexError DFT/bulk=bcc/config=3/strain=xyz/factor=2.0/xc=PBE/gga=PS
: VaspNotFinished DFT/bulk=bcc/config=603/strain=xyz/factor=1.95/xc=PBE/gga=PS

** database manipulation
#+BEGIN_SRC python
from ase.db import connect
import os

db0 = connect('networks/db0/data.db')
data = db0.select(['gga=PS', 'ediff!=1e-9'])

wd = 'networks/db0-PS/'

if not os.path.exists(wd):
    os.makedirs(wd)

db = connect(wd + '/data.db')

for d in data:
    db.write(d,
             key_value_pairs=d.key_value_pairs)
#+END_SRC

#+RESULTS:

** network training
#+BEGIN_SRC python
from neural.bp import BPNeural
import os

os.chdir('networks/db0-PS')

calc = BPNeural()  #  label defines the prefix for a file

calc.train('data.db',
           energy_goal=1e-5,
           force_goal=5e-4)
#+END_SRC

#+RESULTS:
: Warning: Desired error not necessarily achieved due to precision loss.
:          Current function value: 298.548133
:          Iterations: 2764
:          Function evaluations: 3211
:          Gradient evaluations: 3200

* Neural
** GS energy prediction
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from jasp import *
from neural.bp import BPNeural
from ase.db import connect
from jbutil import get_composition
from ase.io import write

BPcalc = BPNeural(json='networks/db0-PS/trained-parameters.json')

config = ['fcc', 'bcc']
color = ['b', 'r']

f, ax = plt.subplots(1, 2, figsize=(10, 5))


for i, cfg in enumerate(config):

    # Open ground states file and collect a list of all GS configs
    with open('CuPd_{0}/gs.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        GS = []

        for line in lines:
            # Composition, DFT energy, Fit energy, Configuration
            comp, dftE, fitE, s = line.split()

            GS.append(s)

    # Open fit file and collect a list of all configs
    with open('CuPd_{0}/fit.out'.format(cfg), 'r') as f:
        lines = f.readlines()

        S = []

        for line in lines:
            # Composition, DFT energy, Fit energy, Fit error, Weight, Configuration
            comp, dftE, fitE, err, w, s = line.split()

            S.append(s)

    dft, fit, var = [], [], []
    
    for s in S:
        with jasp('CuPd_{0}/{1}'.format(cfg, s)) as calc:
            atoms = calc.get_atoms()
            n = len(atoms)
            
            var.append(get_composition(atoms, 'Cu'))
            dft.append(atoms.get_potential_energy() / n)

            atoms.set_calculator(BPcalc)
            fit.append(atoms.get_potential_energy() / n)

    var = np.array(var)
    dft = np.array(dft)
    fit = np.array(fit)
    res = fit - dft

    ax[0].scatter(dft, fit, c=color[i], edgecolor='none', marker='.', s=40, zorder=9, label='{0}'.format(cfg))

    ax[1].scatter(var, res, c=color[i], edgecolor='none', marker='.', s=40, zorder=9)

    anom = []

    for j, s in enumerate(S):

        if s in GS:
            plt.text(var[j], float(res[j])-0.006,
                 '{0}'.format(s),
                 color=color[i], weight='bold',
                 va='top', ha='center',
                 zorder=99)

        if abs(res[j]) > 0.9:
            anom.append(s)
            plt.text(var[j], float(res[j])-0.006,
                 '{0}'.format(s),
                 color=color[i],
                 va='top', ha='center',
                 zorder=99)

    for a in anom:
        with jasp('CuPd_{0}/{1}'.format(cfg, a)) as calc:
            atoms = calc.get_atoms()
        write('./images/{0}-{1}-A.png'.format(cfg, a), atoms, rotation='45x, 45y')

    for a in GS:
        with jasp('CuPd_{0}/{1}'.format(cfg, a)) as calc:
            atoms = calc.get_atoms()
        write('./images/{0}-{1}-GS.png'.format(cfg, a), atoms, rotation='45x, 45y')

ax[1].plot([0.0, 1.0], [0, 0], 'k-')
ax[1].set_xlim(0.0, 1.0)
ax[1].set_xlabel('Composition (Cu)')
ax[1].set_ylabel('Residuals to fit, Neural - DFT (eV/atom)')

#ax[0].plot([-0.6, -0.25], [-0.6, -0.25], 'k-', zorder=1)
ax[0].set_xlabel('DFT total energy (eV/atom)')
#ax[0].set_xlim(-0.6, -0.25)

ax[0].set_ylabel('Neural fitted total energy (eV/atom)')
#ax[0].set_ylim(-0.6, -0.25)
ax[1].set_xticks(ax[1].get_xticks()[1:])
ax[0].legend(loc='best')
plt.tight_layout()

plt.savefig('images/db0-PS-eosfit.png')
plt.show()
#+END_SRC

#+RESULTS:



#+begin_example
['0', '27', '19', '505', '28', '1']
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '11', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '37', '39', '40', '41', '42', '44', '46', '47', '49', '53', '54', '56', '102', '104', '119', '63', '70', '74', '77', '78', '84', '95', '98', '140', '142', '174', '230', '234', '274', '276', '438', '446', '502', '505', '545', '548', '552']
[ 1.     0.     0.5    0.5    0.667  0.333  0.667  0.333  0.667  0.333  0.5
  0.75   0.5    0.25   0.75   0.25   0.75   0.5    0.25   0.75   0.5    0.25
  0.75   0.5    0.25   0.75   0.25   0.6    0.4    0.2    0.8    0.6    0.2
  0.6    0.6    0.4    0.6    0.4    0.2    0.333  0.167  0.333  0.333
  0.333  0.667  0.5    0.333  0.5    0.333  0.667  0.571  0.429  0.286
  0.571  0.429  0.5    0.5    0.625  0.5    0.625  0.375  0.625  0.5    0.5  ]
[-0.287 -0.126 -0.186 -0.198 -0.421 -1.681 -0.237 -0.194 -0.34  -0.429
 -1.871 -0.28  -0.212 -0.213 -0.27  -0.186 -0.258 -0.196 -0.197 -0.297
 -0.316 -0.335 -0.63  -1.146 -0.792 -0.243 -0.159 -0.228 -0.218 -0.398
 -0.282 -0.227 -0.249 -0.243 -0.558 -0.599 -1.925 -0.407 -1.038 -0.184
 -0.288 -0.354 -0.339 -0.338 -0.261 -0.305 -0.258 -0.273 -0.28  -0.246
 -0.226 -0.205 -0.554 -0.329 -0.352 -0.365 -0.373 -0.249 -0.28  -0.231
 -0.181 -0.238 -0.242 -0.264]
['0', '26', '603', '3', '1']
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '34', '35', '36', '37', '38', '39', '41', '45', '46', '47', '48', '49', '50', '51', '53', '54', '55', '56', '105', '112', '116', '130', '134', '60', '81', '90', '93', '95', '441', '479', '494', '603', '618', '1098']
[ 1.     0.     0.5    0.5    0.667  0.333  0.667  0.333  0.667  0.333
  0.75   0.5    0.25   0.75   0.5    0.25   0.75   0.5    0.25   0.75   0.25
  0.75   0.5    0.25   0.75   0.25   0.75   0.5    0.25   0.8    0.6    0.2
  0.8    0.6    0.6    0.4    0.4    0.8    0.8    0.6    0.6    0.4    0.4
  0.2    0.8    0.6    0.4    0.4    0.2    0.833  0.167  0.5    0.667
  0.333  0.5    0.833  0.667  0.5    0.333  0.5    0.625  0.625  0.625
  0.625  0.778]
[-0.301 -0.114 -0.199 -0.194 -2.457 -2.973 -0.249 -0.245 -0.235 -0.165
 -0.707 -1.851 -0.972 -0.308 -0.438 -0.439 -0.263 -0.188 -0.168 -0.256
 -0.139 -0.304 -0.26  -0.244 -0.288 -0.145 -0.246 -0.141 -0.121 -3.525
 -3.474 -4.745 -0.287 -0.258 -0.756 -0.308 -0.727 -0.31  -0.348 -0.229
 -0.396 -0.218 -0.449 -0.459 -0.295 -0.203 -0.193 -0.165 -0.18  -1.566
 -0.954 -1.784 -0.226 -0.158 -0.178 -0.308 -0.225 -0.274 -0.22  -0.19
 -0.208 -0.197 -0.213 -0.219 -0.251]
#+end_example
